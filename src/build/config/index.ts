/* eslint-disable no-console */
import { cssModulesPlugin } from "@asn.aeb/esbuild-css-modules-plugin"
// @ts-ignore
import { tsconfigPathsPlugin } from "esbuild-plugin-tsconfig-paths"
import * as esbuild from "esbuild"
import { copy } from 'esbuild-plugin-copy'
import globby from "globby"

import type { HeroImage, HeroImageBase, HeroImageFocalPoints, Project, WidthMap } from "../types.ts"

const focalPoints: HeroImageFocalPoints[] = [
  {
    "anime": {
      main: [0.49, 0.385],
      secondary: [0.57, 0.65],
    }
  },
  {
    "artbrut": {
      main: [0.465, 0.38],
      secondary: [0.23, 0.21],
    }
  },
  {
    "comic": {
      main: [0.41, 0.36],
      secondary: [0.35, 0.72],
    }
  },
  {
    "fanciful": {
      main: [0.43, 0.6],
      secondary: [0.61, 0.44],
    }
  },
  {
    "fantasy": {
      main: [0.49, 0.59],
      secondary: [0.33, 0.34],
    }
  },
  {
    "farcical": {
      main: [0.485, 0.6],
      secondary: [0.35, 0.43],
    }
  },
  {
    "fauvist": {
      main: [0.33, 0.48],
      secondary: [0.30, 0.55],
    }
  },
  {
    "mystical": {
      main: [0.36, 0.575],
      secondary: [0.61, 0.30],
    }
  },
  {
    "surreal": {
      main: [0.60, 0.54],
      secondary: [0.37, 0.30],
    }
  },
]

/**
 * Resolves a glob parent directories of hero images.
 * @returns A promise that resolves to the first file that matches the glob.
 */
async function getHeroParents(): Promise<string[]> {
  const fastGlobSettings = { onlyDirectories: true, unique: true }
  return globby("src/assets/images/hero/*", fastGlobSettings)
}

/**
 * Resolves a glob to a single file.
 * @param glob The glob to resolve.
 * @returns An array of files that match the glob.
 */
export const heroParents: Promise<string[]> = getHeroParents()

const jsBanner = `/**
 * ---DO NOT EDIT THIS FILE---
 * it is generated by the build process
 * instead edit the source file
 *
 * main site sources are in src/assets/javascripts directory
 */
`
const cssBanner = `/**
  * ---DO NOT EDIT THIS FILE---
  * it is generated by the build process
  * instead edit the source file
  *
  * sources are in src/assets/stylesheets directory
  *
  */
`

export const webConfig: esbuild.BuildOptions = {
  bundle: true,
  minify: false,
  sourcemap: true,
  metafile: true,
  banner: { js: jsBanner, css: cssBanner },
  format: "esm",
  platform: "browser",
  target: "es2018",
  outbase: "src",
  chunkNames: "[dir]/assets/javascripts/chunks/[name].[hash]",
  assetNames: "[dir]/[name].[hash]",

  loader: {
    ".js": "js",
    ".ts": "ts",
    ".tsx": "tsx",
    ".css": "css",
    ".scss": "css",
    ".sass": "css",
    ".woff": "file",
    ".woff2": "file",
    ".png": "file",
    ".svg": "file",
    ".webp": "file",
    ".avif": "file",
  },
  outExtension: {".js": ".js", ".css": ".css"},
  splitting: false,
  plugins: [
    tsconfigPathsPlugin({
      cwd: process.cwd(),
      tsconfig: "tsconfig.json",
      filter: /src\/assets\/javascripts\/index.ts/
    }),
    cssModulesPlugin({
      emitCssBundle: {
        filename: "bundle.css",
      },
    }),
    copy({
      watch: true,
      verbose: true,
      resolveFrom: "cwd",
      globbyOptions: { gitignore: true, extglob: true, unique: true },
      assets: [
        { from: "./src/assets/images/*.+(svg|png|webp)", to: "./docs/assets/images" },
      ],
    }),
  ],
}

export const baseProject: Project = {
  entryPoints: ["src/assets/javascripts/index.ts", "src/assets/stylesheets/bundle.css"
  ],
  tsconfig: "tsconfig.json",
  entryNames: "[dir]/[name].[hash]",
  platform: "browser",
  outdir: "docs",
}

/**
 * Resolves a glob to a single file.
 * @param glob The glob to resolve.
 * @param fastGlobOptions Options to pass to fast-glob.
 * @returns A promise that resolves to the first file that matches the glob.
 */
async function resolveGlob(glob: string, fastGlobOptions?: {}): Promise<string[]> {
  try {
    const result = await globby(glob, fastGlobOptions)
    if (result.length === 0) {
      throw new Error(`Glob "${glob}" did not match any files`)
    } else {
      return result
    }
  } catch (error) {

    console.error("Error resolving glob:", error)
    throw error
  }
}

/**
 * Generates the Srcset for a given image.
 * @param image The image to generate the Srcset for.
 * @returns A promise that resolves to the Srcset for the image.
 */
export async function generateSrcset(image: HeroImageBase): Promise<string> {
  const entries = await Promise.all(
    Object.entries(image.widths).map(async ([width, src]) => {
      return `${await resolveGlob(src, { onlyFiles: true, unique: true })} ${width}w`
    })
  )
  return entries.join(", ")
}

export const heroImages = async () => {
  const parents = await resolveGlob("src/assets/images/hero/*", { onlyDirectories: true })
  const retrieveKey = (filePath: string) => filePath.split("/").pop()
  const getWidthMaps = async () => {
    const results = await Promise.allSettled(
      parents.map(async (parent: string) => {
        const key = retrieveKey(parent)
        const heroFilePattern = `${key}_{1280,1920,2560,3840}.avif`
        const children = await globby(`${parent}/${heroFilePattern}`, { onlyFiles: true, unique: true })
        const flattenedWidths: WidthMap = children.reduce<WidthMap>((acc: WidthMap, child: string) => {
          const width: number | undefined = [1280, 1920, 2560, 3840].find((w: number) => child.includes(w.toString()))
          if (width) {
            acc[width] = child
          }
          return acc
        }, {} as WidthMap) // Initialize acc as an empty WidthMap
        const focalPoint = focalPoints.find((value: HeroImageFocalPoints) => Object.keys(value)[0] === key)
        const imageFocii = focalPoint && key ? focalPoint[key] : { main: [0.5, 0.5], secondary: [0.5, 0.5] }
        const srcset = await generateSrcset({ parent, widths: flattenedWidths })
        return [key, { parent, widths: flattenedWidths, srcset, "focalPoints": imageFocii }] as [string, HeroImage]
      })
    )

    return Object.fromEntries(
      results
        .filter((result): result is PromiseFulfilledResult<[string, HeroImage]> => result.status === "fulfilled")
        .map(result => result.value)
    )
  }
  return getWidthMaps()
}
