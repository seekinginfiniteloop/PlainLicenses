/**
 * @module impactText
 * @description Orchestrates the text impact animation for the hero section.
 *
 * @overview
 * This module facilitates element creation and text handling for the hero section's
 * impact animation. It provides utility functions for converting text content into
 * animated div elements, generating particle configurations, and creating impact
 * animations for different text types.
 *
 ** Key Features:
 * - Prepares text elements for impact animation, including the call to action button
 * - Randomly generates particle configurations for debris effects
 * - Pieces together timelines generated by the impact effects module
 * - Uses GSAP's matchMedia plugin to handle reduced motion preferences
 *
 * @requires GSAP (GreenSock Animation Platform)
 * @requires IMPACT_CONFIG - Configuration for impact animations
 * @requires impactEffects module
 *
 * @exports animateText: Main pipeline function to animate text elements
 *
 ** Core Utilities:
 * - wordsToDivs: Converts text to animated div elements
 * - createDebrisConfig: Generates particle configurations
 * - createImpactAnimation: Constructs impact animation timelines
 *
 * {@link https://greensock.com/docs/} GSAP Documentation
 * @license Plain-Unlicense (Public Domain)
 * @copyright No rights reserved.
 */


import gsap from 'gsap'

import { IMPACT_CONFIG, IMPACT_ELEMENT_CONFIG } from '~/config'
import * as effects from './impactEffects'
import { logger } from '~/log'
import { GsapMatchMediaConditions, ImpactLetter, ImpactTimeline, LetterAnimationConfig, ParticleConfig } from './types'
import { memoize } from '~/utilities/cache'
import { ImpactElementConfig } from '~/config/types'

const impactConfig = IMPACT_CONFIG

const elementConfigs = IMPACT_ELEMENT_CONFIG

// ================== Utility Functions ==================

const getRandomSize = gsap.utils.random(impactConfig.minParticleSize, impactConfig.maxParticleSize, 0.5, true)
const getRandomRadii = gsap.utils.random(25, 95, 5, true)
const getRandomBorderRadius = () => `${getRandomRadii()}% ${getRandomRadii()}% ${getRandomRadii()}% ${getRandomRadii()}%`

const getSpacingTime = gsap.utils.random(0.5, 1.5, 0.1, true)

const getDebrisCount = memoize((minParticles?: number, maxParticles?: number) => {
  return gsap.utils.random(minParticles || impactConfig.minParticles, maxParticles || impactConfig.maxParticles, 1, true)
})


const particleSizeConfig: ParticleConfig[] = Array.from({ length: impactConfig.maxParticles }, () => ({
  size: getRandomSize(),
  borderRadius: getRandomBorderRadius(),
  color: effects.getRandomStartColor()
}))

/**
 * Generates a particle configuration based on the length of the text content. Simply returns the default particle configuration if the length is less than the maximum number of particles. Otherwise, it generates a new configuration for the difference, and concatenates it with the default configuration.
 * @param length The length of the text content.
 * @returns An array of particle configurations.
 */
const getParticleConfig = (length: number): ParticleConfig[] => {
  if (length < particleSizeConfig.length) {
    return gsap.utils.shuffle(particleSizeConfig)
  } else {
    let newConfig = Array.from({ length: length - particleSizeConfig.length }, () => ({
      size: getRandomSize(),
      borderRadius: getRandomBorderRadius(),
      color: effects.getRandomStartColor()
    }))
    return particleSizeConfig.concat(newConfig)
  }
}

/**
 * Creates a div element with the specified character.
 * @param char The character to display.
 * @param index The index of the character.
 * @param isButton A boolean flag to determine if the character is part of a button.
 * @returns A div element.
 */
function createCharDiv(char: string, index?: number, isButton: boolean = false): HTMLDivElement {
  const div = document.createElement('div')
  div.textContent = char
  div.classList.add(
    isButton ? 'button-char' : 'meteor',
    ...(index !== undefined ? [`meteor--${index}`] : [])
  )

  if (isButton) {
    div.classList.add('button-char')
  }

  return div
}


/**
 * Converts text content of an element into individual divs.
 * @param el The element to convert.
 * @param button A boolean flag to determine if the text is a button.
 * @returns A document fragment containing the divs.
 */
function wordsToDivs(el: HTMLElement, button: boolean = false): DocumentFragment {
  const text = el.innerHTML || ''
  const fragment = document.createDocumentFragment()

  requestAnimationFrame(() => {
    el.innerHTML = ""
  })

  if (button) {
    const buttonWords = text.split(' ').map(word => {
      const wordDiv = document.createElement('div')
      wordDiv.classList.add('button-text', 'button-word')

      word.split('').forEach(char => {
        wordDiv.appendChild(createCharDiv(char, undefined, true))
      })

      return wordDiv
    })

    Object.assign(el.style, {
      backgroundColor: 'var(--button-background-color)',
      opacity: '0',
      visibility: 'hidden',
    })

    fragment.append(...buttonWords)
  } else {
    text.split('').forEach((char, idx) => {
      if (char === ' ') {
        fragment.appendChild(document.createTextNode(' '))
      } else {
        const charDiv = createCharDiv(char, idx)
        Object.assign(charDiv.style, {
          color: 'inherit',
          visibility: 'hidden',
          opacity: '0'
        })
        fragment.appendChild(charDiv)
      }
    })
  }

  return fragment
}

// ================== Debris Creation ==================

/**
 * Creates debris particles for a target element.
 * @param target The target element.
 * @param axis The axis of the debris' stagger effect.
 * @param textType The type of text element.
 * @param maxCount The maximum number of particles.
 * @returns An ImpactLetter object.
 */

function createDebrisConfig(target: HTMLElement, axis: 'x' | 'y', textType: 'h1' | 'p' | 'button', maxCount: number = impactConfig.maxParticles): ImpactLetter {
  const debrisCount = getDebrisCount(impactConfig.minParticles, maxCount)()
  const container = document.createElement('div')
  const particleConfig = getParticleConfig(debrisCount)

  container.classList.add('debris-container')

  const particles = Array.from({ length: debrisCount }, (_, i) => {
    const cfg = particleConfig[i]
    const particle = document.createElement('div')
    Object.assign(particle, {
      style: {
        width: `${cfg.size}px`,
        height: `${cfg.size}px`,
        backgroundColor: cfg.color,
        borderRadius: cfg.borderRadius,
      }
    })
    particle.classList.add("debris", `debris-${i}`)

    container.appendChild(particle)
    return particle
  })

  return {
    axis,
    debris: {
      container,
      particles,
      letter: target
    },
    letter: target as HTMLDivElement,
    originRect: target.getBoundingClientRect(),
    textType
  }
}

/**
 * Creates an impact animation for a target element.
 * @param config The configuration for the element.
 * @returns An ImpactTimeline object.
 */
const createImpactAnimation = (config: ImpactElementConfig): LetterAnimationConfig => {
    const element = document.getElementById(config.id.slice(1)) as HTMLElement
    const fragment = wordsToDivs(element, !!config.isButton)
    const targets = Array.from(fragment.children)

    const debrisConfig = targets.map((target) =>
      createDebrisConfig(
        target as HTMLElement,
        config.axis as 'x' | 'y',
        config.textType as 'h1' | 'p' | 'button',
        config.maxParticles
      )
    )

    return {
      impactLetters: config.isButton
        ? debrisConfig.map(letter => ({
            ...letter,
            buttonText: targets as HTMLDivElement[]
          }))
        : debrisConfig,
      parentFragment: fragment
    }
  }


/**
 * Creates a timeline for the impact text animation.
 * @returns An ImpactTimeline object.
 */
export function animateText(): ImpactTimeline {
  const mainTimeline = gsap.timeline({ paused: true })
  gsap.matchMedia().add(
    {
      lowMotion: 'prefers-reduced-motion: reduce',
      normalMotion: 'prefers-reduced-motion: no-preference'
    },
    (context) => {
      const { lowMotion } = context.conditions as GsapMatchMediaConditions

      if (lowMotion) {
        logger.info(`User prefers reduced motion`)
        mainTimeline.from(
          elementConfigs.map(config => config.id),
          {
            opacity: 0,
            duration: 1.5,
            stagger: 0.2,
            delay: 0.5,
            visibility: 'hidden',
            filter: 'hue-rotate(120deg)',
          },
          0
        )
      } else {
        logger.info(`User prefers normal motion`)

        elementConfigs.forEach((config, index) => {
          const impactConfig = createImpactAnimation(config)
          mainTimeline.add(
            effects.constructImpactTimeline(
              impactConfig,
              `${config.textType}Impact`
            ),
            index === 0 ? '1' : `-=${getSpacingTime.toString()}`
          )
        })
      }
    }
  )

  return mainTimeline
}
