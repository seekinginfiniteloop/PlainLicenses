{
  "version": 3,
  "sources": ["../src/cache_worker.ts"],
  "sourcesContent": ["/**\n * Cache worker for precaching and caching strategies\n * @module cache_worker\n *\n * @license Plain-Unlicense\n * @author Adam Poulemanos <adam<at>plainlicense<dot>org>\n * @copyright No rights reserved.\n */\nimport { urls, version, cacheName } from \"~worker/cache_meta.json\";\nexport type {};\ndeclare const self: ServiceWorkerGlobalScope;\n// Configuration types\ninterface CacheConfig {\n    cacheName: string;\n    urls: string[];\n    version: number;\n}\ntype CacheUrls = {\n    urls: string[];\n};\ninterface Payload {\n    type: \"CACHE_CONFIG\" | \"CACHE_URLS\";\n    payload: CacheConfig | CacheUrls;\n}\nlet CONFIG: CacheConfig = {\n    cacheName: cacheName || \"plain-license-v1\",\n    urls: urls || [],\n    version: version || Date.now(),\n};\n/**\n * Check if we're in development mode\n * @returns boolean\n */\nconst isDev = (): boolean => {\n    const { origin, hostname, port } = self.location;\n    return (hostname === \"localhost\" ||\n        hostname === \"127.0.0.1\" ||\n        port === \"8000\" ||\n        origin.includes(\"localhost\"));\n};\n// simple logger utility; only logs in development\nconst logger = {\n    error: (message: string, error?: Error) => {\n        if (isDev()) {\n            if (error instanceof CacheError) {\n                console.error(`[ServiceWorker] Cache Error: ${message}`);\n                console.error(error.toString());\n            }\n            else if (error instanceof NetworkError) {\n                console.error(`[ServiceWorker] Network Error: ${message}`);\n                console.error(`Status: ${error.status || \"unknown\"}`);\n                console.error(error.message);\n            }\n            else if (error) {\n                console.error(`[ServiceWorker] ${message}`);\n                console.error(error);\n            }\n        }\n    },\n    info: (message: string) => {\n        if (isDev()) {\n            console.info(`[ServiceWorker] ${message}`);\n        }\n    },\n};\n/** ======================\n *    Custom Errors\n *========================**/\n// represents Cache errors\nclass CacheError extends Error {\n    constructor(message: string, public readonly cause?: Error) {\n        super(message);\n        this.name = \"CacheError\";\n        // Set the cause on the error object for error chaining\n        if (cause && \"cause\" in Error) {\n            Object.defineProperty(this, \"cause\", {\n                value: cause,\n                configurable: true,\n                writable: true,\n            });\n        }\n    }\n    toString(): string {\n        return this.cause ? `${this.message}\\nCaused by: ${this.cause.toString()}` : this.message;\n    }\n}\n// represents network errors\nclass NetworkError extends Error {\n    constructor(message: string, public readonly status?: number) {\n        super(message);\n        this.name = \"NetworkError\";\n        // Include the status in the error message if available\n        if (status) {\n            this.message = `${message} (HTTP ${status})`;\n        }\n    }\n}\n/**\n * Get the hash from a file path\n * @param s string - file path\n * @returns string | null\n */\nconst get_hash = (s: string): string | null => {\n    try {\n        const split = s.split(\"/\")[s.split(\"/\").length - 1].split(\".\");\n        if (split.length >= 3) {\n            return split[split.length - 2];\n        }\n        else {\n            return null;\n        }\n    }\n    catch (_error) {\n        logger.error(\"Failed to get hash from string:\", _error as Error);\n        return null;\n    }\n};\nconst normalizeUrl = (url: string | URL | Request): URL => {\n    return (url instanceof URL ? url\n        : url instanceof Request ? new URL(url.url)\n            : new URL(url));\n};\nconst normalizeRequest = (url: string | URL | Request): Request => {\n    return url instanceof Request ? url : new Request(url);\n};\n/**\n * Cache manager for managing cache operations\n *\n * @method init - Initialize cache configuration\n * @method cleanup - Cleanup old caches\n * @method precache - Precache all the urls in the cache configuration\n */\nclass CacheManager {\n    private config: CacheConfig = CONFIG;\n    private cache: Cache | null = null;\n    public cacheKeys: string[] = [];\n    constructor() {\n        this.init();\n    }\n    // gets the cache configuration\n    async init(): Promise<void> {\n        this.config = CONFIG;\n        this.cache = await caches.open(this.config.cacheName);\n        this.cacheKeys = await caches.keys();\n        this.validateConfig();\n    }\n    public async getCache(): Promise<Cache> {\n        if (!this.cache) {\n            this.cache = await caches.open(this.config.cacheName);\n        }\n        return this.cache;\n    }\n    public async updateKeys(): Promise<string[]> {\n        this.cacheKeys = await caches.keys();\n        return this.cacheKeys;\n    }\n    public async getCacheKeys(): Promise<string[]> {\n        if (!this.cacheKeys.length) {\n            this.cacheKeys = await caches.keys();\n            logger.info(`Cache keys updated, keys: ${this.cacheKeys.join(\", \")}`);\n        }\n        return this.cacheKeys;\n    }\n    public async cacheIt(request: string | URL | Request, response?: Response): Promise<void> {\n        request = normalizeRequest(request);\n        const cache = await this.getCache();\n        if (response && response.ok) {\n            await cache.put(request, response.clone());\n            this.cacheKeys.push(request.toString());\n            logger.info(\"cache complete\");\n            return;\n        }\n        try {\n            if (await cache.match(request)) {\n                return;\n            }\n            else {\n                await cache.add(request);\n                this.cacheKeys.push(request.toString());\n                logger.info(\"cache complete\");\n            }\n        }\n        catch (error) {\n            throw new CacheError(\"Failed to cache url\", error as Error);\n        }\n        finally {\n            await this.checkForStaleKey(request);\n        }\n    }\n    /**\n     * Validate the cache configuration\n     */\n    private validateConfig(): void {\n        if (!this.config.cacheName || !this.config.cacheName.length || !this.config.cacheName.trim()) {\n            throw new CacheError(\"Cache name is required\");\n        }\n        if (!this.config.urls || !this.config.urls.length) {\n            throw new CacheError(\"At least one url is required. Our poor cache worker has nothing to do.\");\n        }\n        logger.info(\"Cache configuration validated\");\n    }\n    private async toBaseName(s: string | URL | Request): Promise<string> {\n        try {\n            const url = normalizeUrl(s);\n            const file = url.pathname.split(\"/\")?.pop();\n            const parts = file?.split(\".\");\n            if (!parts) {\n                logger.error(\"Failed to get base name: No parts found\");\n                return \"\";\n            }\n            return parts.length >= 2 ? parts.slice(0, -2).join(\".\") : parts[0];\n        }\n        catch (error) {\n            logger.error(\"Failed to get base name:\", error as Error);\n            return \"\";\n        }\n    }\n    /**\n     * Checks for and deletes stale cache keys.\n     * @param url The URL/string/Request to check for stale keys against.\n     */\n    private async checkForStaleKey(url: string | URL | Request): Promise<void> {\n        try {\n            url = normalizeUrl(url);\n            const cache = await this.getCache();\n            const baseName = await this.toBaseName(url);\n            const staleKeys = this.cacheKeys.filter((key) => key.includes(baseName) && url.toString() !== key);\n            if (staleKeys.length) {\n                logger.info(`Stale keys found: ${staleKeys.join(\", \")}`);\n                await Promise.all(staleKeys.map((key) => cache.delete(key)));\n                logger.info(\"Stale keys deleted\");\n            }\n        }\n        catch (error) {\n            logger.error(\"Failed to check for stale keys:\", error as Error);\n        }\n    }\n    /**\n     * Cleanup old caches\n     */\n    async cleanup(): Promise<void> {\n        try {\n            const deletionPromises = await this.getCacheKeys().then((keys) => keys.filter((key) => key !== this.config.cacheName).map((key) => caches.delete(key)));\n            await Promise.all(deletionPromises);\n            logger.info(\"Old caches cleaned up\");\n        }\n        catch (error) {\n            throw new CacheError(\"Failed to cleanup caches\", error as Error);\n        }\n    }\n    /**\n     * Precache all the urls in the cache configuration\n     */\n    async precache(): Promise<void> {\n        try {\n            const cache = await this.getCache();\n            await cache.addAll(this.config.urls);\n            for (const url of this.config.urls) {\n                await this.checkForStaleKey(url);\n            }\n            logger.info(\"Precaching complete\");\n        }\n        catch (error) {\n            throw new CacheError(\"Failed to precache urls\", error as Error);\n        }\n    }\n    /**\n     * Attempt to fetch a resource\n     * @param request Request | string | URL - request to fetch\n     * @param init RequestInit - request options\n     * @returns Promise<Response> - response\n     */\n    private async tryFetch(request: Request | string | URL, init?: RequestInit): Promise<Response> {\n        try {\n            const response = await fetch(request, init);\n            if (!response.ok) {\n                throw new NetworkError(\"Network response was not ok\", response.status);\n            }\n            this.cacheKeys.push(request.toString());\n            return response;\n        }\n        catch (error) {\n            logger.error(\"Failed to fetch:\", error as Error);\n            throw new NetworkError(`Failed to fetch request for ${request.toString()}`, 500);\n        }\n        finally {\n            await this.checkForStaleKey(request);\n        }\n    }\n    /**\n     * Fallback fetch for failed fetches. Attempts to remove the hash from the url and fetch again. We're basically checking if the build process went wrong.\n     * @param request Request | string | URL - request to fetch\n     * @param init RequestInit - request options\n     * @returns Promise<Response> - response\n     */\n    async fallbackFetch(request: Request | string | URL, init?: RequestInit): Promise<Response> {\n        request = normalizeRequest(request);\n        const response = await fetch(request, init);\n        if (response.ok) {\n            return response;\n        }\n        else {\n            const errorMessage = response instanceof Response ? await response.json() : \"No response\";\n            logger.error(\"Failed to fetch:\", new Error(errorMessage));\n            logger.error(\"Attempting fallback fetch\");\n            const url = normalizeUrl(request);\n            const hash = get_hash(url.pathname);\n            if (!hash && url.origin === self.location.origin) {\n                const file = url.pathname.split(\"/\")?.pop();\n                const parts = file?.split(\".\");\n                const name = parts?.slice(0, -1).join(\".\");\n                const ext = parts?.slice(-1)[0];\n                const hashlessUrl = new RegExp(`${name}\\.[a-fA-F0-9]{8}\\.${ext}`);\n                const inConfig = this.config.urls.find((u) => hashlessUrl.test(u));\n                if (inConfig) {\n                    return this.tryFetch(inConfig, init);\n                }\n            }\n            return this.tryFetch(url.pathname.replace(`.${hash}`, \"\"), init);\n        }\n    }\n}\n// Initialize cache manager\nconst cacheManager = new CacheManager();\n/**\n * Cache strategies for fetching resources\n * @method @static cacheFirst\n * @method @static staleWhileRevalidate\n */\nclass CacheStrategies {\n    /**\n     * Cache first strategy\n     * @param request Request\n     * @returns Promise<Response>\n     */\n    static async cacheFirst(request: Request): Promise<Response> {\n        request = normalizeRequest(request);\n        const cache = await cacheManager.getCache();\n        const cached = await cache.match(request);\n        if (cached) {\n            return cached;\n        }\n        try {\n            const response = await cacheManager.fallbackFetch(request);\n            if (!response.ok) {\n                throw new NetworkError(\"Network response was not ok\", response.status);\n            }\n            await cacheManager.cacheIt(request, response.clone());\n            return response;\n        }\n        catch (error) {\n            logger.error(\"Cache first strategy failed:\", error as Error);\n            throw error;\n        }\n    }\n    /**\n     * Stale while revalidate strategy\n     * @param request Request\n     * @returns Promise<Response>\n     */\n    static async staleWhileRevalidate(request: Request): Promise<Response> {\n        const cache = await cacheManager.getCache();\n        const cached = await cache.match(request);\n        const networkPromise = await cacheManager\n            .fallbackFetch(request)\n            .then((response) => {\n            if (!response.ok) {\n                throw new NetworkError(\"Network response was not ok\", response.status);\n            }\n            cacheManager.cacheIt(request, response.clone());\n            return response;\n        })\n            .catch((error) => {\n            logger.error(\"Network fetch failed:\", error as Error);\n            throw error;\n        });\n        return cached ?? networkPromise;\n    }\n}\n// install the service worker\nself.addEventListener(\"install\", (event: ExtendableEvent) => {\n    event.waitUntil((async () => {\n        try {\n            await cacheManager.init();\n            await self.skipWaiting();\n            await cacheManager.precache();\n            logger.info(\"Service worker installed\");\n        }\n        catch (error) {\n            logger.error(\"Install failed:\", error as Error);\n            throw error;\n        }\n    })());\n});\n/**\n * Activate the service worker and cleanup old caches\n */\nself.addEventListener(\"activate\", (event: ExtendableEvent) => {\n    event.waitUntil((async () => {\n        try {\n            await cacheManager.cleanup();\n            await self.clients.claim();\n            logger.info(\"Service worker activated\");\n        }\n        catch (error) {\n            logger.error(\"Activation failed:\", error as Error);\n            throw error;\n        }\n    })());\n});\n/**\n * Fetch event listener for handling requests\n */\nself.addEventListener(\"fetch\", (event: FetchEvent) => {\n    if (event.request.method !== \"GET\") {\n        return;\n    }\n    const url = new URL(event.request.url);\n    if (!url.origin.startsWith(self.location.origin)) {\n        return;\n    }\n    // We use stale-while-revalidate for assets that are more regularly updated\n    const isRefreshAsset = /\\.(js|css|html|json)$/i.test(url.pathname);\n    event.respondWith(isRefreshAsset ?\n        CacheStrategies.staleWhileRevalidate(event.request)\n        : CacheStrategies.cacheFirst(event.request));\n    logger.info(`Fetching: ${url.pathname}`);\n});\nself.addEventListener(\"message\", (event: ExtendableMessageEvent) => {\n    const payload = event.data as Payload;\n    if (payload.type === \"CACHE_URLS\" && payload.payload && payload.payload.urls) {\n        CONFIG.urls.push(...payload.payload.urls);\n        for (const url of payload.payload.urls) {\n            CacheStrategies.cacheFirst(new Request(url));\n        }\n    }\n});\n"],
  "mappings": "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",
  "names": []
}
