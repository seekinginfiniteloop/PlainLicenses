/**
 * ---DO NOT EDIT THIS FILE---
 * The build process generates this file
 * You should edit the source file instead
 *
 * sources are in: src/assets/javascripts directory
 */

"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/focus-visible/dist/focus-visible.js
  var require_focus_visible = __commonJS({
    "node_modules/focus-visible/dist/focus-visible.js"(exports, module) {
      "use strict";
      (function(global, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory() : typeof define === "function" && define.amd ? define(factory) : factory();
      })(exports, function() {
        "use strict";
        function applyFocusVisiblePolyfill(scope) {
          var hadKeyboardEvent = true;
          var hadFocusVisibleRecently = false;
          var hadFocusVisibleRecentlyTimeout = null;
          var inputTypesAllowlist = {
            text: true,
            search: true,
            url: true,
            tel: true,
            email: true,
            password: true,
            number: true,
            date: true,
            month: true,
            week: true,
            time: true,
            datetime: true,
            "datetime-local": true
          };
          function isValidFocusTarget(el) {
            if (el && el !== document && el.nodeName !== "HTML" && el.nodeName !== "BODY" && "classList" in el && "contains" in el.classList) {
              return true;
            }
            return false;
          }
          function focusTriggersKeyboardModality(el) {
            var type = el.type;
            var tagName = el.tagName;
            if (tagName === "INPUT" && inputTypesAllowlist[type] && !el.readOnly) {
              return true;
            }
            if (tagName === "TEXTAREA" && !el.readOnly) {
              return true;
            }
            if (el.isContentEditable) {
              return true;
            }
            return false;
          }
          function addFocusVisibleClass(el) {
            if (el.classList.contains("focus-visible")) {
              return;
            }
            el.classList.add("focus-visible");
            el.setAttribute("data-focus-visible-added", "");
          }
          function removeFocusVisibleClass(el) {
            if (!el.hasAttribute("data-focus-visible-added")) {
              return;
            }
            el.classList.remove("focus-visible");
            el.removeAttribute("data-focus-visible-added");
          }
          function onKeyDown(e) {
            if (e.metaKey || e.altKey || e.ctrlKey) {
              return;
            }
            if (isValidFocusTarget(scope.activeElement)) {
              addFocusVisibleClass(scope.activeElement);
            }
            hadKeyboardEvent = true;
          }
          function onPointerDown(e) {
            hadKeyboardEvent = false;
          }
          function onFocus(e) {
            if (!isValidFocusTarget(e.target)) {
              return;
            }
            if (hadKeyboardEvent || focusTriggersKeyboardModality(e.target)) {
              addFocusVisibleClass(e.target);
            }
          }
          function onBlur(e) {
            if (!isValidFocusTarget(e.target)) {
              return;
            }
            if (e.target.classList.contains("focus-visible") || e.target.hasAttribute("data-focus-visible-added")) {
              hadFocusVisibleRecently = true;
              window.clearTimeout(hadFocusVisibleRecentlyTimeout);
              hadFocusVisibleRecentlyTimeout = window.setTimeout(function() {
                hadFocusVisibleRecently = false;
              }, 100);
              removeFocusVisibleClass(e.target);
            }
          }
          function onVisibilityChange(e) {
            if (document.visibilityState === "hidden") {
              if (hadFocusVisibleRecently) {
                hadKeyboardEvent = true;
              }
              addInitialPointerMoveListeners();
            }
          }
          function addInitialPointerMoveListeners() {
            document.addEventListener("mousemove", onInitialPointerMove);
            document.addEventListener("mousedown", onInitialPointerMove);
            document.addEventListener("mouseup", onInitialPointerMove);
            document.addEventListener("pointermove", onInitialPointerMove);
            document.addEventListener("pointerdown", onInitialPointerMove);
            document.addEventListener("pointerup", onInitialPointerMove);
            document.addEventListener("touchmove", onInitialPointerMove);
            document.addEventListener("touchstart", onInitialPointerMove);
            document.addEventListener("touchend", onInitialPointerMove);
          }
          function removeInitialPointerMoveListeners() {
            document.removeEventListener("mousemove", onInitialPointerMove);
            document.removeEventListener("mousedown", onInitialPointerMove);
            document.removeEventListener("mouseup", onInitialPointerMove);
            document.removeEventListener("pointermove", onInitialPointerMove);
            document.removeEventListener("pointerdown", onInitialPointerMove);
            document.removeEventListener("pointerup", onInitialPointerMove);
            document.removeEventListener("touchmove", onInitialPointerMove);
            document.removeEventListener("touchstart", onInitialPointerMove);
            document.removeEventListener("touchend", onInitialPointerMove);
          }
          function onInitialPointerMove(e) {
            if (e.target.nodeName && e.target.nodeName.toLowerCase() === "html") {
              return;
            }
            hadKeyboardEvent = false;
            removeInitialPointerMoveListeners();
          }
          document.addEventListener("keydown", onKeyDown, true);
          document.addEventListener("mousedown", onPointerDown, true);
          document.addEventListener("pointerdown", onPointerDown, true);
          document.addEventListener("touchstart", onPointerDown, true);
          document.addEventListener("visibilitychange", onVisibilityChange, true);
          addInitialPointerMoveListeners();
          scope.addEventListener("focus", onFocus, true);
          scope.addEventListener("blur", onBlur, true);
          if (scope.nodeType === Node.DOCUMENT_FRAGMENT_NODE && scope.host) {
            scope.host.setAttribute("data-js-focus-visible", "");
          } else if (scope.nodeType === Node.DOCUMENT_NODE) {
            document.documentElement.classList.add("js-focus-visible");
            document.documentElement.setAttribute("data-js-focus-visible", "");
          }
        }
        if (typeof window !== "undefined" && typeof document !== "undefined") {
          window.applyFocusVisiblePolyfill = applyFocusVisiblePolyfill;
          var event;
          try {
            event = new CustomEvent("focus-visible-polyfill-ready");
          } catch (error) {
            event = document.createEvent("CustomEvent");
            event.initCustomEvent("focus-visible-polyfill-ready", false, false, {});
          }
          window.dispatchEvent(event);
        }
        if (typeof document !== "undefined") {
          applyFocusVisiblePolyfill(document);
        }
      });
    }
  });

  // node_modules/escape-html/index.js
  var require_escape_html = __commonJS({
    "node_modules/escape-html/index.js"(exports, module) {
      "use strict";
      var matchHtmlRegExp = /["'&<>]/;
      module.exports = escapeHtml;
      function escapeHtml(string) {
        var str = "" + string;
        var match = matchHtmlRegExp.exec(str);
        if (!match) {
          return str;
        }
        var escape;
        var html = "";
        var index = 0;
        var lastIndex = 0;
        for (index = match.index; index < str.length; index++) {
          switch (str.charCodeAt(index)) {
            case 34:
              escape = "&quot;";
              break;
            case 38:
              escape = "&amp;";
              break;
            case 39:
              escape = "&#39;";
              break;
            case 60:
              escape = "&lt;";
              break;
            case 62:
              escape = "&gt;";
              break;
            default:
              continue;
          }
          if (lastIndex !== index) {
            html += str.substring(lastIndex, index);
          }
          lastIndex = index + 1;
          html += escape;
        }
        return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
      }
    }
  });

  // node_modules/clipboard/dist/clipboard.js
  var require_clipboard = __commonJS({
    "node_modules/clipboard/dist/clipboard.js"(exports, module) {
      "use strict";
      (function webpackUniversalModuleDefinition(root, factory) {
        if (typeof exports === "object" && typeof module === "object")
          module.exports = factory();
        else if (typeof define === "function" && define.amd)
          define([], factory);
        else if (typeof exports === "object")
          exports["ClipboardJS"] = factory();
        else
          root["ClipboardJS"] = factory();
      })(exports, function() {
        return (
          /******/
          function() {
            var __webpack_modules__ = {
              /***/
              686: (
                /***/
                function(__unused_webpack_module, __webpack_exports__, __webpack_require__2) {
                  "use strict";
                  __webpack_require__2.d(__webpack_exports__, {
                    "default": function() {
                      return (
                        /* binding */
                        clipboard
                      );
                    }
                  });
                  var tiny_emitter = __webpack_require__2(279);
                  var tiny_emitter_default = /* @__PURE__ */ __webpack_require__2.n(tiny_emitter);
                  var listen = __webpack_require__2(370);
                  var listen_default = /* @__PURE__ */ __webpack_require__2.n(listen);
                  var src_select = __webpack_require__2(817);
                  var select_default = /* @__PURE__ */ __webpack_require__2.n(src_select);
                  ;
                  function command(type) {
                    try {
                      return document.execCommand(type);
                    } catch (err) {
                      return false;
                    }
                  }
                  ;
                  var ClipboardActionCut = function ClipboardActionCut2(target) {
                    var selectedText = select_default()(target);
                    command("cut");
                    return selectedText;
                  };
                  var actions_cut = ClipboardActionCut;
                  ;
                  function createFakeElement(value) {
                    var isRTL = document.documentElement.getAttribute("dir") === "rtl";
                    var fakeElement = document.createElement("textarea");
                    fakeElement.style.fontSize = "12pt";
                    fakeElement.style.border = "0";
                    fakeElement.style.padding = "0";
                    fakeElement.style.margin = "0";
                    fakeElement.style.position = "absolute";
                    fakeElement.style[isRTL ? "right" : "left"] = "-9999px";
                    var yPosition = window.pageYOffset || document.documentElement.scrollTop;
                    fakeElement.style.top = "".concat(yPosition, "px");
                    fakeElement.setAttribute("readonly", "");
                    fakeElement.value = value;
                    return fakeElement;
                  }
                  ;
                  var fakeCopyAction = function fakeCopyAction2(value, options) {
                    var fakeElement = createFakeElement(value);
                    options.container.appendChild(fakeElement);
                    var selectedText = select_default()(fakeElement);
                    command("copy");
                    fakeElement.remove();
                    return selectedText;
                  };
                  var ClipboardActionCopy = function ClipboardActionCopy2(target) {
                    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                      container: document.body
                    };
                    var selectedText = "";
                    if (typeof target === "string") {
                      selectedText = fakeCopyAction(target, options);
                    } else if (target instanceof HTMLInputElement && !["text", "search", "url", "tel", "password"].includes(target === null || target === void 0 ? void 0 : target.type)) {
                      selectedText = fakeCopyAction(target.value, options);
                    } else {
                      selectedText = select_default()(target);
                      command("copy");
                    }
                    return selectedText;
                  };
                  var actions_copy = ClipboardActionCopy;
                  ;
                  function _typeof(obj) {
                    "@babel/helpers - typeof";
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                      _typeof = function _typeof2(obj2) {
                        return typeof obj2;
                      };
                    } else {
                      _typeof = function _typeof2(obj2) {
                        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                      };
                    }
                    return _typeof(obj);
                  }
                  var ClipboardActionDefault = function ClipboardActionDefault2() {
                    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                    var _options$action = options.action, action = _options$action === void 0 ? "copy" : _options$action, container = options.container, target = options.target, text = options.text;
                    if (action !== "copy" && action !== "cut") {
                      throw new Error('Invalid "action" value, use either "copy" or "cut"');
                    }
                    if (target !== void 0) {
                      if (target && _typeof(target) === "object" && target.nodeType === 1) {
                        if (action === "copy" && target.hasAttribute("disabled")) {
                          throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
                        }
                        if (action === "cut" && (target.hasAttribute("readonly") || target.hasAttribute("disabled"))) {
                          throw new Error(`Invalid "target" attribute. You can't cut text from elements with "readonly" or "disabled" attributes`);
                        }
                      } else {
                        throw new Error('Invalid "target" value, use a valid Element');
                      }
                    }
                    if (text) {
                      return actions_copy(text, {
                        container
                      });
                    }
                    if (target) {
                      return action === "cut" ? actions_cut(target) : actions_copy(target, {
                        container
                      });
                    }
                  };
                  var actions_default = ClipboardActionDefault;
                  ;
                  function clipboard_typeof(obj) {
                    "@babel/helpers - typeof";
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                      clipboard_typeof = function _typeof2(obj2) {
                        return typeof obj2;
                      };
                    } else {
                      clipboard_typeof = function _typeof2(obj2) {
                        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                      };
                    }
                    return clipboard_typeof(obj);
                  }
                  function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                      throw new TypeError("Cannot call a class as a function");
                    }
                  }
                  function _defineProperties2(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  function _createClass2(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties2(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties2(Constructor, staticProps);
                    return Constructor;
                  }
                  function _inherits(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                      throw new TypeError("Super expression must either be null or a function");
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
                    if (superClass) _setPrototypeOf(subClass, superClass);
                  }
                  function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                      o2.__proto__ = p2;
                      return o2;
                    };
                    return _setPrototypeOf(o, p);
                  }
                  function _createSuper(Derived) {
                    var hasNativeReflectConstruct = _isNativeReflectConstruct();
                    return function _createSuperInternal() {
                      var Super = _getPrototypeOf(Derived), result;
                      if (hasNativeReflectConstruct) {
                        var NewTarget = _getPrototypeOf(this).constructor;
                        result = Reflect.construct(Super, arguments, NewTarget);
                      } else {
                        result = Super.apply(this, arguments);
                      }
                      return _possibleConstructorReturn(this, result);
                    };
                  }
                  function _possibleConstructorReturn(self, call) {
                    if (call && (clipboard_typeof(call) === "object" || typeof call === "function")) {
                      return call;
                    }
                    return _assertThisInitialized2(self);
                  }
                  function _assertThisInitialized2(self) {
                    if (self === void 0) {
                      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return self;
                  }
                  function _isNativeReflectConstruct() {
                    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if (typeof Proxy === "function") return true;
                    try {
                      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                      }));
                      return true;
                    } catch (e) {
                      return false;
                    }
                  }
                  function _getPrototypeOf(o) {
                    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                      return o2.__proto__ || Object.getPrototypeOf(o2);
                    };
                    return _getPrototypeOf(o);
                  }
                  function getAttributeValue(suffix, element) {
                    var attribute = "data-clipboard-".concat(suffix);
                    if (!element.hasAttribute(attribute)) {
                      return;
                    }
                    return element.getAttribute(attribute);
                  }
                  var Clipboard = /* @__PURE__ */ function(_Emitter) {
                    _inherits(Clipboard2, _Emitter);
                    var _super = _createSuper(Clipboard2);
                    function Clipboard2(trigger, options) {
                      var _this;
                      _classCallCheck(this, Clipboard2);
                      _this = _super.call(this);
                      _this.resolveOptions(options);
                      _this.listenClick(trigger);
                      return _this;
                    }
                    _createClass2(Clipboard2, [{
                      key: "resolveOptions",
                      value: function resolveOptions() {
                        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                        this.action = typeof options.action === "function" ? options.action : this.defaultAction;
                        this.target = typeof options.target === "function" ? options.target : this.defaultTarget;
                        this.text = typeof options.text === "function" ? options.text : this.defaultText;
                        this.container = clipboard_typeof(options.container) === "object" ? options.container : document.body;
                      }
                      /**
                       * Adds a click event listener to the passed trigger.
                       * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
                       */
                    }, {
                      key: "listenClick",
                      value: function listenClick(trigger) {
                        var _this2 = this;
                        this.listener = listen_default()(trigger, "click", function(e) {
                          return _this2.onClick(e);
                        });
                      }
                      /**
                       * Defines a new `ClipboardAction` on each click event.
                       * @param {Event} e
                       */
                    }, {
                      key: "onClick",
                      value: function onClick(e) {
                        var trigger = e.delegateTarget || e.currentTarget;
                        var action = this.action(trigger) || "copy";
                        var text = actions_default({
                          action,
                          container: this.container,
                          target: this.target(trigger),
                          text: this.text(trigger)
                        });
                        this.emit(text ? "success" : "error", {
                          action,
                          text,
                          trigger,
                          clearSelection: function clearSelection() {
                            if (trigger) {
                              trigger.focus();
                            }
                            window.getSelection().removeAllRanges();
                          }
                        });
                      }
                      /**
                       * Default `action` lookup function.
                       * @param {Element} trigger
                       */
                    }, {
                      key: "defaultAction",
                      value: function defaultAction(trigger) {
                        return getAttributeValue("action", trigger);
                      }
                      /**
                       * Default `target` lookup function.
                       * @param {Element} trigger
                       */
                    }, {
                      key: "defaultTarget",
                      value: function defaultTarget(trigger) {
                        var selector3 = getAttributeValue("target", trigger);
                        if (selector3) {
                          return document.querySelector(selector3);
                        }
                      }
                      /**
                       * Allow fire programmatically a copy action
                       * @param {String|HTMLElement} target
                       * @param {Object} options
                       * @returns Text copied.
                       */
                    }, {
                      key: "defaultText",
                      /**
                       * Default `text` lookup function.
                       * @param {Element} trigger
                       */
                      value: function defaultText(trigger) {
                        return getAttributeValue("text", trigger);
                      }
                      /**
                       * Destroy lifecycle.
                       */
                    }, {
                      key: "destroy",
                      value: function destroy() {
                        this.listener.destroy();
                      }
                    }], [{
                      key: "copy",
                      value: function copy(target) {
                        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                          container: document.body
                        };
                        return actions_copy(target, options);
                      }
                      /**
                       * Allow fire programmatically a cut action
                       * @param {String|HTMLElement} target
                       * @returns Text cutted.
                       */
                    }, {
                      key: "cut",
                      value: function cut(target) {
                        return actions_cut(target);
                      }
                      /**
                       * Returns the support of the given action, or all actions if no action is
                       * given.
                       * @param {String} [action]
                       */
                    }, {
                      key: "isSupported",
                      value: function isSupported() {
                        var action = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ["copy", "cut"];
                        var actions = typeof action === "string" ? [action] : action;
                        var support = !!document.queryCommandSupported;
                        actions.forEach(function(action2) {
                          support = support && !!document.queryCommandSupported(action2);
                        });
                        return support;
                      }
                    }]);
                    return Clipboard2;
                  }(tiny_emitter_default());
                  var clipboard = Clipboard;
                }
              ),
              /***/
              828: (
                /***/
                function(module2) {
                  var DOCUMENT_NODE_TYPE = 9;
                  if (typeof Element !== "undefined" && !Element.prototype.matches) {
                    var proto = Element.prototype;
                    proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
                  }
                  function closest(element, selector3) {
                    while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
                      if (typeof element.matches === "function" && element.matches(selector3)) {
                        return element;
                      }
                      element = element.parentNode;
                    }
                  }
                  module2.exports = closest;
                }
              ),
              /***/
              438: (
                /***/
                function(module2, __unused_webpack_exports, __webpack_require__2) {
                  var closest = __webpack_require__2(828);
                  function _delegate(element, selector3, type, callback, useCapture) {
                    var listenerFn = listener.apply(this, arguments);
                    element.addEventListener(type, listenerFn, useCapture);
                    return {
                      destroy: function() {
                        element.removeEventListener(type, listenerFn, useCapture);
                      }
                    };
                  }
                  function delegate(elements, selector3, type, callback, useCapture) {
                    if (typeof elements.addEventListener === "function") {
                      return _delegate.apply(null, arguments);
                    }
                    if (typeof type === "function") {
                      return _delegate.bind(null, document).apply(null, arguments);
                    }
                    if (typeof elements === "string") {
                      elements = document.querySelectorAll(elements);
                    }
                    return Array.prototype.map.call(elements, function(element) {
                      return _delegate(element, selector3, type, callback, useCapture);
                    });
                  }
                  function listener(element, selector3, type, callback) {
                    return function(e) {
                      e.delegateTarget = closest(e.target, selector3);
                      if (e.delegateTarget) {
                        callback.call(element, e);
                      }
                    };
                  }
                  module2.exports = delegate;
                }
              ),
              /***/
              879: (
                /***/
                function(__unused_webpack_module, exports2) {
                  exports2.node = function(value) {
                    return value !== void 0 && value instanceof HTMLElement && value.nodeType === 1;
                  };
                  exports2.nodeList = function(value) {
                    var type = Object.prototype.toString.call(value);
                    return value !== void 0 && (type === "[object NodeList]" || type === "[object HTMLCollection]") && "length" in value && (value.length === 0 || exports2.node(value[0]));
                  };
                  exports2.string = function(value) {
                    return typeof value === "string" || value instanceof String;
                  };
                  exports2.fn = function(value) {
                    var type = Object.prototype.toString.call(value);
                    return type === "[object Function]";
                  };
                }
              ),
              /***/
              370: (
                /***/
                function(module2, __unused_webpack_exports, __webpack_require__2) {
                  var is = __webpack_require__2(879);
                  var delegate = __webpack_require__2(438);
                  function listen(target, type, callback) {
                    if (!target && !type && !callback) {
                      throw new Error("Missing required arguments");
                    }
                    if (!is.string(type)) {
                      throw new TypeError("Second argument must be a String");
                    }
                    if (!is.fn(callback)) {
                      throw new TypeError("Third argument must be a Function");
                    }
                    if (is.node(target)) {
                      return listenNode(target, type, callback);
                    } else if (is.nodeList(target)) {
                      return listenNodeList(target, type, callback);
                    } else if (is.string(target)) {
                      return listenSelector(target, type, callback);
                    } else {
                      throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList");
                    }
                  }
                  function listenNode(node, type, callback) {
                    node.addEventListener(type, callback);
                    return {
                      destroy: function() {
                        node.removeEventListener(type, callback);
                      }
                    };
                  }
                  function listenNodeList(nodeList, type, callback) {
                    Array.prototype.forEach.call(nodeList, function(node) {
                      node.addEventListener(type, callback);
                    });
                    return {
                      destroy: function() {
                        Array.prototype.forEach.call(nodeList, function(node) {
                          node.removeEventListener(type, callback);
                        });
                      }
                    };
                  }
                  function listenSelector(selector3, type, callback) {
                    return delegate(document.body, selector3, type, callback);
                  }
                  module2.exports = listen;
                }
              ),
              /***/
              817: (
                /***/
                function(module2) {
                  function select(element) {
                    var selectedText;
                    if (element.nodeName === "SELECT") {
                      element.focus();
                      selectedText = element.value;
                    } else if (element.nodeName === "INPUT" || element.nodeName === "TEXTAREA") {
                      var isReadOnly = element.hasAttribute("readonly");
                      if (!isReadOnly) {
                        element.setAttribute("readonly", "");
                      }
                      element.select();
                      element.setSelectionRange(0, element.value.length);
                      if (!isReadOnly) {
                        element.removeAttribute("readonly");
                      }
                      selectedText = element.value;
                    } else {
                      if (element.hasAttribute("contenteditable")) {
                        element.focus();
                      }
                      var selection = window.getSelection();
                      var range = document.createRange();
                      range.selectNodeContents(element);
                      selection.removeAllRanges();
                      selection.addRange(range);
                      selectedText = selection.toString();
                    }
                    return selectedText;
                  }
                  module2.exports = select;
                }
              ),
              /***/
              279: (
                /***/
                function(module2) {
                  function E() {
                  }
                  E.prototype = {
                    on: function(name, callback, ctx) {
                      var e = this.e || (this.e = {});
                      (e[name] || (e[name] = [])).push({
                        fn: callback,
                        ctx
                      });
                      return this;
                    },
                    once: function(name, callback, ctx) {
                      var self = this;
                      function listener() {
                        self.off(name, listener);
                        callback.apply(ctx, arguments);
                      }
                      ;
                      listener._ = callback;
                      return this.on(name, listener, ctx);
                    },
                    emit: function(name) {
                      var data = [].slice.call(arguments, 1);
                      var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
                      var i = 0;
                      var len = evtArr.length;
                      for (i; i < len; i++) {
                        evtArr[i].fn.apply(evtArr[i].ctx, data);
                      }
                      return this;
                    },
                    off: function(name, callback) {
                      var e = this.e || (this.e = {});
                      var evts = e[name];
                      var liveEvents = [];
                      if (evts && callback) {
                        for (var i = 0, len = evts.length; i < len; i++) {
                          if (evts[i].fn !== callback && evts[i].fn._ !== callback)
                            liveEvents.push(evts[i]);
                        }
                      }
                      liveEvents.length ? e[name] = liveEvents : delete e[name];
                      return this;
                    }
                  };
                  module2.exports = E;
                  module2.exports.TinyEmitter = E;
                }
              )
              /******/
            };
            var __webpack_module_cache__ = {};
            function __webpack_require__(moduleId) {
              if (__webpack_module_cache__[moduleId]) {
                return __webpack_module_cache__[moduleId].exports;
              }
              var module2 = __webpack_module_cache__[moduleId] = {
                /******/
                // no module.id needed
                /******/
                // no module.loaded needed
                /******/
                exports: {}
                /******/
              };
              __webpack_modules__[moduleId](module2, module2.exports, __webpack_require__);
              return module2.exports;
            }
            !function() {
              __webpack_require__.n = function(module2) {
                var getter = module2 && module2.__esModule ? (
                  /******/
                  function() {
                    return module2["default"];
                  }
                ) : (
                  /******/
                  function() {
                    return module2;
                  }
                );
                __webpack_require__.d(getter, { a: getter });
                return getter;
              };
            }();
            !function() {
              __webpack_require__.d = function(exports2, definition) {
                for (var key in definition) {
                  if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                    Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
                  }
                }
              };
            }();
            !function() {
              __webpack_require__.o = function(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop);
              };
            }();
            return __webpack_require__(686);
          }().default
        );
      });
    }
  });

  // node_modules/tablesort/src/tablesort.js
  var require_tablesort = __commonJS({
    "node_modules/tablesort/src/tablesort.js"(exports, module) {
      "use strict";
      (function() {
        function Tablesort2(el, options) {
          if (!(this instanceof Tablesort2)) return new Tablesort2(el, options);
          if (!el || el.tagName !== "TABLE") {
            throw new Error("Element must be a table");
          }
          this.init(el, options || {});
        }
        var sortOptions = [];
        var createEvent = function(name) {
          var evt;
          if (!window.CustomEvent || typeof window.CustomEvent !== "function") {
            evt = document.createEvent("CustomEvent");
            evt.initCustomEvent(name, false, false, void 0);
          } else {
            evt = new CustomEvent(name);
          }
          return evt;
        };
        var getInnerText = function(el, options) {
          return el.getAttribute(options.sortAttribute || "data-sort") || el.textContent || el.innerText || "";
        };
        var caseInsensitiveSort = function(a, b) {
          a = a.trim().toLowerCase();
          b = b.trim().toLowerCase();
          if (a === b) return 0;
          if (a < b) return 1;
          return -1;
        };
        var getCellByKey = function(cells, key) {
          return [].slice.call(cells).find(function(cell) {
            return cell.getAttribute("data-sort-column-key") === key;
          });
        };
        var stabilize = function(sort, antiStabilize) {
          return function(a, b) {
            var unstableResult = sort(a.td, b.td);
            if (unstableResult === 0) {
              if (antiStabilize) return b.index - a.index;
              return a.index - b.index;
            }
            return unstableResult;
          };
        };
        Tablesort2.extend = function(name, pattern, sort) {
          if (typeof pattern !== "function" || typeof sort !== "function") {
            throw new Error("Pattern and sort must be a function");
          }
          sortOptions.push({
            name,
            pattern,
            sort
          });
        };
        Tablesort2.prototype = {
          init: function(el, options) {
            var that = this, firstRow, defaultSort, i, cell;
            that.table = el;
            that.thead = false;
            that.options = options;
            if (el.rows && el.rows.length > 0) {
              if (el.tHead && el.tHead.rows.length > 0) {
                for (i = 0; i < el.tHead.rows.length; i++) {
                  if (el.tHead.rows[i].getAttribute("data-sort-method") === "thead") {
                    firstRow = el.tHead.rows[i];
                    break;
                  }
                }
                if (!firstRow) {
                  firstRow = el.tHead.rows[el.tHead.rows.length - 1];
                }
                that.thead = true;
              } else {
                firstRow = el.rows[0];
              }
            }
            if (!firstRow) return;
            var onClick = function() {
              if (that.current && that.current !== this) {
                that.current.removeAttribute("aria-sort");
              }
              that.current = this;
              that.sortTable(this);
            };
            for (i = 0; i < firstRow.cells.length; i++) {
              cell = firstRow.cells[i];
              cell.setAttribute("role", "columnheader");
              if (cell.getAttribute("data-sort-method") !== "none") {
                cell.tabindex = 0;
                cell.addEventListener("click", onClick, false);
                if (cell.getAttribute("data-sort-default") !== null) {
                  defaultSort = cell;
                }
              }
            }
            if (defaultSort) {
              that.current = defaultSort;
              that.sortTable(defaultSort);
            }
          },
          sortTable: function(header, update) {
            var that = this, columnKey = header.getAttribute("data-sort-column-key"), column = header.cellIndex, sortFunction = caseInsensitiveSort, item = "", items = [], i = that.thead ? 0 : 1, sortMethod = header.getAttribute("data-sort-method"), sortOrder = header.getAttribute("aria-sort");
            that.table.dispatchEvent(createEvent("beforeSort"));
            if (!update) {
              if (sortOrder === "ascending") {
                sortOrder = "descending";
              } else if (sortOrder === "descending") {
                sortOrder = "ascending";
              } else {
                sortOrder = that.options.descending ? "descending" : "ascending";
              }
              header.setAttribute("aria-sort", sortOrder);
            }
            if (that.table.rows.length < 2) return;
            if (!sortMethod) {
              var cell;
              while (items.length < 3 && i < that.table.tBodies[0].rows.length) {
                if (columnKey) {
                  cell = getCellByKey(that.table.tBodies[0].rows[i].cells, columnKey);
                } else {
                  cell = that.table.tBodies[0].rows[i].cells[column];
                }
                item = cell ? getInnerText(cell, that.options) : "";
                item = item.trim();
                if (item.length > 0) {
                  items.push(item);
                }
                i++;
              }
              if (!items) return;
            }
            for (i = 0; i < sortOptions.length; i++) {
              item = sortOptions[i];
              if (sortMethod) {
                if (item.name === sortMethod) {
                  sortFunction = item.sort;
                  break;
                }
              } else if (items.every(item.pattern)) {
                sortFunction = item.sort;
                break;
              }
            }
            that.col = column;
            for (i = 0; i < that.table.tBodies.length; i++) {
              var newRows = [], noSorts = {}, j, totalRows = 0, noSortsSoFar = 0;
              if (that.table.tBodies[i].rows.length < 2) continue;
              for (j = 0; j < that.table.tBodies[i].rows.length; j++) {
                var cell;
                item = that.table.tBodies[i].rows[j];
                if (item.getAttribute("data-sort-method") === "none") {
                  noSorts[totalRows] = item;
                } else {
                  if (columnKey) {
                    cell = getCellByKey(item.cells, columnKey);
                  } else {
                    cell = item.cells[that.col];
                  }
                  newRows.push({
                    tr: item,
                    td: cell ? getInnerText(cell, that.options) : "",
                    index: totalRows
                  });
                }
                totalRows++;
              }
              if (sortOrder === "descending") {
                newRows.sort(stabilize(sortFunction, true));
              } else {
                newRows.sort(stabilize(sortFunction, false));
                newRows.reverse();
              }
              for (j = 0; j < totalRows; j++) {
                if (noSorts[j]) {
                  item = noSorts[j];
                  noSortsSoFar++;
                } else {
                  item = newRows[j - noSortsSoFar].tr;
                }
                that.table.tBodies[i].appendChild(item);
              }
            }
            that.table.dispatchEvent(createEvent("afterSort"));
          },
          refresh: function() {
            if (this.current !== void 0) {
              this.sortTable(this.current, true);
            }
          }
        };
        if (typeof module !== "undefined" && module.exports) {
          module.exports = Tablesort2;
        } else {
          window.Tablesort = Tablesort2;
        }
      })();
    }
  });

  // node_modules/gsap/gsap-core.js
  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var _config = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
      lineHeight: ""
    }
  };
  var _defaults = {
    duration: 0.5,
    overwrite: false,
    delay: 0
  };
  var _suppressOverwrites;
  var _reverting;
  var _context;
  var _bigNum = 1e8;
  var _tinyNum = 1 / _bigNum;
  var _2PI = Math.PI * 2;
  var _HALF_PI = _2PI / 4;
  var _gsID = 0;
  var _sqrt = Math.sqrt;
  var _cos = Math.cos;
  var _sin = Math.sin;
  var _isString = function _isString2(value) {
    return typeof value === "string";
  };
  var _isFunction = function _isFunction2(value) {
    return typeof value === "function";
  };
  var _isNumber = function _isNumber2(value) {
    return typeof value === "number";
  };
  var _isUndefined = function _isUndefined2(value) {
    return typeof value === "undefined";
  };
  var _isObject = function _isObject2(value) {
    return typeof value === "object";
  };
  var _isNotFalse = function _isNotFalse2(value) {
    return value !== false;
  };
  var _windowExists = function _windowExists2() {
    return typeof window !== "undefined";
  };
  var _isFuncOrString = function _isFuncOrString2(value) {
    return _isFunction(value) || _isString(value);
  };
  var _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function() {
  };
  var _isArray = Array.isArray;
  var _strictNumExp = /(?:-?\.?\d|\.)+/gi;
  var _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g;
  var _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g;
  var _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi;
  var _relExp = /[+-]=-?[.\d]+/;
  var _delimitedValueExp = /[^,'"\[\]\s]+/gi;
  var _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i;
  var _globalTimeline;
  var _win;
  var _coreInitted;
  var _doc;
  var _globals = {};
  var _installScope = {};
  var _coreReady;
  var _install = function _install2(scope) {
    return (_installScope = _merge(scope, _globals)) && gsap;
  };
  var _missingPlugin = function _missingPlugin2(property, value) {
    return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
  };
  var _warn = function _warn2(message, suppress) {
    return !suppress && console.warn(message);
  };
  var _addGlobal = function _addGlobal2(name, obj) {
    return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
  };
  var _emptyFunc = function _emptyFunc2() {
    return 0;
  };
  var _startAtRevertConfig = {
    suppressEvents: true,
    isStart: true,
    kill: false
  };
  var _revertConfigNoKill = {
    suppressEvents: true,
    kill: false
  };
  var _revertConfig = {
    suppressEvents: true
  };
  var _reservedProps = {};
  var _lazyTweens = [];
  var _lazyLookup = {};
  var _lastRenderedFrame;
  var _plugins = {};
  var _effects = {};
  var _nextGCFrame = 30;
  var _harnessPlugins = [];
  var _callbackNames = "";
  var _harness = function _harness2(targets) {
    var target = targets[0], harnessPlugin, i;
    _isObject(target) || _isFunction(target) || (targets = [targets]);
    if (!(harnessPlugin = (target._gsap || {}).harness)) {
      i = _harnessPlugins.length;
      while (i-- && !_harnessPlugins[i].targetTest(target)) {
      }
      harnessPlugin = _harnessPlugins[i];
    }
    i = targets.length;
    while (i--) {
      targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
    }
    return targets;
  };
  var _getCache = function _getCache2(target) {
    return target._gsap || _harness(toArray(target))[0]._gsap;
  };
  var _getProperty = function _getProperty2(target, property, v) {
    return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
  };
  var _forEachName = function _forEachName2(names, func) {
    return (names = names.split(",")).forEach(func) || names;
  };
  var _round = function _round2(value) {
    return Math.round(value * 1e5) / 1e5 || 0;
  };
  var _roundPrecise = function _roundPrecise2(value) {
    return Math.round(value * 1e7) / 1e7 || 0;
  };
  var _parseRelative = function _parseRelative2(start, value) {
    var operator = value.charAt(0), end = parseFloat(value.substr(2));
    start = parseFloat(start);
    return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
  };
  var _arrayContainsAny = function _arrayContainsAny2(toSearch, toFind) {
    var l = toFind.length, i = 0;
    for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l; ) {
    }
    return i < l;
  };
  var _lazyRender = function _lazyRender2() {
    var l = _lazyTweens.length, a = _lazyTweens.slice(0), i, tween;
    _lazyLookup = {};
    _lazyTweens.length = 0;
    for (i = 0; i < l; i++) {
      tween = a[i];
      tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
    }
  };
  var _lazySafeRender = function _lazySafeRender2(animation, time, suppressEvents, force) {
    _lazyTweens.length && !_reverting && _lazyRender();
    animation.render(time, suppressEvents, force || _reverting && time < 0 && (animation._initted || animation._startAt));
    _lazyTweens.length && !_reverting && _lazyRender();
  };
  var _numericIfPossible = function _numericIfPossible2(value) {
    var n = parseFloat(value);
    return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
  };
  var _passThrough = function _passThrough2(p) {
    return p;
  };
  var _setDefaults = function _setDefaults2(obj, defaults2) {
    for (var p in defaults2) {
      p in obj || (obj[p] = defaults2[p]);
    }
    return obj;
  };
  var _setKeyframeDefaults = function _setKeyframeDefaults2(excludeDuration) {
    return function(obj, defaults2) {
      for (var p in defaults2) {
        p in obj || p === "duration" && excludeDuration || p === "ease" || (obj[p] = defaults2[p]);
      }
    };
  };
  var _merge = function _merge2(base, toMerge) {
    for (var p in toMerge) {
      base[p] = toMerge[p];
    }
    return base;
  };
  var _mergeDeep = function _mergeDeep2(base, toMerge) {
    for (var p in toMerge) {
      p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep2(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
    }
    return base;
  };
  var _copyExcluding = function _copyExcluding2(obj, excluding) {
    var copy = {}, p;
    for (p in obj) {
      p in excluding || (copy[p] = obj[p]);
    }
    return copy;
  };
  var _inheritDefaults = function _inheritDefaults2(vars) {
    var parent = vars.parent || _globalTimeline, func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;
    if (_isNotFalse(vars.inherit)) {
      while (parent) {
        func(vars, parent.vars.defaults);
        parent = parent.parent || parent._dp;
      }
    }
    return vars;
  };
  var _arraysMatch = function _arraysMatch2(a1, a2) {
    var i = a1.length, match = i === a2.length;
    while (match && i-- && a1[i] === a2[i]) {
    }
    return i < 0;
  };
  var _addLinkedListItem = function _addLinkedListItem2(parent, child, firstProp, lastProp, sortBy) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }
    if (lastProp === void 0) {
      lastProp = "_last";
    }
    var prev = parent[lastProp], t;
    if (sortBy) {
      t = child[sortBy];
      while (prev && prev[sortBy] > t) {
        prev = prev._prev;
      }
    }
    if (prev) {
      child._next = prev._next;
      prev._next = child;
    } else {
      child._next = parent[firstProp];
      parent[firstProp] = child;
    }
    if (child._next) {
      child._next._prev = child;
    } else {
      parent[lastProp] = child;
    }
    child._prev = prev;
    child.parent = child._dp = parent;
    return child;
  };
  var _removeLinkedListItem = function _removeLinkedListItem2(parent, child, firstProp, lastProp) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }
    if (lastProp === void 0) {
      lastProp = "_last";
    }
    var prev = child._prev, next = child._next;
    if (prev) {
      prev._next = next;
    } else if (parent[firstProp] === child) {
      parent[firstProp] = next;
    }
    if (next) {
      next._prev = prev;
    } else if (parent[lastProp] === child) {
      parent[lastProp] = prev;
    }
    child._next = child._prev = child.parent = null;
  };
  var _removeFromParent = function _removeFromParent2(child, onlyIfParentHasAutoRemove) {
    child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);
    child._act = 0;
  };
  var _uncache = function _uncache2(animation, child) {
    if (animation && (!child || child._end > animation._dur || child._start < 0)) {
      var a = animation;
      while (a) {
        a._dirty = 1;
        a = a.parent;
      }
    }
    return animation;
  };
  var _recacheAncestors = function _recacheAncestors2(animation) {
    var parent = animation.parent;
    while (parent && parent.parent) {
      parent._dirty = 1;
      parent.totalDuration();
      parent = parent.parent;
    }
    return animation;
  };
  var _rewindStartAt = function _rewindStartAt2(tween, totalTime, suppressEvents, force) {
    return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));
  };
  var _hasNoPausedAncestors = function _hasNoPausedAncestors2(animation) {
    return !animation || animation._ts && _hasNoPausedAncestors2(animation.parent);
  };
  var _elapsedCycleDuration = function _elapsedCycleDuration2(animation) {
    return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
  };
  var _animationCycle = function _animationCycle2(tTime, cycleDuration) {
    var whole = Math.floor(tTime = _roundPrecise(tTime / cycleDuration));
    return tTime && whole === tTime ? whole - 1 : whole;
  };
  var _parentToChildTotalTime = function _parentToChildTotalTime2(parentTime, child) {
    return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
  };
  var _setEnd = function _setEnd2(animation) {
    return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
  };
  var _alignPlayhead = function _alignPlayhead2(animation, totalTime) {
    var parent = animation._dp;
    if (parent && parent.smoothChildTiming && animation._ts) {
      animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
      _setEnd(animation);
      parent._dirty || _uncache(parent, animation);
    }
    return animation;
  };
  var _postAddChecks = function _postAddChecks2(timeline2, child) {
    var t;
    if (child._time || !child._dur && child._initted || child._start < timeline2._time && (child._dur || !child.add)) {
      t = _parentToChildTotalTime(timeline2.rawTime(), child);
      if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
        child.render(t, true);
      }
    }
    if (_uncache(timeline2, child)._dp && timeline2._initted && timeline2._time >= timeline2._dur && timeline2._ts) {
      if (timeline2._dur < timeline2.duration()) {
        t = timeline2;
        while (t._dp) {
          t.rawTime() >= 0 && t.totalTime(t._tTime);
          t = t._dp;
        }
      }
      timeline2._zTime = -_tinyNum;
    }
  };
  var _addToTimeline = function _addToTimeline2(timeline2, child, position, skipChecks) {
    child.parent && _removeFromParent(child);
    child._start = _roundPrecise((_isNumber(position) ? position : position || timeline2 !== _globalTimeline ? _parsePosition(timeline2, position, child) : timeline2._time) + child._delay);
    child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));
    _addLinkedListItem(timeline2, child, "_first", "_last", timeline2._sort ? "_start" : 0);
    _isFromOrFromStart(child) || (timeline2._recent = child);
    skipChecks || _postAddChecks(timeline2, child);
    timeline2._ts < 0 && _alignPlayhead(timeline2, timeline2._tTime);
    return timeline2;
  };
  var _scrollTrigger = function _scrollTrigger2(animation, trigger) {
    return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
  };
  var _attemptInitTween = function _attemptInitTween2(tween, time, force, suppressEvents, tTime) {
    _initTween(tween, time, tTime);
    if (!tween._initted) {
      return 1;
    }
    if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
      _lazyTweens.push(tween);
      tween._lazy = [tTime, suppressEvents];
      return 1;
    }
  };
  var _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart2(_ref) {
    var parent = _ref.parent;
    return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart2(parent));
  };
  var _isFromOrFromStart = function _isFromOrFromStart2(_ref2) {
    var data = _ref2.data;
    return data === "isFromStart" || data === "isStart";
  };
  var _renderZeroDurationTween = function _renderZeroDurationTween2(tween, totalTime, suppressEvents, force) {
    var prevRatio = tween.ratio, ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1, repeatDelay = tween._rDelay, tTime = 0, pt, iteration, prevIteration;
    if (repeatDelay && tween._repeat) {
      tTime = _clamp(0, tween._tDur, totalTime);
      iteration = _animationCycle(tTime, repeatDelay);
      tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
      if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
        prevRatio = 1 - ratio;
        tween.vars.repeatRefresh && tween._initted && tween.invalidate();
      }
    }
    if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
      if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {
        return;
      }
      prevIteration = tween._zTime;
      tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);
      suppressEvents || (suppressEvents = totalTime && !prevIteration);
      tween.ratio = ratio;
      tween._from && (ratio = 1 - ratio);
      tween._time = 0;
      tween._tTime = tTime;
      pt = tween._pt;
      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
      totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);
      tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
      tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
      if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
        ratio && _removeFromParent(tween, 1);
        if (!suppressEvents && !_reverting) {
          _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);
          tween._prom && tween._prom();
        }
      }
    } else if (!tween._zTime) {
      tween._zTime = totalTime;
    }
  };
  var _findNextPauseTween = function _findNextPauseTween2(animation, prevTime, time) {
    var child;
    if (time > prevTime) {
      child = animation._first;
      while (child && child._start <= time) {
        if (child.data === "isPause" && child._start > prevTime) {
          return child;
        }
        child = child._next;
      }
    } else {
      child = animation._last;
      while (child && child._start >= time) {
        if (child.data === "isPause" && child._start < prevTime) {
          return child;
        }
        child = child._prev;
      }
    }
  };
  var _setDuration = function _setDuration2(animation, duration, skipUncache, leavePlayhead) {
    var repeat2 = animation._repeat, dur = _roundPrecise(duration) || 0, totalProgress = animation._tTime / animation._tDur;
    totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
    animation._dur = dur;
    animation._tDur = !repeat2 ? dur : repeat2 < 0 ? 1e10 : _roundPrecise(dur * (repeat2 + 1) + animation._rDelay * repeat2);
    totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);
    animation.parent && _setEnd(animation);
    skipUncache || _uncache(animation.parent, animation);
    return animation;
  };
  var _onUpdateTotalDuration = function _onUpdateTotalDuration2(animation) {
    return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
  };
  var _zeroPosition = {
    _start: 0,
    endTime: _emptyFunc,
    totalDuration: _emptyFunc
  };
  var _parsePosition = function _parsePosition2(animation, position, percentAnimation) {
    var labels = animation.labels, recent = animation._recent || _zeroPosition, clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur, i, offset, isPercent;
    if (_isString(position) && (isNaN(position) || position in labels)) {
      offset = position.charAt(0);
      isPercent = position.substr(-1) === "%";
      i = position.indexOf("=");
      if (offset === "<" || offset === ">") {
        i >= 0 && (position = position.replace(/=/, ""));
        return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
      }
      if (i < 0) {
        position in labels || (labels[position] = clippedDuration);
        return labels[position];
      }
      offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));
      if (isPercent && percentAnimation) {
        offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
      }
      return i > 1 ? _parsePosition2(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
    }
    return position == null ? clippedDuration : +position;
  };
  var _createTweenType = function _createTweenType2(type, params, timeline2) {
    var isLegacy = _isNumber(params[1]), varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1), vars = params[varsIndex], irVars, parent;
    isLegacy && (vars.duration = params[1]);
    vars.parent = timeline2;
    if (type) {
      irVars = vars;
      parent = timeline2;
      while (parent && !("immediateRender" in irVars)) {
        irVars = parent.vars.defaults || {};
        parent = _isNotFalse(parent.vars.inherit) && parent.parent;
      }
      vars.immediateRender = _isNotFalse(irVars.immediateRender);
      type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1];
    }
    return new Tween(params[0], vars, params[varsIndex + 1]);
  };
  var _conditionalReturn = function _conditionalReturn2(value, func) {
    return value || value === 0 ? func(value) : func;
  };
  var _clamp = function _clamp2(min, max, value) {
    return value < min ? min : value > max ? max : value;
  };
  var getUnit = function getUnit2(value, v) {
    return !_isString(value) || !(v = _unitExp.exec(value)) ? "" : v[1];
  };
  var clamp = function clamp2(min, max, value) {
    return _conditionalReturn(value, function(v) {
      return _clamp(min, max, v);
    });
  };
  var _slice = [].slice;
  var _isArrayLike = function _isArrayLike2(value, nonEmpty) {
    return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
  };
  var _flatten = function _flatten2(ar, leaveStrings, accumulator) {
    if (accumulator === void 0) {
      accumulator = [];
    }
    return ar.forEach(function(value) {
      var _accumulator;
      return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
    }) || accumulator;
  };
  var toArray = function toArray2(value, scope, leaveStrings) {
    return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
  };
  var selector = function selector2(value) {
    value = toArray(value)[0] || _warn("Invalid scope") || {};
    return function(v) {
      var el = value.current || value.nativeElement || value;
      return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
    };
  };
  var shuffle = function shuffle2(a) {
    return a.sort(function() {
      return 0.5 - Math.random();
    });
  };
  var distribute = function distribute2(v) {
    if (_isFunction(v)) {
      return v;
    }
    var vars = _isObject(v) ? v : {
      each: v
    }, ease = _parseEase(vars.ease), from2 = vars.from || 0, base = parseFloat(vars.base) || 0, cache = {}, isDecimal = from2 > 0 && from2 < 1, ratios = isNaN(from2) || isDecimal, axis = vars.axis, ratioX = from2, ratioY = from2;
    if (_isString(from2)) {
      ratioX = ratioY = {
        center: 0.5,
        edges: 0.5,
        end: 1
      }[from2] || 0;
    } else if (!isDecimal && ratios) {
      ratioX = from2[0];
      ratioY = from2[1];
    }
    return function(i, target, a) {
      var l = (a || vars).length, distances = cache[l], originX, originY, x, y, d, j, max, min, wrapAt;
      if (!distances) {
        wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];
        if (!wrapAt) {
          max = -_bigNum;
          while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {
          }
          wrapAt < l && wrapAt--;
        }
        distances = cache[l] = [];
        originX = ratios ? Math.min(wrapAt, l) * ratioX - 0.5 : from2 % wrapAt;
        originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - 0.5 : from2 / wrapAt | 0;
        max = 0;
        min = _bigNum;
        for (j = 0; j < l; j++) {
          x = j % wrapAt - originX;
          y = originY - (j / wrapAt | 0);
          distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
          d > max && (max = d);
          d < min && (min = d);
        }
        from2 === "random" && shuffle(distances);
        distances.max = max - min;
        distances.min = min;
        distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from2 === "edges" ? -1 : 1);
        distances.b = l < 0 ? base - l : base;
        distances.u = getUnit(vars.amount || vars.each) || 0;
        ease = ease && l < 0 ? _invertEase(ease) : ease;
      }
      l = (distances[i] - distances.min) / distances.max || 0;
      return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u;
    };
  };
  var _roundModifier = function _roundModifier2(v) {
    var p = Math.pow(10, ((v + "").split(".")[1] || "").length);
    return function(raw) {
      var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);
      return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw));
    };
  };
  var snap = function snap2(snapTo, value) {
    var isArray4 = _isArray(snapTo), radius, is2D;
    if (!isArray4 && _isObject(snapTo)) {
      radius = isArray4 = snapTo.radius || _bigNum;
      if (snapTo.values) {
        snapTo = toArray(snapTo.values);
        if (is2D = !_isNumber(snapTo[0])) {
          radius *= radius;
        }
      } else {
        snapTo = _roundModifier(snapTo.increment);
      }
    }
    return _conditionalReturn(value, !isArray4 ? _roundModifier(snapTo) : _isFunction(snapTo) ? function(raw) {
      is2D = snapTo(raw);
      return Math.abs(is2D - raw) <= radius ? is2D : raw;
    } : function(raw) {
      var x = parseFloat(is2D ? raw.x : raw), y = parseFloat(is2D ? raw.y : 0), min = _bigNum, closest = 0, i = snapTo.length, dx, dy;
      while (i--) {
        if (is2D) {
          dx = snapTo[i].x - x;
          dy = snapTo[i].y - y;
          dx = dx * dx + dy * dy;
        } else {
          dx = Math.abs(snapTo[i] - x);
        }
        if (dx < min) {
          min = dx;
          closest = i;
        }
      }
      closest = !radius || min <= radius ? snapTo[closest] : raw;
      return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
    });
  };
  var random = function random2(min, max, roundingIncrement, returnFunction) {
    return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function() {
      return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * 0.99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
    });
  };
  var pipe = function pipe2() {
    for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
      functions[_key] = arguments[_key];
    }
    return function(value) {
      return functions.reduce(function(v, f) {
        return f(v);
      }, value);
    };
  };
  var unitize = function unitize2(func, unit) {
    return function(value) {
      return func(parseFloat(value)) + (unit || getUnit(value));
    };
  };
  var normalize = function normalize2(min, max, value) {
    return mapRange(min, max, 0, 1, value);
  };
  var _wrapArray = function _wrapArray2(a, wrapper, value) {
    return _conditionalReturn(value, function(index) {
      return a[~~wrapper(index)];
    });
  };
  var wrap = function wrap2(min, max, value) {
    var range = max - min;
    return _isArray(min) ? _wrapArray(min, wrap2(0, min.length), max) : _conditionalReturn(value, function(value2) {
      return (range + (value2 - min) % range) % range + min;
    });
  };
  var wrapYoyo = function wrapYoyo2(min, max, value) {
    var range = max - min, total = range * 2;
    return _isArray(min) ? _wrapArray(min, wrapYoyo2(0, min.length - 1), max) : _conditionalReturn(value, function(value2) {
      value2 = (total + (value2 - min) % total) % total || 0;
      return min + (value2 > range ? total - value2 : value2);
    });
  };
  var _replaceRandom = function _replaceRandom2(value) {
    var prev = 0, s = "", i, nums, end, isArray4;
    while (~(i = value.indexOf("random(", prev))) {
      end = value.indexOf(")", i);
      isArray4 = value.charAt(i + 7) === "[";
      nums = value.substr(i + 7, end - i - 7).match(isArray4 ? _delimitedValueExp : _strictNumExp);
      s += value.substr(prev, i - prev) + random(isArray4 ? nums : +nums[0], isArray4 ? 0 : +nums[1], +nums[2] || 1e-5);
      prev = end + 1;
    }
    return s + value.substr(prev, value.length - prev);
  };
  var mapRange = function mapRange2(inMin, inMax, outMin, outMax, value) {
    var inRange = inMax - inMin, outRange = outMax - outMin;
    return _conditionalReturn(value, function(value2) {
      return outMin + ((value2 - inMin) / inRange * outRange || 0);
    });
  };
  var interpolate = function interpolate2(start, end, progress, mutate) {
    var func = isNaN(start + end) ? 0 : function(p2) {
      return (1 - p2) * start + p2 * end;
    };
    if (!func) {
      var isString = _isString(start), master = {}, p, i, interpolators, l, il;
      progress === true && (mutate = 1) && (progress = null);
      if (isString) {
        start = {
          p: start
        };
        end = {
          p: end
        };
      } else if (_isArray(start) && !_isArray(end)) {
        interpolators = [];
        l = start.length;
        il = l - 2;
        for (i = 1; i < l; i++) {
          interpolators.push(interpolate2(start[i - 1], start[i]));
        }
        l--;
        func = function func2(p2) {
          p2 *= l;
          var i2 = Math.min(il, ~~p2);
          return interpolators[i2](p2 - i2);
        };
        progress = end;
      } else if (!mutate) {
        start = _merge(_isArray(start) ? [] : {}, start);
      }
      if (!interpolators) {
        for (p in end) {
          _addPropTween.call(master, start, p, "get", end[p]);
        }
        func = function func2(p2) {
          return _renderPropTweens(p2, master) || (isString ? start.p : start);
        };
      }
    }
    return _conditionalReturn(progress, func);
  };
  var _getLabelInDirection = function _getLabelInDirection2(timeline2, fromTime, backward) {
    var labels = timeline2.labels, min = _bigNum, p, distance, label;
    for (p in labels) {
      distance = labels[p] - fromTime;
      if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
        label = p;
        min = distance;
      }
    }
    return label;
  };
  var _callback = function _callback2(animation, type, executeLazyFirst) {
    var v = animation.vars, callback = v[type], prevContext = _context, context4 = animation._ctx, params, scope, result;
    if (!callback) {
      return;
    }
    params = v[type + "Params"];
    scope = v.callbackScope || animation;
    executeLazyFirst && _lazyTweens.length && _lazyRender();
    context4 && (_context = context4);
    result = params ? callback.apply(scope, params) : callback.call(scope);
    _context = prevContext;
    return result;
  };
  var _interrupt = function _interrupt2(animation) {
    _removeFromParent(animation);
    animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);
    animation.progress() < 1 && _callback(animation, "onInterrupt");
    return animation;
  };
  var _quickTween;
  var _registerPluginQueue = [];
  var _createPlugin = function _createPlugin2(config6) {
    if (!config6) return;
    config6 = !config6.name && config6["default"] || config6;
    if (_windowExists() || config6.headless) {
      var name = config6.name, isFunc = _isFunction(config6), Plugin = name && !isFunc && config6.init ? function() {
        this._props = [];
      } : config6, instanceDefaults = {
        init: _emptyFunc,
        render: _renderPropTweens,
        add: _addPropTween,
        kill: _killPropTweensOf,
        modifier: _addPluginModifier,
        rawVars: 0
      }, statics = {
        targetTest: 0,
        get: 0,
        getSetter: _getSetter,
        aliases: {},
        register: 0
      };
      _wake();
      if (config6 !== Plugin) {
        if (_plugins[name]) {
          return;
        }
        _setDefaults(Plugin, _setDefaults(_copyExcluding(config6, instanceDefaults), statics));
        _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config6, statics)));
        _plugins[Plugin.prop = name] = Plugin;
        if (config6.targetTest) {
          _harnessPlugins.push(Plugin);
          _reservedProps[name] = 1;
        }
        name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin";
      }
      _addGlobal(name, Plugin);
      config6.register && config6.register(gsap, Plugin, PropTween);
    } else {
      _registerPluginQueue.push(config6);
    }
  };
  var _255 = 255;
  var _colorLookup = {
    aqua: [0, _255, _255],
    lime: [0, _255, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, _255],
    navy: [0, 0, 128],
    white: [_255, _255, _255],
    olive: [128, 128, 0],
    yellow: [_255, _255, 0],
    orange: [_255, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [_255, 0, 0],
    pink: [_255, 192, 203],
    cyan: [0, _255, _255],
    transparent: [_255, _255, _255, 0]
  };
  var _hue = function _hue2(h2, m1, m2) {
    h2 += h2 < 0 ? 1 : h2 > 1 ? -1 : 0;
    return (h2 * 6 < 1 ? m1 + (m2 - m1) * h2 * 6 : h2 < 0.5 ? m2 : h2 * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h2) * 6 : m1) * _255 + 0.5 | 0;
  };
  var splitColor = function splitColor2(v, toHSL, forceAlpha) {
    var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0, r, g, b, h2, s, l, max, min, d, wasHSL;
    if (!a) {
      if (v.substr(-1) === ",") {
        v = v.substr(0, v.length - 1);
      }
      if (_colorLookup[v]) {
        a = _colorLookup[v];
      } else if (v.charAt(0) === "#") {
        if (v.length < 6) {
          r = v.charAt(1);
          g = v.charAt(2);
          b = v.charAt(3);
          v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
        }
        if (v.length === 9) {
          a = parseInt(v.substr(1, 6), 16);
          return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
        }
        v = parseInt(v.substr(1), 16);
        a = [v >> 16, v >> 8 & _255, v & _255];
      } else if (v.substr(0, 3) === "hsl") {
        a = wasHSL = v.match(_strictNumExp);
        if (!toHSL) {
          h2 = +a[0] % 360 / 360;
          s = +a[1] / 100;
          l = +a[2] / 100;
          g = l <= 0.5 ? l * (s + 1) : l + s - l * s;
          r = l * 2 - g;
          a.length > 3 && (a[3] *= 1);
          a[0] = _hue(h2 + 1 / 3, r, g);
          a[1] = _hue(h2, r, g);
          a[2] = _hue(h2 - 1 / 3, r, g);
        } else if (~v.indexOf("=")) {
          a = v.match(_numExp);
          forceAlpha && a.length < 4 && (a[3] = 1);
          return a;
        }
      } else {
        a = v.match(_strictNumExp) || _colorLookup.transparent;
      }
      a = a.map(Number);
    }
    if (toHSL && !wasHSL) {
      r = a[0] / _255;
      g = a[1] / _255;
      b = a[2] / _255;
      max = Math.max(r, g, b);
      min = Math.min(r, g, b);
      l = (max + min) / 2;
      if (max === min) {
        h2 = s = 0;
      } else {
        d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        h2 = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
        h2 *= 60;
      }
      a[0] = ~~(h2 + 0.5);
      a[1] = ~~(s * 100 + 0.5);
      a[2] = ~~(l * 100 + 0.5);
    }
    forceAlpha && a.length < 4 && (a[3] = 1);
    return a;
  };
  var _colorOrderData = function _colorOrderData2(v) {
    var values = [], c = [], i = -1;
    v.split(_colorExp).forEach(function(v2) {
      var a = v2.match(_numWithUnitExp) || [];
      values.push.apply(values, a);
      c.push(i += a.length + 1);
    });
    values.c = c;
    return values;
  };
  var _formatColors = function _formatColors2(s, toHSL, orderMatchData) {
    var result = "", colors = (s + result).match(_colorExp), type = toHSL ? "hsla(" : "rgba(", i = 0, c, shell, d, l;
    if (!colors) {
      return s;
    }
    colors = colors.map(function(color) {
      return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
    });
    if (orderMatchData) {
      d = _colorOrderData(s);
      c = orderMatchData.c;
      if (c.join(result) !== d.c.join(result)) {
        shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
        l = shell.length - 1;
        for (; i < l; i++) {
          result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
        }
      }
    }
    if (!shell) {
      shell = s.split(_colorExp);
      l = shell.length - 1;
      for (; i < l; i++) {
        result += shell[i] + colors[i];
      }
    }
    return result + shell[l];
  };
  var _colorExp = function() {
    var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", p;
    for (p in _colorLookup) {
      s += "|" + p + "\\b";
    }
    return new RegExp(s + ")", "gi");
  }();
  var _hslExp = /hsl[a]?\(/;
  var _colorStringFilter = function _colorStringFilter2(a) {
    var combined = a.join(" "), toHSL;
    _colorExp.lastIndex = 0;
    if (_colorExp.test(combined)) {
      toHSL = _hslExp.test(combined);
      a[1] = _formatColors(a[1], toHSL);
      a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1]));
      return true;
    }
  };
  var _tickerActive;
  var _ticker = function() {
    var _getTime3 = Date.now, _lagThreshold = 500, _adjustedLag = 33, _startTime = _getTime3(), _lastUpdate = _startTime, _gap = 1e3 / 240, _nextTime = _gap, _listeners3 = [], _id, _req, _raf, _self, _delta, _i2, _tick = function _tick2(v) {
      var elapsed = _getTime3() - _lastUpdate, manual = v === true, overlap, dispatch, time, frame;
      (elapsed > _lagThreshold || elapsed < 0) && (_startTime += elapsed - _adjustedLag);
      _lastUpdate += elapsed;
      time = _lastUpdate - _startTime;
      overlap = time - _nextTime;
      if (overlap > 0 || manual) {
        frame = ++_self.frame;
        _delta = time - _self.time * 1e3;
        _self.time = time = time / 1e3;
        _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
        dispatch = 1;
      }
      manual || (_id = _req(_tick2));
      if (dispatch) {
        for (_i2 = 0; _i2 < _listeners3.length; _i2++) {
          _listeners3[_i2](time, _delta, frame, v);
        }
      }
    };
    _self = {
      time: 0,
      frame: 0,
      tick: function tick() {
        _tick(true);
      },
      deltaRatio: function deltaRatio(fps) {
        return _delta / (1e3 / (fps || 60));
      },
      wake: function wake() {
        if (_coreReady) {
          if (!_coreInitted && _windowExists()) {
            _win = _coreInitted = window;
            _doc = _win.document || {};
            _globals.gsap = gsap;
            (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);
            _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});
            _registerPluginQueue.forEach(_createPlugin);
          }
          _raf = typeof requestAnimationFrame !== "undefined" && requestAnimationFrame;
          _id && _self.sleep();
          _req = _raf || function(f) {
            return setTimeout(f, _nextTime - _self.time * 1e3 + 1 | 0);
          };
          _tickerActive = 1;
          _tick(2);
        }
      },
      sleep: function sleep() {
        (_raf ? cancelAnimationFrame : clearTimeout)(_id);
        _tickerActive = 0;
        _req = _emptyFunc;
      },
      lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
        _lagThreshold = threshold || Infinity;
        _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);
      },
      fps: function fps(_fps) {
        _gap = 1e3 / (_fps || 240);
        _nextTime = _self.time * 1e3 + _gap;
      },
      add: function add(callback, once, prioritize) {
        var func = once ? function(t, d, f, v) {
          callback(t, d, f, v);
          _self.remove(func);
        } : callback;
        _self.remove(callback);
        _listeners3[prioritize ? "unshift" : "push"](func);
        _wake();
        return func;
      },
      remove: function remove(callback, i) {
        ~(i = _listeners3.indexOf(callback)) && _listeners3.splice(i, 1) && _i2 >= i && _i2--;
      },
      _listeners: _listeners3
    };
    return _self;
  }();
  var _wake = function _wake2() {
    return !_tickerActive && _ticker.wake();
  };
  var _easeMap = {};
  var _customEaseExp = /^[\d.\-M][\d.\-,\s]/;
  var _quotesExp = /["']/g;
  var _parseObjectInString = function _parseObjectInString2(value) {
    var obj = {}, split2 = value.substr(1, value.length - 3).split(":"), key = split2[0], i = 1, l = split2.length, index, val, parsedVal;
    for (; i < l; i++) {
      val = split2[i];
      index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
      parsedVal = val.substr(0, index);
      obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
      key = val.substr(index + 1).trim();
    }
    return obj;
  };
  var _valueInParentheses = function _valueInParentheses2(value) {
    var open = value.indexOf("(") + 1, close = value.indexOf(")"), nested = value.indexOf("(", open);
    return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
  };
  var _configEaseFromString = function _configEaseFromString2(name) {
    var split2 = (name + "").split("("), ease = _easeMap[split2[0]];
    return ease && split2.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split2[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
  };
  var _invertEase = function _invertEase2(ease) {
    return function(p) {
      return 1 - ease(1 - p);
    };
  };
  var _propagateYoyoEase = function _propagateYoyoEase2(timeline2, isYoyo) {
    var child = timeline2._first, ease;
    while (child) {
      if (child instanceof Timeline) {
        _propagateYoyoEase2(child, isYoyo);
      } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
        if (child.timeline) {
          _propagateYoyoEase2(child.timeline, isYoyo);
        } else {
          ease = child._ease;
          child._ease = child._yEase;
          child._yEase = ease;
          child._yoyo = isYoyo;
        }
      }
      child = child._next;
    }
  };
  var _parseEase = function _parseEase2(ease, defaultEase) {
    return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
  };
  var _insertEase = function _insertEase2(names, easeIn, easeOut, easeInOut) {
    if (easeOut === void 0) {
      easeOut = function easeOut2(p) {
        return 1 - easeIn(1 - p);
      };
    }
    if (easeInOut === void 0) {
      easeInOut = function easeInOut2(p) {
        return p < 0.5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
      };
    }
    var ease = {
      easeIn,
      easeOut,
      easeInOut
    }, lowercaseName;
    _forEachName(names, function(name) {
      _easeMap[name] = _globals[name] = ease;
      _easeMap[lowercaseName = name.toLowerCase()] = easeOut;
      for (var p in ease) {
        _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
      }
    });
    return ease;
  };
  var _easeInOutFromOut = function _easeInOutFromOut2(easeOut) {
    return function(p) {
      return p < 0.5 ? (1 - easeOut(1 - p * 2)) / 2 : 0.5 + easeOut((p - 0.5) * 2) / 2;
    };
  };
  var _configElastic = function _configElastic2(type, amplitude, period) {
    var p1 = amplitude >= 1 ? amplitude : 1, p2 = (period || (type ? 0.3 : 0.45)) / (amplitude < 1 ? amplitude : 1), p3 = p2 / _2PI * (Math.asin(1 / p1) || 0), easeOut = function easeOut2(p) {
      return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
    }, ease = type === "out" ? easeOut : type === "in" ? function(p) {
      return 1 - easeOut(1 - p);
    } : _easeInOutFromOut(easeOut);
    p2 = _2PI / p2;
    ease.config = function(amplitude2, period2) {
      return _configElastic2(type, amplitude2, period2);
    };
    return ease;
  };
  var _configBack = function _configBack2(type, overshoot) {
    if (overshoot === void 0) {
      overshoot = 1.70158;
    }
    var easeOut = function easeOut2(p) {
      return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
    }, ease = type === "out" ? easeOut : type === "in" ? function(p) {
      return 1 - easeOut(1 - p);
    } : _easeInOutFromOut(easeOut);
    ease.config = function(overshoot2) {
      return _configBack2(type, overshoot2);
    };
    return ease;
  };
  _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function(name, i) {
    var power = i < 5 ? i + 1 : i;
    _insertEase(name + ",Power" + (power - 1), i ? function(p) {
      return Math.pow(p, power);
    } : function(p) {
      return p;
    }, function(p) {
      return 1 - Math.pow(1 - p, power);
    }, function(p) {
      return p < 0.5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
    });
  });
  _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
  _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
  (function(n, c) {
    var n1 = 1 / c, n2 = 2 * n1, n3 = 2.5 * n1, easeOut = function easeOut2(p) {
      return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + 0.75 : p < n3 ? n * (p -= 2.25 / c) * p + 0.9375 : n * Math.pow(p - 2.625 / c, 2) + 0.984375;
    };
    _insertEase("Bounce", function(p) {
      return 1 - easeOut(1 - p);
    }, easeOut);
  })(7.5625, 2.75);
  _insertEase("Expo", function(p) {
    return Math.pow(2, 10 * (p - 1)) * p + p * p * p * p * p * p * (1 - p);
  });
  _insertEase("Circ", function(p) {
    return -(_sqrt(1 - p * p) - 1);
  });
  _insertEase("Sine", function(p) {
    return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
  });
  _insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
  _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
    config: function config(steps, immediateStart) {
      if (steps === void 0) {
        steps = 1;
      }
      var p1 = 1 / steps, p2 = steps + (immediateStart ? 0 : 1), p3 = immediateStart ? 1 : 0, max = 1 - _tinyNum;
      return function(p) {
        return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
      };
    }
  };
  _defaults.ease = _easeMap["quad.out"];
  _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(name) {
    return _callbackNames += name + "," + name + "Params,";
  });
  var GSCache = function GSCache2(target, harness) {
    this.id = _gsID++;
    target._gsap = this;
    this.target = target;
    this.harness = harness;
    this.get = harness ? harness.get : _getProperty;
    this.set = harness ? harness.getSetter : _getSetter;
  };
  var Animation = /* @__PURE__ */ function() {
    function Animation2(vars) {
      this.vars = vars;
      this._delay = +vars.delay || 0;
      if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
        this._rDelay = vars.repeatDelay || 0;
        this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
      }
      this._ts = 1;
      _setDuration(this, +vars.duration, 1, 1);
      this.data = vars.data;
      if (_context) {
        this._ctx = _context;
        _context.data.push(this);
      }
      _tickerActive || _ticker.wake();
    }
    var _proto = Animation2.prototype;
    _proto.delay = function delay2(value) {
      if (value || value === 0) {
        this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
        this._delay = value;
        return this;
      }
      return this._delay;
    };
    _proto.duration = function duration(value) {
      return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
    };
    _proto.totalDuration = function totalDuration(value) {
      if (!arguments.length) {
        return this._tDur;
      }
      this._dirty = 0;
      return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
    };
    _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
      _wake();
      if (!arguments.length) {
        return this._tTime;
      }
      var parent = this._dp;
      if (parent && parent.smoothChildTiming && this._ts) {
        _alignPlayhead(this, _totalTime);
        !parent._dp || parent.parent || _postAddChecks(parent, this);
        while (parent && parent.parent) {
          if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
            parent.totalTime(parent._tTime, true);
          }
          parent = parent.parent;
        }
        if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
          _addToTimeline(this._dp, this, this._start - this._delay);
        }
      }
      if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
        this._ts || (this._pTime = _totalTime);
        _lazySafeRender(this, _totalTime, suppressEvents);
      }
      return this;
    };
    _proto.time = function time(value, suppressEvents) {
      return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time;
    };
    _proto.totalProgress = function totalProgress(value, suppressEvents) {
      return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0;
    };
    _proto.progress = function progress(value, suppressEvents) {
      return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
    };
    _proto.iteration = function iteration(value, suppressEvents) {
      var cycleDuration = this.duration() + this._rDelay;
      return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
    };
    _proto.timeScale = function timeScale(value, suppressEvents) {
      if (!arguments.length) {
        return this._rts === -_tinyNum ? 0 : this._rts;
      }
      if (this._rts === value) {
        return this;
      }
      var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
      this._rts = +value || 0;
      this._ts = this._ps || value === -_tinyNum ? 0 : this._rts;
      this.totalTime(_clamp(-Math.abs(this._delay), this._tDur, tTime), suppressEvents !== false);
      _setEnd(this);
      return _recacheAncestors(this);
    };
    _proto.paused = function paused(value) {
      if (!arguments.length) {
        return this._ps;
      }
      if (this._ps !== value) {
        this._ps = value;
        if (value) {
          this._pTime = this._tTime || Math.max(-this._delay, this.rawTime());
          this._ts = this._act = 0;
        } else {
          _wake();
          this._ts = this._rts;
          this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum));
        }
      }
      return this;
    };
    _proto.startTime = function startTime(value) {
      if (arguments.length) {
        this._start = value;
        var parent = this.parent || this._dp;
        parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
        return this;
      }
      return this._start;
    };
    _proto.endTime = function endTime(includeRepeats) {
      return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
    };
    _proto.rawTime = function rawTime(wrapRepeats) {
      var parent = this.parent || this._dp;
      return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
    };
    _proto.revert = function revert(config6) {
      if (config6 === void 0) {
        config6 = _revertConfig;
      }
      var prevIsReverting = _reverting;
      _reverting = config6;
      if (this._initted || this._startAt) {
        this.timeline && this.timeline.revert(config6);
        this.totalTime(-0.01, config6.suppressEvents);
      }
      this.data !== "nested" && config6.kill !== false && this.kill();
      _reverting = prevIsReverting;
      return this;
    };
    _proto.globalTime = function globalTime(rawTime) {
      var animation = this, time = arguments.length ? rawTime : animation.rawTime();
      while (animation) {
        time = animation._start + time / (Math.abs(animation._ts) || 1);
        animation = animation._dp;
      }
      return !this.parent && this._sat ? this._sat.globalTime(rawTime) : time;
    };
    _proto.repeat = function repeat2(value) {
      if (arguments.length) {
        this._repeat = value === Infinity ? -2 : value;
        return _onUpdateTotalDuration(this);
      }
      return this._repeat === -2 ? Infinity : this._repeat;
    };
    _proto.repeatDelay = function repeatDelay(value) {
      if (arguments.length) {
        var time = this._time;
        this._rDelay = value;
        _onUpdateTotalDuration(this);
        return time ? this.time(time) : this;
      }
      return this._rDelay;
    };
    _proto.yoyo = function yoyo(value) {
      if (arguments.length) {
        this._yoyo = value;
        return this;
      }
      return this._yoyo;
    };
    _proto.seek = function seek(position, suppressEvents) {
      return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
    };
    _proto.restart = function restart(includeDelay, suppressEvents) {
      this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
      this._dur || (this._zTime = -_tinyNum);
      return this;
    };
    _proto.play = function play(from2, suppressEvents) {
      from2 != null && this.seek(from2, suppressEvents);
      return this.reversed(false).paused(false);
    };
    _proto.reverse = function reverse(from2, suppressEvents) {
      from2 != null && this.seek(from2 || this.totalDuration(), suppressEvents);
      return this.reversed(true).paused(false);
    };
    _proto.pause = function pause(atTime, suppressEvents) {
      atTime != null && this.seek(atTime, suppressEvents);
      return this.paused(true);
    };
    _proto.resume = function resume() {
      return this.paused(false);
    };
    _proto.reversed = function reversed(value) {
      if (arguments.length) {
        !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0));
        return this;
      }
      return this._rts < 0;
    };
    _proto.invalidate = function invalidate() {
      this._initted = this._act = 0;
      this._zTime = -_tinyNum;
      return this;
    };
    _proto.isActive = function isActive() {
      var parent = this.parent || this._dp, start = this._start, rawTime;
      return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
    };
    _proto.eventCallback = function eventCallback(type, callback, params) {
      var vars = this.vars;
      if (arguments.length > 1) {
        if (!callback) {
          delete vars[type];
        } else {
          vars[type] = callback;
          params && (vars[type + "Params"] = params);
          type === "onUpdate" && (this._onUpdate = callback);
        }
        return this;
      }
      return vars[type];
    };
    _proto.then = function then(onFulfilled) {
      var self = this;
      return new Promise(function(resolve3) {
        var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough, _resolve = function _resolve2() {
          var _then = self.then;
          self.then = null;
          _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
          resolve3(f);
          self.then = _then;
        };
        if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {
          _resolve();
        } else {
          self._prom = _resolve;
        }
      });
    };
    _proto.kill = function kill2() {
      _interrupt(this);
    };
    return Animation2;
  }();
  _setDefaults(Animation.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: false,
    parent: null,
    _initted: false,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -_tinyNum,
    _prom: 0,
    _ps: false,
    _rts: 1
  });
  var Timeline = /* @__PURE__ */ function(_Animation) {
    _inheritsLoose(Timeline2, _Animation);
    function Timeline2(vars, position) {
      var _this;
      if (vars === void 0) {
        vars = {};
      }
      _this = _Animation.call(this, vars) || this;
      _this.labels = {};
      _this.smoothChildTiming = !!vars.smoothChildTiming;
      _this.autoRemoveChildren = !!vars.autoRemoveChildren;
      _this._sort = _isNotFalse(vars.sortChildren);
      _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
      vars.reversed && _this.reverse();
      vars.paused && _this.paused(true);
      vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
      return _this;
    }
    var _proto2 = Timeline2.prototype;
    _proto2.to = function to(targets, vars, position) {
      _createTweenType(0, arguments, this);
      return this;
    };
    _proto2.from = function from2(targets, vars, position) {
      _createTweenType(1, arguments, this);
      return this;
    };
    _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
      _createTweenType(2, arguments, this);
      return this;
    };
    _proto2.set = function set(targets, vars, position) {
      vars.duration = 0;
      vars.parent = this;
      _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
      vars.immediateRender = !!vars.immediateRender;
      new Tween(targets, vars, _parsePosition(this, position), 1);
      return this;
    };
    _proto2.call = function call(callback, params, position) {
      return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
    };
    _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
      vars.duration = duration;
      vars.stagger = vars.stagger || stagger;
      vars.onComplete = onCompleteAll;
      vars.onCompleteParams = onCompleteAllParams;
      vars.parent = this;
      new Tween(targets, vars, _parsePosition(this, position));
      return this;
    };
    _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
      vars.runBackwards = 1;
      _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
      return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
    };
    _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
      toVars.startAt = fromVars;
      _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
      return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
    };
    _proto2.render = function render4(totalTime, suppressEvents, force) {
      var prevTime = this._time, tDur = this._dirty ? this.totalDuration() : this._tDur, dur = this._dur, tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime), crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur), time, child, next, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo;
      this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);
      if (tTime !== this._tTime || force || crossingStart) {
        if (prevTime !== this._time && dur) {
          tTime += this._time - prevTime;
          totalTime += this._time - prevTime;
        }
        time = tTime;
        prevStart = this._start;
        timeScale = this._ts;
        prevPaused = !timeScale;
        if (crossingStart) {
          dur || (prevTime = this._zTime);
          (totalTime || !suppressEvents) && (this._zTime = totalTime);
        }
        if (this._repeat) {
          yoyo = this._yoyo;
          cycleDuration = dur + this._rDelay;
          if (this._repeat < -1 && totalTime < 0) {
            return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
          }
          time = _roundPrecise(tTime % cycleDuration);
          if (tTime === tDur) {
            iteration = this._repeat;
            time = dur;
          } else {
            prevIteration = _roundPrecise(tTime / cycleDuration);
            iteration = ~~prevIteration;
            if (iteration && iteration === prevIteration) {
              time = dur;
              iteration--;
            }
            time > dur && (time = dur);
          }
          prevIteration = _animationCycle(this._tTime, cycleDuration);
          !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration);
          if (yoyo && iteration & 1) {
            time = dur - time;
            isYoyo = 1;
          }
          if (iteration !== prevIteration && !this._lock) {
            var rewinding = yoyo && prevIteration & 1, doesWrap = rewinding === (yoyo && iteration & 1);
            iteration < prevIteration && (rewinding = !rewinding);
            prevTime = rewinding ? 0 : tTime % dur ? dur : tTime;
            this._lock = 1;
            this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
            this._tTime = tTime;
            !suppressEvents && this.parent && _callback(this, "onRepeat");
            this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);
            if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
              return this;
            }
            dur = this._dur;
            tDur = this._tDur;
            if (doesWrap) {
              this._lock = 2;
              prevTime = rewinding ? dur : -1e-4;
              this.render(prevTime, true);
              this.vars.repeatRefresh && !isYoyo && this.invalidate();
            }
            this._lock = 0;
            if (!this._ts && !prevPaused) {
              return this;
            }
            _propagateYoyoEase(this, isYoyo);
          }
        }
        if (this._hasPause && !this._forcing && this._lock < 2) {
          pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));
          if (pauseTween) {
            tTime -= time - (time = pauseTween._start);
          }
        }
        this._tTime = tTime;
        this._time = time;
        this._act = !timeScale;
        if (!this._initted) {
          this._onUpdate = this.vars.onUpdate;
          this._initted = 1;
          this._zTime = totalTime;
          prevTime = 0;
        }
        if (!prevTime && time && !suppressEvents && !iteration) {
          _callback(this, "onStart");
          if (this._tTime !== tTime) {
            return this;
          }
        }
        if (time >= prevTime && totalTime >= 0) {
          child = this._first;
          while (child) {
            next = child._next;
            if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                return this.render(totalTime, suppressEvents, force);
              }
              child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);
              if (time !== this._time || !this._ts && !prevPaused) {
                pauseTween = 0;
                next && (tTime += this._zTime = -_tinyNum);
                break;
              }
            }
            child = next;
          }
        } else {
          child = this._last;
          var adjustedTime = totalTime < 0 ? totalTime : time;
          while (child) {
            next = child._prev;
            if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                return this.render(totalTime, suppressEvents, force);
              }
              child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && (child._initted || child._startAt));
              if (time !== this._time || !this._ts && !prevPaused) {
                pauseTween = 0;
                next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum);
                break;
              }
            }
            child = next;
          }
        }
        if (pauseTween && !suppressEvents) {
          this.pause();
          pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;
          if (this._ts) {
            this._start = prevStart;
            _setEnd(this);
            return this.render(totalTime, suppressEvents, force);
          }
        }
        this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
        if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) {
          if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) {
            if (!this._lock) {
              (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
              if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
                _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);
                this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
              }
            }
          }
        }
      }
      return this;
    };
    _proto2.add = function add(child, position) {
      var _this2 = this;
      _isNumber(position) || (position = _parsePosition(this, position, child));
      if (!(child instanceof Animation)) {
        if (_isArray(child)) {
          child.forEach(function(obj) {
            return _this2.add(obj, position);
          });
          return this;
        }
        if (_isString(child)) {
          return this.addLabel(child, position);
        }
        if (_isFunction(child)) {
          child = Tween.delayedCall(0, child);
        } else {
          return this;
        }
      }
      return this !== child ? _addToTimeline(this, child, position) : this;
    };
    _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
      if (nested === void 0) {
        nested = true;
      }
      if (tweens === void 0) {
        tweens = true;
      }
      if (timelines === void 0) {
        timelines = true;
      }
      if (ignoreBeforeTime === void 0) {
        ignoreBeforeTime = -_bigNum;
      }
      var a = [], child = this._first;
      while (child) {
        if (child._start >= ignoreBeforeTime) {
          if (child instanceof Tween) {
            tweens && a.push(child);
          } else {
            timelines && a.push(child);
            nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
          }
        }
        child = child._next;
      }
      return a;
    };
    _proto2.getById = function getById2(id) {
      var animations = this.getChildren(1, 1, 1), i = animations.length;
      while (i--) {
        if (animations[i].vars.id === id) {
          return animations[i];
        }
      }
    };
    _proto2.remove = function remove(child) {
      if (_isString(child)) {
        return this.removeLabel(child);
      }
      if (_isFunction(child)) {
        return this.killTweensOf(child);
      }
      child.parent === this && _removeLinkedListItem(this, child);
      if (child === this._recent) {
        this._recent = this._last;
      }
      return _uncache(this);
    };
    _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
      if (!arguments.length) {
        return this._tTime;
      }
      this._forcing = 1;
      if (!this._dp && this._ts) {
        this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
      }
      _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);
      this._forcing = 0;
      return this;
    };
    _proto2.addLabel = function addLabel(label, position) {
      this.labels[label] = _parsePosition(this, position);
      return this;
    };
    _proto2.removeLabel = function removeLabel(label) {
      delete this.labels[label];
      return this;
    };
    _proto2.addPause = function addPause(position, callback, params) {
      var t = Tween.delayedCall(0, callback || _emptyFunc, params);
      t.data = "isPause";
      this._hasPause = 1;
      return _addToTimeline(this, t, _parsePosition(this, position));
    };
    _proto2.removePause = function removePause(position) {
      var child = this._first;
      position = _parsePosition(this, position);
      while (child) {
        if (child._start === position && child.data === "isPause") {
          _removeFromParent(child);
        }
        child = child._next;
      }
    };
    _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
      var tweens = this.getTweensOf(targets, onlyActive), i = tweens.length;
      while (i--) {
        _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
      }
      return this;
    };
    _proto2.getTweensOf = function getTweensOf2(targets, onlyActive) {
      var a = [], parsedTargets = toArray(targets), child = this._first, isGlobalTime = _isNumber(onlyActive), children;
      while (child) {
        if (child instanceof Tween) {
          if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
            a.push(child);
          }
        } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
          a.push.apply(a, children);
        }
        child = child._next;
      }
      return a;
    };
    _proto2.tweenTo = function tweenTo(position, vars) {
      vars = vars || {};
      var tl = this, endTime = _parsePosition(tl, position), _vars = vars, startAt = _vars.startAt, _onStart = _vars.onStart, onStartParams = _vars.onStartParams, immediateRender = _vars.immediateRender, initted, tween = Tween.to(tl, _setDefaults({
        ease: vars.ease || "none",
        lazy: false,
        immediateRender: false,
        time: endTime,
        overwrite: "auto",
        duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
        onStart: function onStart() {
          tl.pause();
          if (!initted) {
            var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
            tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
            initted = 1;
          }
          _onStart && _onStart.apply(tween, onStartParams || []);
        }
      }, vars));
      return immediateRender ? tween.render(0) : tween;
    };
    _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
      return this.tweenTo(toPosition, _setDefaults({
        startAt: {
          time: _parsePosition(this, fromPosition)
        }
      }, vars));
    };
    _proto2.recent = function recent() {
      return this._recent;
    };
    _proto2.nextLabel = function nextLabel(afterTime) {
      if (afterTime === void 0) {
        afterTime = this._time;
      }
      return _getLabelInDirection(this, _parsePosition(this, afterTime));
    };
    _proto2.previousLabel = function previousLabel(beforeTime) {
      if (beforeTime === void 0) {
        beforeTime = this._time;
      }
      return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
    };
    _proto2.currentLabel = function currentLabel(value) {
      return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
    };
    _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
      if (ignoreBeforeTime === void 0) {
        ignoreBeforeTime = 0;
      }
      var child = this._first, labels = this.labels, p;
      while (child) {
        if (child._start >= ignoreBeforeTime) {
          child._start += amount;
          child._end += amount;
        }
        child = child._next;
      }
      if (adjustLabels) {
        for (p in labels) {
          if (labels[p] >= ignoreBeforeTime) {
            labels[p] += amount;
          }
        }
      }
      return _uncache(this);
    };
    _proto2.invalidate = function invalidate(soft) {
      var child = this._first;
      this._lock = 0;
      while (child) {
        child.invalidate(soft);
        child = child._next;
      }
      return _Animation.prototype.invalidate.call(this, soft);
    };
    _proto2.clear = function clear(includeLabels) {
      if (includeLabels === void 0) {
        includeLabels = true;
      }
      var child = this._first, next;
      while (child) {
        next = child._next;
        this.remove(child);
        child = next;
      }
      this._dp && (this._time = this._tTime = this._pTime = 0);
      includeLabels && (this.labels = {});
      return _uncache(this);
    };
    _proto2.totalDuration = function totalDuration(value) {
      var max = 0, self = this, child = self._last, prevStart = _bigNum, prev, start, parent;
      if (arguments.length) {
        return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
      }
      if (self._dirty) {
        parent = self.parent;
        while (child) {
          prev = child._prev;
          child._dirty && child.totalDuration();
          start = child._start;
          if (start > prevStart && self._sort && child._ts && !self._lock) {
            self._lock = 1;
            _addToTimeline(self, child, start - child._delay, 1)._lock = 0;
          } else {
            prevStart = start;
          }
          if (start < 0 && child._ts) {
            max -= start;
            if (!parent && !self._dp || parent && parent.smoothChildTiming) {
              self._start += start / self._ts;
              self._time -= start;
              self._tTime -= start;
            }
            self.shiftChildren(-start, false, -Infinity);
            prevStart = 0;
          }
          child._end > max && child._ts && (max = child._end);
          child = prev;
        }
        _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);
        self._dirty = 0;
      }
      return self._tDur;
    };
    Timeline2.updateRoot = function updateRoot(time) {
      if (_globalTimeline._ts) {
        _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));
        _lastRenderedFrame = _ticker.frame;
      }
      if (_ticker.frame >= _nextGCFrame) {
        _nextGCFrame += _config.autoSleep || 120;
        var child = _globalTimeline._first;
        if (!child || !child._ts) {
          if (_config.autoSleep && _ticker._listeners.length < 2) {
            while (child && !child._ts) {
              child = child._next;
            }
            child || _ticker.sleep();
          }
        }
      }
    };
    return Timeline2;
  }(Animation);
  _setDefaults(Timeline.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
  });
  var _addComplexStringPropTween = function _addComplexStringPropTween2(target, prop, start, end, setter, stringFilter, funcParam) {
    var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter), index = 0, matchIndex = 0, result, startNums, color, endNum, chunk, startNum, hasRandom, a;
    pt.b = start;
    pt.e = end;
    start += "";
    end += "";
    if (hasRandom = ~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }
    if (stringFilter) {
      a = [start, end];
      stringFilter(a, target, prop);
      start = a[0];
      end = a[1];
    }
    startNums = start.match(_complexStringNumExp) || [];
    while (result = _complexStringNumExp.exec(end)) {
      endNum = result[0];
      chunk = end.substring(index, result.index);
      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(") {
        color = 1;
      }
      if (endNum !== startNums[matchIndex++]) {
        startNum = parseFloat(startNums[matchIndex - 1]) || 0;
        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
          m: color && color < 4 ? Math.round : 0
        };
        index = _complexStringNumExp.lastIndex;
      }
    }
    pt.c = index < end.length ? end.substring(index, end.length) : "";
    pt.fp = funcParam;
    if (_relExp.test(end) || hasRandom) {
      pt.e = 0;
    }
    this._pt = pt;
    return pt;
  };
  var _addPropTween = function _addPropTween2(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {
    _isFunction(end) && (end = end(index || 0, target, targets));
    var currentValue = target[prop], parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](), setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc, pt;
    if (_isString(end)) {
      if (~end.indexOf("random(")) {
        end = _replaceRandom(end);
      }
      if (end.charAt(1) === "=") {
        pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);
        if (pt || pt === 0) {
          end = pt;
        }
      }
    }
    if (!optional || parsedStart !== end || _forceAllPropTweens) {
      if (!isNaN(parsedStart * end) && end !== "") {
        pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
        funcParam && (pt.fp = funcParam);
        modifier && pt.modifier(modifier, this, target);
        return this._pt = pt;
      }
      !currentValue && !(prop in target) && _missingPlugin(prop, end);
      return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
    }
  };
  var _processVars = function _processVars2(vars, index, target, targets, tween) {
    _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));
    if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
      return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
    }
    var copy = {}, p;
    for (p in vars) {
      copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
    }
    return copy;
  };
  var _checkPlugin = function _checkPlugin2(property, vars, tween, index, target, targets) {
    var plugin, pt, ptLookup, i;
    if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
      tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);
      if (tween !== _quickTween) {
        ptLookup = tween._ptLookup[tween._targets.indexOf(target)];
        i = plugin._props.length;
        while (i--) {
          ptLookup[plugin._props[i]] = pt;
        }
      }
    }
    return plugin;
  };
  var _overwritingTween;
  var _forceAllPropTweens;
  var _initTween = function _initTween2(tween, time, tTime) {
    var vars = tween.vars, ease = vars.ease, startAt = vars.startAt, immediateRender = vars.immediateRender, lazy = vars.lazy, onUpdate = vars.onUpdate, runBackwards = vars.runBackwards, yoyoEase = vars.yoyoEase, keyframes = vars.keyframes, autoRevert = vars.autoRevert, dur = tween._dur, prevStartAt = tween._startAt, targets = tween._targets, parent = tween.parent, fullTargets = parent && parent.data === "nested" ? parent.vars.targets : targets, autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites, tl = tween.timeline, cleanVars, i, p, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index, harnessVars, overwritten;
    tl && (!keyframes || !ease) && (ease = "none");
    tween._ease = _parseEase(ease, _defaults.ease);
    tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;
    if (yoyoEase && tween._yoyo && !tween._repeat) {
      yoyoEase = tween._yEase;
      tween._yEase = tween._ease;
      tween._ease = yoyoEase;
    }
    tween._from = !tl && !!vars.runBackwards;
    if (!tl || keyframes && !vars.stagger) {
      harness = targets[0] ? _getCache(targets[0]).harness : 0;
      harnessVars = harness && vars[harness.prop];
      cleanVars = _copyExcluding(vars, _reservedProps);
      if (prevStartAt) {
        prevStartAt._zTime < 0 && prevStartAt.progress(1);
        time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig);
        prevStartAt._lazy = 0;
      }
      if (startAt) {
        _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
          data: "isStart",
          overwrite: false,
          parent,
          immediateRender: true,
          lazy: !prevStartAt && _isNotFalse(lazy),
          startAt: null,
          delay: 0,
          onUpdate: onUpdate && function() {
            return _callback(tween, "onUpdate");
          },
          stagger: 0
        }, startAt)));
        tween._startAt._dp = 0;
        tween._startAt._sat = tween;
        time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill);
        if (immediateRender) {
          if (dur && time <= 0 && tTime <= 0) {
            time && (tween._zTime = time);
            return;
          }
        }
      } else if (runBackwards && dur) {
        if (!prevStartAt) {
          time && (immediateRender = false);
          p = _setDefaults({
            overwrite: false,
            data: "isFromStart",
            //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
            lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),
            immediateRender,
            //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
            stagger: 0,
            parent
            //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})
          }, cleanVars);
          harnessVars && (p[harness.prop] = harnessVars);
          _removeFromParent(tween._startAt = Tween.set(targets, p));
          tween._startAt._dp = 0;
          tween._startAt._sat = tween;
          time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));
          tween._zTime = time;
          if (!immediateRender) {
            _initTween2(tween._startAt, _tinyNum, _tinyNum);
          } else if (!time) {
            return;
          }
        }
      }
      tween._pt = tween._ptCache = 0;
      lazy = dur && _isNotFalse(lazy) || lazy && !dur;
      for (i = 0; i < targets.length; i++) {
        target = targets[i];
        gsData = target._gsap || _harness(targets)[i]._gsap;
        tween._ptLookup[i] = ptLookup = {};
        _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();
        index = fullTargets === targets ? i : fullTargets.indexOf(target);
        if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
          tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
          plugin._props.forEach(function(name) {
            ptLookup[name] = pt;
          });
          plugin.priority && (hasPriority = 1);
        }
        if (!harness || harnessVars) {
          for (p in cleanVars) {
            if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
              plugin.priority && (hasPriority = 1);
            } else {
              ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
            }
          }
        }
        tween._op && tween._op[i] && tween.kill(target, tween._op[i]);
        if (autoOverwrite && tween._pt) {
          _overwritingTween = tween;
          _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time));
          overwritten = !tween.parent;
          _overwritingTween = 0;
        }
        tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
      }
      hasPriority && _sortPropTweensByPriority(tween);
      tween._onInit && tween._onInit(tween);
    }
    tween._onUpdate = onUpdate;
    tween._initted = (!tween._op || tween._pt) && !overwritten;
    keyframes && time <= 0 && tl.render(_bigNum, true, true);
  };
  var _updatePropTweens = function _updatePropTweens2(tween, property, value, start, startIsRelative, ratio, time, skipRecursion) {
    var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property], pt, rootPT, lookup, i;
    if (!ptCache) {
      ptCache = tween._ptCache[property] = [];
      lookup = tween._ptLookup;
      i = tween._targets.length;
      while (i--) {
        pt = lookup[i][property];
        if (pt && pt.d && pt.d._pt) {
          pt = pt.d._pt;
          while (pt && pt.p !== property && pt.fp !== property) {
            pt = pt._next;
          }
        }
        if (!pt) {
          _forceAllPropTweens = 1;
          tween.vars[property] = "+=0";
          _initTween(tween, time);
          _forceAllPropTweens = 0;
          return skipRecursion ? _warn(property + " not eligible for reset") : 1;
        }
        ptCache.push(pt);
      }
    }
    i = ptCache.length;
    while (i--) {
      rootPT = ptCache[i];
      pt = rootPT._pt || rootPT;
      pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
      pt.c = value - pt.s;
      rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e));
      rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b));
    }
  };
  var _addAliasesToVars = function _addAliasesToVars2(targets, vars) {
    var harness = targets[0] ? _getCache(targets[0]).harness : 0, propertyAliases = harness && harness.aliases, copy, p, i, aliases;
    if (!propertyAliases) {
      return vars;
    }
    copy = _merge({}, vars);
    for (p in propertyAliases) {
      if (p in copy) {
        aliases = propertyAliases[p].split(",");
        i = aliases.length;
        while (i--) {
          copy[aliases[i]] = copy[p];
        }
      }
    }
    return copy;
  };
  var _parseKeyframe = function _parseKeyframe2(prop, obj, allProps, easeEach) {
    var ease = obj.ease || easeEach || "power1.inOut", p, a;
    if (_isArray(obj)) {
      a = allProps[prop] || (allProps[prop] = []);
      obj.forEach(function(value, i) {
        return a.push({
          t: i / (obj.length - 1) * 100,
          v: value,
          e: ease
        });
      });
    } else {
      for (p in obj) {
        a = allProps[p] || (allProps[p] = []);
        p === "ease" || a.push({
          t: parseFloat(prop),
          v: obj[p],
          e: ease
        });
      }
    }
  };
  var _parseFuncOrString = function _parseFuncOrString2(value, tween, i, target, targets) {
    return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
  };
  var _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert";
  var _staggerPropsToSkip = {};
  _forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function(name) {
    return _staggerPropsToSkip[name] = 1;
  });
  var Tween = /* @__PURE__ */ function(_Animation2) {
    _inheritsLoose(Tween2, _Animation2);
    function Tween2(targets, vars, position, skipInherit) {
      var _this3;
      if (typeof vars === "number") {
        position.duration = vars;
        vars = position;
        position = null;
      }
      _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
      var _this3$vars = _this3.vars, duration = _this3$vars.duration, delay2 = _this3$vars.delay, immediateRender = _this3$vars.immediateRender, stagger = _this3$vars.stagger, overwrite = _this3$vars.overwrite, keyframes = _this3$vars.keyframes, defaults2 = _this3$vars.defaults, scrollTrigger = _this3$vars.scrollTrigger, yoyoEase = _this3$vars.yoyoEase, parent = vars.parent || _globalTimeline, parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets), tl, i, copy, l, p, curTarget, staggerFunc, staggerVarsToMerge;
      _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://gsap.com", !_config.nullTargetWarn) || [];
      _this3._ptLookup = [];
      _this3._overwrite = overwrite;
      if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay2)) {
        vars = _this3.vars;
        tl = _this3.timeline = new Timeline({
          data: "nested",
          defaults: defaults2 || {},
          targets: parent && parent.data === "nested" ? parent.vars.targets : parsedTargets
        });
        tl.kill();
        tl.parent = tl._dp = _assertThisInitialized(_this3);
        tl._start = 0;
        if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay2)) {
          l = parsedTargets.length;
          staggerFunc = stagger && distribute(stagger);
          if (_isObject(stagger)) {
            for (p in stagger) {
              if (~_staggerTweenProps.indexOf(p)) {
                staggerVarsToMerge || (staggerVarsToMerge = {});
                staggerVarsToMerge[p] = stagger[p];
              }
            }
          }
          for (i = 0; i < l; i++) {
            copy = _copyExcluding(vars, _staggerPropsToSkip);
            copy.stagger = 0;
            yoyoEase && (copy.yoyoEase = yoyoEase);
            staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
            curTarget = parsedTargets[i];
            copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
            copy.delay = (+_parseFuncOrString(delay2, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;
            if (!stagger && l === 1 && copy.delay) {
              _this3._delay = delay2 = copy.delay;
              _this3._start += delay2;
              copy.delay = 0;
            }
            tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);
            tl._ease = _easeMap.none;
          }
          tl.duration() ? duration = delay2 = 0 : _this3.timeline = 0;
        } else if (keyframes) {
          _inheritDefaults(_setDefaults(tl.vars.defaults, {
            ease: "none"
          }));
          tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
          var time = 0, a, kf, v;
          if (_isArray(keyframes)) {
            keyframes.forEach(function(frame) {
              return tl.to(parsedTargets, frame, ">");
            });
            tl.duration();
          } else {
            copy = {};
            for (p in keyframes) {
              p === "ease" || p === "easeEach" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);
            }
            for (p in copy) {
              a = copy[p].sort(function(a2, b) {
                return a2.t - b.t;
              });
              time = 0;
              for (i = 0; i < a.length; i++) {
                kf = a[i];
                v = {
                  ease: kf.e,
                  duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration
                };
                v[p] = kf.v;
                tl.to(parsedTargets, v, time);
                time += v.duration;
              }
            }
            tl.duration() < duration && tl.to({}, {
              duration: duration - tl.duration()
            });
          }
        }
        duration || _this3.duration(duration = tl.duration());
      } else {
        _this3.timeline = 0;
      }
      if (overwrite === true && !_suppressOverwrites) {
        _overwritingTween = _assertThisInitialized(_this3);
        _globalTimeline.killTweensOf(parsedTargets);
        _overwritingTween = 0;
      }
      _addToTimeline(parent, _assertThisInitialized(_this3), position);
      vars.reversed && _this3.reverse();
      vars.paused && _this3.paused(true);
      if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
        _this3._tTime = -_tinyNum;
        _this3.render(Math.max(0, -delay2) || 0);
      }
      scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
      return _this3;
    }
    var _proto3 = Tween2.prototype;
    _proto3.render = function render4(totalTime, suppressEvents, force) {
      var prevTime = this._time, tDur = this._tDur, dur = this._dur, isNegative = totalTime < 0, tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime, time, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline2, yoyoEase;
      if (!dur) {
        _renderZeroDurationTween(this, totalTime, suppressEvents, force);
      } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative || this._lazy) {
        time = tTime;
        timeline2 = this.timeline;
        if (this._repeat) {
          cycleDuration = dur + this._rDelay;
          if (this._repeat < -1 && isNegative) {
            return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
          }
          time = _roundPrecise(tTime % cycleDuration);
          if (tTime === tDur) {
            iteration = this._repeat;
            time = dur;
          } else {
            prevIteration = _roundPrecise(tTime / cycleDuration);
            iteration = ~~prevIteration;
            if (iteration && iteration === prevIteration) {
              time = dur;
              iteration--;
            } else if (time > dur) {
              time = dur;
            }
          }
          isYoyo = this._yoyo && iteration & 1;
          if (isYoyo) {
            yoyoEase = this._yEase;
            time = dur - time;
          }
          prevIteration = _animationCycle(this._tTime, cycleDuration);
          if (time === prevTime && !force && this._initted && iteration === prevIteration) {
            this._tTime = tTime;
            return this;
          }
          if (iteration !== prevIteration) {
            timeline2 && this._yEase && _propagateYoyoEase(timeline2, isYoyo);
            if (this.vars.repeatRefresh && !isYoyo && !this._lock && time !== cycleDuration && this._initted) {
              this._lock = force = 1;
              this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
            }
          }
        }
        if (!this._initted) {
          if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {
            this._tTime = 0;
            return this;
          }
          if (prevTime !== this._time && !(force && this.vars.repeatRefresh && iteration !== prevIteration)) {
            return this;
          }
          if (dur !== this._dur) {
            return this.render(totalTime, suppressEvents, force);
          }
        }
        this._tTime = tTime;
        this._time = time;
        if (!this._act && this._ts) {
          this._act = 1;
          this._lazy = 0;
        }
        this.ratio = ratio = (yoyoEase || this._ease)(time / dur);
        if (this._from) {
          this.ratio = ratio = 1 - ratio;
        }
        if (time && !prevTime && !suppressEvents && !iteration) {
          _callback(this, "onStart");
          if (this._tTime !== tTime) {
            return this;
          }
        }
        pt = this._pt;
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
        timeline2 && timeline2.render(totalTime < 0 ? totalTime : timeline2._dur * timeline2._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);
        if (this._onUpdate && !suppressEvents) {
          isNegative && _rewindStartAt(this, totalTime, suppressEvents, force);
          _callback(this, "onUpdate");
        }
        this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");
        if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
          isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);
          (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
          if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {
            _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);
            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
          }
        }
      }
      return this;
    };
    _proto3.targets = function targets() {
      return this._targets;
    };
    _proto3.invalidate = function invalidate(soft) {
      (!soft || !this.vars.runBackwards) && (this._startAt = 0);
      this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;
      this._ptLookup = [];
      this.timeline && this.timeline.invalidate(soft);
      return _Animation2.prototype.invalidate.call(this, soft);
    };
    _proto3.resetTo = function resetTo(property, value, start, startIsRelative, skipRecursion) {
      _tickerActive || _ticker.wake();
      this._ts || this.play();
      var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts), ratio;
      this._initted || _initTween(this, time);
      ratio = this._ease(time / this._dur);
      if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time, skipRecursion)) {
        return this.resetTo(property, value, start, startIsRelative, 1);
      }
      _alignPlayhead(this, 0);
      this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
      return this.render(0);
    };
    _proto3.kill = function kill2(targets, vars) {
      if (vars === void 0) {
        vars = "all";
      }
      if (!targets && (!vars || vars === "all")) {
        this._lazy = this._pt = 0;
        this.parent ? _interrupt(this) : this.scrollTrigger && this.scrollTrigger.kill(!!_reverting);
        return this;
      }
      if (this.timeline) {
        var tDur = this.timeline.totalDuration();
        this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this);
        this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1);
        return this;
      }
      var parsedTargets = this._targets, killingTargets = targets ? toArray(targets) : parsedTargets, propTweenLookup = this._ptLookup, firstPT = this._pt, overwrittenProps, curLookup, curOverwriteProps, props, p, pt, i;
      if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
        vars === "all" && (this._pt = 0);
        return _interrupt(this);
      }
      overwrittenProps = this._op = this._op || [];
      if (vars !== "all") {
        if (_isString(vars)) {
          p = {};
          _forEachName(vars, function(name) {
            return p[name] = 1;
          });
          vars = p;
        }
        vars = _addAliasesToVars(parsedTargets, vars);
      }
      i = parsedTargets.length;
      while (i--) {
        if (~killingTargets.indexOf(parsedTargets[i])) {
          curLookup = propTweenLookup[i];
          if (vars === "all") {
            overwrittenProps[i] = vars;
            props = curLookup;
            curOverwriteProps = {};
          } else {
            curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
            props = vars;
          }
          for (p in props) {
            pt = curLookup && curLookup[p];
            if (pt) {
              if (!("kill" in pt.d) || pt.d.kill(p) === true) {
                _removeLinkedListItem(this, pt, "_pt");
              }
              delete curLookup[p];
            }
            if (curOverwriteProps !== "all") {
              curOverwriteProps[p] = 1;
            }
          }
        }
      }
      this._initted && !this._pt && firstPT && _interrupt(this);
      return this;
    };
    Tween2.to = function to(targets, vars) {
      return new Tween2(targets, vars, arguments[2]);
    };
    Tween2.from = function from2(targets, vars) {
      return _createTweenType(1, arguments);
    };
    Tween2.delayedCall = function delayedCall(delay2, callback, params, scope) {
      return new Tween2(callback, 0, {
        immediateRender: false,
        lazy: false,
        overwrite: false,
        delay: delay2,
        onComplete: callback,
        onReverseComplete: callback,
        onCompleteParams: params,
        onReverseCompleteParams: params,
        callbackScope: scope
      });
    };
    Tween2.fromTo = function fromTo(targets, fromVars, toVars) {
      return _createTweenType(2, arguments);
    };
    Tween2.set = function set(targets, vars) {
      vars.duration = 0;
      vars.repeatDelay || (vars.repeat = 0);
      return new Tween2(targets, vars);
    };
    Tween2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
      return _globalTimeline.killTweensOf(targets, props, onlyActive);
    };
    return Tween2;
  }(Animation);
  _setDefaults(Tween.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
  });
  _forEachName("staggerTo,staggerFrom,staggerFromTo", function(name) {
    Tween[name] = function() {
      var tl = new Timeline(), params = _slice.call(arguments, 0);
      params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
      return tl[name].apply(tl, params);
    };
  });
  var _setterPlain = function _setterPlain2(target, property, value) {
    return target[property] = value;
  };
  var _setterFunc = function _setterFunc2(target, property, value) {
    return target[property](value);
  };
  var _setterFuncWithParam = function _setterFuncWithParam2(target, property, value, data) {
    return target[property](data.fp, value);
  };
  var _setterAttribute = function _setterAttribute2(target, property, value) {
    return target.setAttribute(property, value);
  };
  var _getSetter = function _getSetter2(target, property) {
    return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
  };
  var _renderPlain = function _renderPlain2(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e6) / 1e6, data);
  };
  var _renderBoolean = function _renderBoolean2(ratio, data) {
    return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
  };
  var _renderComplexString = function _renderComplexString2(ratio, data) {
    var pt = data._pt, s = "";
    if (!ratio && data.b) {
      s = data.b;
    } else if (ratio === 1 && data.e) {
      s = data.e;
    } else {
      while (pt) {
        s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 1e4) / 1e4) + s;
        pt = pt._next;
      }
      s += data.c;
    }
    data.set(data.t, data.p, s, data);
  };
  var _renderPropTweens = function _renderPropTweens2(ratio, data) {
    var pt = data._pt;
    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }
  };
  var _addPluginModifier = function _addPluginModifier2(modifier, tween, target, property) {
    var pt = this._pt, next;
    while (pt) {
      next = pt._next;
      pt.p === property && pt.modifier(modifier, tween, target);
      pt = next;
    }
  };
  var _killPropTweensOf = function _killPropTweensOf2(property) {
    var pt = this._pt, hasNonDependentRemaining, next;
    while (pt) {
      next = pt._next;
      if (pt.p === property && !pt.op || pt.op === property) {
        _removeLinkedListItem(this, pt, "_pt");
      } else if (!pt.dep) {
        hasNonDependentRemaining = 1;
      }
      pt = next;
    }
    return !hasNonDependentRemaining;
  };
  var _setterWithModifier = function _setterWithModifier2(target, property, value, data) {
    data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
  };
  var _sortPropTweensByPriority = function _sortPropTweensByPriority2(parent) {
    var pt = parent._pt, next, pt2, first2, last2;
    while (pt) {
      next = pt._next;
      pt2 = first2;
      while (pt2 && pt2.pr > pt.pr) {
        pt2 = pt2._next;
      }
      if (pt._prev = pt2 ? pt2._prev : last2) {
        pt._prev._next = pt;
      } else {
        first2 = pt;
      }
      if (pt._next = pt2) {
        pt2._prev = pt;
      } else {
        last2 = pt;
      }
      pt = next;
    }
    parent._pt = first2;
  };
  var PropTween = /* @__PURE__ */ function() {
    function PropTween2(next, target, prop, start, change, renderer, data, setter, priority) {
      this.t = target;
      this.s = start;
      this.c = change;
      this.p = prop;
      this.r = renderer || _renderPlain;
      this.d = data || this;
      this.set = setter || _setterPlain;
      this.pr = priority || 0;
      this._next = next;
      if (next) {
        next._prev = this;
      }
    }
    var _proto4 = PropTween2.prototype;
    _proto4.modifier = function modifier(func, tween, target) {
      this.mSet = this.mSet || this.set;
      this.set = _setterWithModifier;
      this.m = func;
      this.mt = target;
      this.tween = tween;
    };
    return PropTween2;
  }();
  _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(name) {
    return _reservedProps[name] = 1;
  });
  _globals.TweenMax = _globals.TweenLite = Tween;
  _globals.TimelineLite = _globals.TimelineMax = Timeline;
  _globalTimeline = new Timeline({
    sortChildren: false,
    defaults: _defaults,
    autoRemoveChildren: true,
    id: "root",
    smoothChildTiming: true
  });
  _config.stringFilter = _colorStringFilter;
  var _media = [];
  var _listeners = {};
  var _emptyArray = [];
  var _lastMediaTime = 0;
  var _contextID = 0;
  var _dispatch = function _dispatch2(type) {
    return (_listeners[type] || _emptyArray).map(function(f) {
      return f();
    });
  };
  var _onMediaChange = function _onMediaChange2() {
    var time = Date.now(), matches = [];
    if (time - _lastMediaTime > 2) {
      _dispatch("matchMediaInit");
      _media.forEach(function(c) {
        var queries = c.queries, conditions = c.conditions, match, p, anyMatch, toggled;
        for (p in queries) {
          match = _win.matchMedia(queries[p]).matches;
          match && (anyMatch = 1);
          if (match !== conditions[p]) {
            conditions[p] = match;
            toggled = 1;
          }
        }
        if (toggled) {
          c.revert();
          anyMatch && matches.push(c);
        }
      });
      _dispatch("matchMediaRevert");
      matches.forEach(function(c) {
        return c.onMatch(c, function(func) {
          return c.add(null, func);
        });
      });
      _lastMediaTime = time;
      _dispatch("matchMedia");
    }
  };
  var Context = /* @__PURE__ */ function() {
    function Context2(func, scope) {
      this.selector = scope && selector(scope);
      this.data = [];
      this._r = [];
      this.isReverted = false;
      this.id = _contextID++;
      func && this.add(func);
    }
    var _proto5 = Context2.prototype;
    _proto5.add = function add(name, func, scope) {
      if (_isFunction(name)) {
        scope = func;
        func = name;
        name = _isFunction;
      }
      var self = this, f = function f2() {
        var prev = _context, prevSelector = self.selector, result;
        prev && prev !== self && prev.data.push(self);
        scope && (self.selector = selector(scope));
        _context = self;
        result = func.apply(self, arguments);
        _isFunction(result) && self._r.push(result);
        _context = prev;
        self.selector = prevSelector;
        self.isReverted = false;
        return result;
      };
      self.last = f;
      return name === _isFunction ? f(self, function(func2) {
        return self.add(null, func2);
      }) : name ? self[name] = f : f;
    };
    _proto5.ignore = function ignore(func) {
      var prev = _context;
      _context = null;
      func(this);
      _context = prev;
    };
    _proto5.getTweens = function getTweens() {
      var a = [];
      this.data.forEach(function(e) {
        return e instanceof Context2 ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === "nested") && a.push(e);
      });
      return a;
    };
    _proto5.clear = function clear() {
      this._r.length = this.data.length = 0;
    };
    _proto5.kill = function kill2(revert, matchMedia3) {
      var _this4 = this;
      if (revert) {
        (function() {
          var tweens = _this4.getTweens(), i2 = _this4.data.length, t;
          while (i2--) {
            t = _this4.data[i2];
            if (t.data === "isFlip") {
              t.revert();
              t.getChildren(true, true, false).forEach(function(tween) {
                return tweens.splice(tweens.indexOf(tween), 1);
              });
            }
          }
          tweens.map(function(t2) {
            return {
              g: t2._dur || t2._delay || t2._sat && !t2._sat.vars.immediateRender ? t2.globalTime(0) : -Infinity,
              t: t2
            };
          }).sort(function(a, b) {
            return b.g - a.g || -Infinity;
          }).forEach(function(o) {
            return o.t.revert(revert);
          });
          i2 = _this4.data.length;
          while (i2--) {
            t = _this4.data[i2];
            if (t instanceof Timeline) {
              if (t.data !== "nested") {
                t.scrollTrigger && t.scrollTrigger.revert();
                t.kill();
              }
            } else {
              !(t instanceof Tween) && t.revert && t.revert(revert);
            }
          }
          _this4._r.forEach(function(f) {
            return f(revert, _this4);
          });
          _this4.isReverted = true;
        })();
      } else {
        this.data.forEach(function(e) {
          return e.kill && e.kill();
        });
      }
      this.clear();
      if (matchMedia3) {
        var i = _media.length;
        while (i--) {
          _media[i].id === this.id && _media.splice(i, 1);
        }
      }
    };
    _proto5.revert = function revert(config6) {
      this.kill(config6 || {});
    };
    return Context2;
  }();
  var MatchMedia = /* @__PURE__ */ function() {
    function MatchMedia2(scope) {
      this.contexts = [];
      this.scope = scope;
      _context && _context.data.push(this);
    }
    var _proto6 = MatchMedia2.prototype;
    _proto6.add = function add(conditions, func, scope) {
      _isObject(conditions) || (conditions = {
        matches: conditions
      });
      var context4 = new Context(0, scope || this.scope), cond = context4.conditions = {}, mq, p, active;
      _context && !context4.selector && (context4.selector = _context.selector);
      this.contexts.push(context4);
      func = context4.add("onMatch", func);
      context4.queries = conditions;
      for (p in conditions) {
        if (p === "all") {
          active = 1;
        } else {
          mq = _win.matchMedia(conditions[p]);
          if (mq) {
            _media.indexOf(context4) < 0 && _media.push(context4);
            (cond[p] = mq.matches) && (active = 1);
            mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
          }
        }
      }
      active && func(context4, function(f) {
        return context4.add(null, f);
      });
      return this;
    };
    _proto6.revert = function revert(config6) {
      this.kill(config6 || {});
    };
    _proto6.kill = function kill2(revert) {
      this.contexts.forEach(function(c) {
        return c.kill(revert, true);
      });
    };
    return MatchMedia2;
  }();
  var _gsap = {
    registerPlugin: function registerPlugin() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      args.forEach(function(config6) {
        return _createPlugin(config6);
      });
    },
    timeline: function timeline(vars) {
      return new Timeline(vars);
    },
    getTweensOf: function getTweensOf(targets, onlyActive) {
      return _globalTimeline.getTweensOf(targets, onlyActive);
    },
    getProperty: function getProperty(target, property, unit, uncache) {
      _isString(target) && (target = toArray(target)[0]);
      var getter = _getCache(target || {}).get, format = unit ? _passThrough : _numericIfPossible;
      unit === "native" && (unit = "");
      return !target ? target : !property ? function(property2, unit2, uncache2) {
        return format((_plugins[property2] && _plugins[property2].get || getter)(target, property2, unit2, uncache2));
      } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
    },
    quickSetter: function quickSetter(target, property, unit) {
      target = toArray(target);
      if (target.length > 1) {
        var setters = target.map(function(t) {
          return gsap.quickSetter(t, property, unit);
        }), l = setters.length;
        return function(value) {
          var i = l;
          while (i--) {
            setters[i](value);
          }
        };
      }
      target = target[0] || {};
      var Plugin = _plugins[property], cache = _getCache(target), p = cache.harness && (cache.harness.aliases || {})[property] || property, setter = Plugin ? function(value) {
        var p2 = new Plugin();
        _quickTween._pt = 0;
        p2.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
        p2.render(1, p2);
        _quickTween._pt && _renderPropTweens(1, _quickTween);
      } : cache.set(target, p);
      return Plugin ? setter : function(value) {
        return setter(target, p, unit ? value + unit : value, cache, 1);
      };
    },
    quickTo: function quickTo(target, property, vars) {
      var _setDefaults22;
      var tween = gsap.to(target, _setDefaults((_setDefaults22 = {}, _setDefaults22[property] = "+=0.1", _setDefaults22.paused = true, _setDefaults22.stagger = 0, _setDefaults22), vars || {})), func = function func2(value, start, startIsRelative) {
        return tween.resetTo(property, value, start, startIsRelative);
      };
      func.tween = tween;
      return func;
    },
    isTweening: function isTweening(targets) {
      return _globalTimeline.getTweensOf(targets, true).length > 0;
    },
    defaults: function defaults(value) {
      value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
      return _mergeDeep(_defaults, value || {});
    },
    config: function config2(value) {
      return _mergeDeep(_config, value || {});
    },
    registerEffect: function registerEffect(_ref3) {
      var name = _ref3.name, effect = _ref3.effect, plugins = _ref3.plugins, defaults2 = _ref3.defaults, extendTimeline = _ref3.extendTimeline;
      (plugins || "").split(",").forEach(function(pluginName) {
        return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
      });
      _effects[name] = function(targets, vars, tl) {
        return effect(toArray(targets), _setDefaults(vars || {}, defaults2), tl);
      };
      if (extendTimeline) {
        Timeline.prototype[name] = function(targets, vars, position) {
          return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
        };
      }
    },
    registerEase: function registerEase(name, ease) {
      _easeMap[name] = _parseEase(ease);
    },
    parseEase: function parseEase(ease, defaultEase) {
      return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
    },
    getById: function getById(id) {
      return _globalTimeline.getById(id);
    },
    exportRoot: function exportRoot(vars, includeDelayedCalls) {
      if (vars === void 0) {
        vars = {};
      }
      var tl = new Timeline(vars), child, next;
      tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
      _globalTimeline.remove(tl);
      tl._dp = 0;
      tl._time = tl._tTime = _globalTimeline._time;
      child = _globalTimeline._first;
      while (child) {
        next = child._next;
        if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
          _addToTimeline(tl, child, child._start - child._delay);
        }
        child = next;
      }
      _addToTimeline(_globalTimeline, tl, 0);
      return tl;
    },
    context: function context(func, scope) {
      return func ? new Context(func, scope) : _context;
    },
    matchMedia: function matchMedia2(scope) {
      return new MatchMedia(scope);
    },
    matchMediaRefresh: function matchMediaRefresh() {
      return _media.forEach(function(c) {
        var cond = c.conditions, found, p;
        for (p in cond) {
          if (cond[p]) {
            cond[p] = false;
            found = 1;
          }
        }
        found && c.revert();
      }) || _onMediaChange();
    },
    addEventListener: function addEventListener(type, callback) {
      var a = _listeners[type] || (_listeners[type] = []);
      ~a.indexOf(callback) || a.push(callback);
    },
    removeEventListener: function removeEventListener(type, callback) {
      var a = _listeners[type], i = a && a.indexOf(callback);
      i >= 0 && a.splice(i, 1);
    },
    utils: {
      wrap,
      wrapYoyo,
      distribute,
      random,
      snap,
      normalize,
      getUnit,
      clamp,
      splitColor,
      toArray,
      selector,
      mapRange,
      pipe,
      unitize,
      interpolate,
      shuffle
    },
    install: _install,
    effects: _effects,
    ticker: _ticker,
    updateRoot: Timeline.updateRoot,
    plugins: _plugins,
    globalTimeline: _globalTimeline,
    core: {
      PropTween,
      globals: _addGlobal,
      Tween,
      Timeline,
      Animation,
      getCache: _getCache,
      _removeLinkedListItem,
      reverting: function reverting() {
        return _reverting;
      },
      context: function context2(toAdd) {
        if (toAdd && _context) {
          _context.data.push(toAdd);
          toAdd._ctx = _context;
        }
        return _context;
      },
      suppressOverwrites: function suppressOverwrites(value) {
        return _suppressOverwrites = value;
      }
    }
  };
  _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function(name) {
    return _gsap[name] = Tween[name];
  });
  _ticker.add(Timeline.updateRoot);
  _quickTween = _gsap.to({}, {
    duration: 0
  });
  var _getPluginPropTween = function _getPluginPropTween2(plugin, prop) {
    var pt = plugin._pt;
    while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
      pt = pt._next;
    }
    return pt;
  };
  var _addModifiers = function _addModifiers2(tween, modifiers) {
    var targets = tween._targets, p, i, pt;
    for (p in modifiers) {
      i = targets.length;
      while (i--) {
        pt = tween._ptLookup[i][p];
        if (pt && (pt = pt.d)) {
          if (pt._pt) {
            pt = _getPluginPropTween(pt, p);
          }
          pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
        }
      }
    }
  };
  var _buildModifierPlugin = function _buildModifierPlugin2(name, modifier) {
    return {
      name,
      rawVars: 1,
      //don't pre-process function-based values or "random()" strings.
      init: function init5(target, vars, tween) {
        tween._onInit = function(tween2) {
          var temp, p;
          if (_isString(vars)) {
            temp = {};
            _forEachName(vars, function(name2) {
              return temp[name2] = 1;
            });
            vars = temp;
          }
          if (modifier) {
            temp = {};
            for (p in vars) {
              temp[p] = modifier(vars[p]);
            }
            vars = temp;
          }
          _addModifiers(tween2, vars);
        };
      }
    };
  };
  var gsap = _gsap.registerPlugin({
    name: "attr",
    init: function init(target, vars, tween, index, targets) {
      var p, pt, v;
      this.tween = tween;
      for (p in vars) {
        v = target.getAttribute(p) || "";
        pt = this.add(target, "setAttribute", (v || 0) + "", vars[p], index, targets, 0, 0, p);
        pt.op = p;
        pt.b = v;
        this._props.push(p);
      }
    },
    render: function render(ratio, data) {
      var pt = data._pt;
      while (pt) {
        _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d);
        pt = pt._next;
      }
    }
  }, {
    name: "endArray",
    init: function init2(target, value) {
      var i = value.length;
      while (i--) {
        this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1);
      }
    }
  }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
  Tween.version = Timeline.version = gsap.version = "3.12.7";
  _coreReady = 1;
  _windowExists() && _wake();
  var Power0 = _easeMap.Power0;
  var Power1 = _easeMap.Power1;
  var Power2 = _easeMap.Power2;
  var Power3 = _easeMap.Power3;
  var Power4 = _easeMap.Power4;
  var Linear = _easeMap.Linear;
  var Quad = _easeMap.Quad;
  var Cubic = _easeMap.Cubic;
  var Quart = _easeMap.Quart;
  var Quint = _easeMap.Quint;
  var Strong = _easeMap.Strong;
  var Elastic = _easeMap.Elastic;
  var Back = _easeMap.Back;
  var SteppedEase = _easeMap.SteppedEase;
  var Bounce = _easeMap.Bounce;
  var Sine = _easeMap.Sine;
  var Expo = _easeMap.Expo;
  var Circ = _easeMap.Circ;

  // node_modules/gsap/CSSPlugin.js
  var _win2;
  var _doc2;
  var _docElement;
  var _pluginInitted;
  var _tempDiv;
  var _tempDivStyler;
  var _recentSetterPlugin;
  var _reverting2;
  var _windowExists3 = function _windowExists4() {
    return typeof window !== "undefined";
  };
  var _transformProps = {};
  var _RAD2DEG = 180 / Math.PI;
  var _DEG2RAD = Math.PI / 180;
  var _atan2 = Math.atan2;
  var _bigNum2 = 1e8;
  var _capsExp = /([A-Z])/g;
  var _horizontalExp = /(left|right|width|margin|padding|x)/i;
  var _complexExp = /[\s,\(]\S/;
  var _propertyAliases = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
  };
  var _renderCSSProp = function _renderCSSProp2(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
  };
  var _renderPropWithEnd = function _renderPropWithEnd2(ratio, data) {
    return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
  };
  var _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning2(ratio, data) {
    return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u : data.b, data);
  };
  var _renderRoundedCSSProp = function _renderRoundedCSSProp2(ratio, data) {
    var value = data.s + data.c * ratio;
    data.set(data.t, data.p, ~~(value + (value < 0 ? -0.5 : 0.5)) + data.u, data);
  };
  var _renderNonTweeningValue = function _renderNonTweeningValue2(ratio, data) {
    return data.set(data.t, data.p, ratio ? data.e : data.b, data);
  };
  var _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd2(ratio, data) {
    return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
  };
  var _setterCSSStyle = function _setterCSSStyle2(target, property, value) {
    return target.style[property] = value;
  };
  var _setterCSSProp = function _setterCSSProp2(target, property, value) {
    return target.style.setProperty(property, value);
  };
  var _setterTransform = function _setterTransform2(target, property, value) {
    return target._gsap[property] = value;
  };
  var _setterScale = function _setterScale2(target, property, value) {
    return target._gsap.scaleX = target._gsap.scaleY = value;
  };
  var _setterScaleWithRender = function _setterScaleWithRender2(target, property, value, data, ratio) {
    var cache = target._gsap;
    cache.scaleX = cache.scaleY = value;
    cache.renderTransform(ratio, cache);
  };
  var _setterTransformWithRender = function _setterTransformWithRender2(target, property, value, data, ratio) {
    var cache = target._gsap;
    cache[property] = value;
    cache.renderTransform(ratio, cache);
  };
  var _transformProp = "transform";
  var _transformOriginProp = _transformProp + "Origin";
  var _saveStyle = function _saveStyle2(property, isNotCSS) {
    var _this = this;
    var target = this.target, style = target.style, cache = target._gsap;
    if (property in _transformProps && style) {
      this.tfm = this.tfm || {};
      if (property !== "transform") {
        property = _propertyAliases[property] || property;
        ~property.indexOf(",") ? property.split(",").forEach(function(a) {
          return _this.tfm[a] = _get(target, a);
        }) : this.tfm[property] = cache.x ? cache[property] : _get(target, property);
        property === _transformOriginProp && (this.tfm.zOrigin = cache.zOrigin);
      } else {
        return _propertyAliases.transform.split(",").forEach(function(p) {
          return _saveStyle2.call(_this, p, isNotCSS);
        });
      }
      if (this.props.indexOf(_transformProp) >= 0) {
        return;
      }
      if (cache.svg) {
        this.svgo = target.getAttribute("data-svg-origin");
        this.props.push(_transformOriginProp, isNotCSS, "");
      }
      property = _transformProp;
    }
    (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);
  };
  var _removeIndependentTransforms = function _removeIndependentTransforms2(style) {
    if (style.translate) {
      style.removeProperty("translate");
      style.removeProperty("scale");
      style.removeProperty("rotate");
    }
  };
  var _revertStyle = function _revertStyle2() {
    var props = this.props, target = this.target, style = target.style, cache = target._gsap, i, p;
    for (i = 0; i < props.length; i += 3) {
      if (!props[i + 1]) {
        props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty(props[i].substr(0, 2) === "--" ? props[i] : props[i].replace(_capsExp, "-$1").toLowerCase());
      } else if (props[i + 1] === 2) {
        target[props[i]](props[i + 2]);
      } else {
        target[props[i]] = props[i + 2];
      }
    }
    if (this.tfm) {
      for (p in this.tfm) {
        cache[p] = this.tfm[p];
      }
      if (cache.svg) {
        cache.renderTransform();
        target.setAttribute("data-svg-origin", this.svgo || "");
      }
      i = _reverting2();
      if ((!i || !i.isStart) && !style[_transformProp]) {
        _removeIndependentTransforms(style);
        if (cache.zOrigin && style[_transformOriginProp]) {
          style[_transformOriginProp] += " " + cache.zOrigin + "px";
          cache.zOrigin = 0;
          cache.renderTransform();
        }
        cache.uncache = 1;
      }
    }
  };
  var _getStyleSaver = function _getStyleSaver2(target, properties) {
    var saver = {
      target,
      props: [],
      revert: _revertStyle,
      save: _saveStyle
    };
    target._gsap || gsap.core.getCache(target);
    properties && target.style && target.nodeType && properties.split(",").forEach(function(p) {
      return saver.save(p);
    });
    return saver;
  };
  var _supports3D;
  var _createElement = function _createElement2(type, ns) {
    var e = _doc2.createElementNS ? _doc2.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc2.createElement(type);
    return e && e.style ? e : _doc2.createElement(type);
  };
  var _getComputedProperty = function _getComputedProperty2(target, property, skipPrefixFallback) {
    var cs = getComputedStyle(target);
    return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty2(target, _checkPropPrefix(property) || property, 1) || "";
  };
  var _prefixes = "O,Moz,ms,Ms,Webkit".split(",");
  var _checkPropPrefix = function _checkPropPrefix2(property, element, preferPrefix) {
    var e = element || _tempDiv, s = e.style, i = 5;
    if (property in s && !preferPrefix) {
      return property;
    }
    property = property.charAt(0).toUpperCase() + property.substr(1);
    while (i-- && !(_prefixes[i] + property in s)) {
    }
    return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
  };
  var _initCore = function _initCore2() {
    if (_windowExists3() && window.document) {
      _win2 = window;
      _doc2 = _win2.document;
      _docElement = _doc2.documentElement;
      _tempDiv = _createElement("div") || {
        style: {}
      };
      _tempDivStyler = _createElement("div");
      _transformProp = _checkPropPrefix(_transformProp);
      _transformOriginProp = _transformProp + "Origin";
      _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0";
      _supports3D = !!_checkPropPrefix("perspective");
      _reverting2 = gsap.core.reverting;
      _pluginInitted = 1;
    }
  };
  var _getReparentedCloneBBox = function _getReparentedCloneBBox2(target) {
    var owner = target.ownerSVGElement, svg = _createElement("svg", owner && owner.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), clone = target.cloneNode(true), bbox;
    clone.style.display = "block";
    svg.appendChild(clone);
    _docElement.appendChild(svg);
    try {
      bbox = clone.getBBox();
    } catch (e) {
    }
    svg.removeChild(clone);
    _docElement.removeChild(svg);
    return bbox;
  };
  var _getAttributeFallbacks = function _getAttributeFallbacks2(target, attributesArray) {
    var i = attributesArray.length;
    while (i--) {
      if (target.hasAttribute(attributesArray[i])) {
        return target.getAttribute(attributesArray[i]);
      }
    }
  };
  var _getBBox = function _getBBox2(target) {
    var bounds, cloned;
    try {
      bounds = target.getBBox();
    } catch (error) {
      bounds = _getReparentedCloneBBox(target);
      cloned = 1;
    }
    bounds && (bounds.width || bounds.height) || cloned || (bounds = _getReparentedCloneBBox(target));
    return bounds && !bounds.width && !bounds.x && !bounds.y ? {
      x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
      y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
      width: 0,
      height: 0
    } : bounds;
  };
  var _isSVG = function _isSVG2(e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
  };
  var _removeProperty = function _removeProperty2(target, property) {
    if (property) {
      var style = target.style, first2Chars;
      if (property in _transformProps && property !== _transformOriginProp) {
        property = _transformProp;
      }
      if (style.removeProperty) {
        first2Chars = property.substr(0, 2);
        if (first2Chars === "ms" || property.substr(0, 6) === "webkit") {
          property = "-" + property;
        }
        style.removeProperty(first2Chars === "--" ? property : property.replace(_capsExp, "-$1").toLowerCase());
      } else {
        style.removeAttribute(property);
      }
    }
  };
  var _addNonTweeningPT = function _addNonTweeningPT2(plugin, target, property, beginning, end, onlySetAtEnd) {
    var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
    plugin._pt = pt;
    pt.b = beginning;
    pt.e = end;
    plugin._props.push(property);
    return pt;
  };
  var _nonConvertibleUnits = {
    deg: 1,
    rad: 1,
    turn: 1
  };
  var _nonStandardLayouts = {
    grid: 1,
    flex: 1
  };
  var _convertToUnit = function _convertToUnit2(target, property, value, unit) {
    var curValue = parseFloat(value) || 0, curUnit = (value + "").trim().substr((curValue + "").length) || "px", style = _tempDiv.style, horizontal = _horizontalExp.test(property), isRootSVG = target.tagName.toLowerCase() === "svg", measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"), amount = 100, toPixels = unit === "px", toPercent = unit === "%", px, parent, cache, isSVG;
    if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
      return curValue;
    }
    curUnit !== "px" && !toPixels && (curValue = _convertToUnit2(target, property, value, "px"));
    isSVG = target.getCTM && _isSVG(target);
    if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
      px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
      return _round(toPercent ? curValue / px * amount : curValue / 100 * px);
    }
    style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
    parent = unit !== "rem" && ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;
    if (isSVG) {
      parent = (target.ownerSVGElement || {}).parentNode;
    }
    if (!parent || parent === _doc2 || !parent.appendChild) {
      parent = _doc2.body;
    }
    cache = parent._gsap;
    if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time && !cache.uncache) {
      return _round(curValue / cache.width * amount);
    } else {
      if (toPercent && (property === "height" || property === "width")) {
        var v = target.style[property];
        target.style[property] = amount + unit;
        px = target[measureProperty];
        v ? target.style[property] = v : _removeProperty(target, property);
      } else {
        (toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent, "display")] && (style.position = _getComputedProperty(target, "position"));
        parent === target && (style.position = "static");
        parent.appendChild(_tempDiv);
        px = _tempDiv[measureProperty];
        parent.removeChild(_tempDiv);
        style.position = "absolute";
      }
      if (horizontal && toPercent) {
        cache = _getCache(parent);
        cache.time = _ticker.time;
        cache.width = parent[measureProperty];
      }
    }
    return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
  };
  var _get = function _get2(target, property, unit, uncache) {
    var value;
    _pluginInitted || _initCore();
    if (property in _propertyAliases && property !== "transform") {
      property = _propertyAliases[property];
      if (~property.indexOf(",")) {
        property = property.split(",")[0];
      }
    }
    if (_transformProps[property] && property !== "transform") {
      value = _parseTransform(target, uncache);
      value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
    } else {
      value = target.style[property];
      if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
        value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0);
      }
    }
    return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
  };
  var _tweenComplexCSSString = function _tweenComplexCSSString2(target, prop, start, end) {
    if (!start || start === "none") {
      var p = _checkPropPrefix(prop, target, 1), s = p && _getComputedProperty(target, p, 1);
      if (s && s !== start) {
        prop = p;
        start = s;
      } else if (prop === "borderColor") {
        start = _getComputedProperty(target, "borderTopColor");
      }
    }
    var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString), index = 0, matchIndex = 0, a, result, startValues, startNum, color, startValue, endValue, endNum, chunk, endUnit, startUnit, endValues;
    pt.b = start;
    pt.e = end;
    start += "";
    end += "";
    if (end === "auto") {
      startValue = target.style[prop];
      target.style[prop] = end;
      end = _getComputedProperty(target, prop) || end;
      startValue ? target.style[prop] = startValue : _removeProperty(target, prop);
    }
    a = [start, end];
    _colorStringFilter(a);
    start = a[0];
    end = a[1];
    startValues = start.match(_numWithUnitExp) || [];
    endValues = end.match(_numWithUnitExp) || [];
    if (endValues.length) {
      while (result = _numWithUnitExp.exec(end)) {
        endValue = result[0];
        chunk = end.substring(index, result.index);
        if (color) {
          color = (color + 1) % 5;
        } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
          color = 1;
        }
        if (endValue !== (startValue = startValues[matchIndex++] || "")) {
          startNum = parseFloat(startValue) || 0;
          startUnit = startValue.substr((startNum + "").length);
          endValue.charAt(1) === "=" && (endValue = _parseRelative(startNum, endValue) + startUnit);
          endNum = parseFloat(endValue);
          endUnit = endValue.substr((endNum + "").length);
          index = _numWithUnitExp.lastIndex - endUnit.length;
          if (!endUnit) {
            endUnit = endUnit || _config.units[prop] || startUnit;
            if (index === end.length) {
              end += endUnit;
              pt.e += endUnit;
            }
          }
          if (startUnit !== endUnit) {
            startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
          }
          pt._pt = {
            _next: pt._pt,
            p: chunk || matchIndex === 1 ? chunk : ",",
            //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
            s: startNum,
            c: endNum - startNum,
            m: color && color < 4 || prop === "zIndex" ? Math.round : 0
          };
        }
      }
      pt.c = index < end.length ? end.substring(index, end.length) : "";
    } else {
      pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
    }
    _relExp.test(end) && (pt.e = 0);
    this._pt = pt;
    return pt;
  };
  var _keywordToPercent = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
  };
  var _convertKeywordsToPercentages = function _convertKeywordsToPercentages2(value) {
    var split2 = value.split(" "), x = split2[0], y = split2[1] || "50%";
    if (x === "top" || x === "bottom" || y === "left" || y === "right") {
      value = x;
      x = y;
      y = value;
    }
    split2[0] = _keywordToPercent[x] || x;
    split2[1] = _keywordToPercent[y] || y;
    return split2.join(" ");
  };
  var _renderClearProps = function _renderClearProps2(ratio, data) {
    if (data.tween && data.tween._time === data.tween._dur) {
      var target = data.t, style = target.style, props = data.u, cache = target._gsap, prop, clearTransforms, i;
      if (props === "all" || props === true) {
        style.cssText = "";
        clearTransforms = 1;
      } else {
        props = props.split(",");
        i = props.length;
        while (--i > -1) {
          prop = props[i];
          if (_transformProps[prop]) {
            clearTransforms = 1;
            prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
          }
          _removeProperty(target, prop);
        }
      }
      if (clearTransforms) {
        _removeProperty(target, _transformProp);
        if (cache) {
          cache.svg && target.removeAttribute("transform");
          style.scale = style.rotate = style.translate = "none";
          _parseTransform(target, 1);
          cache.uncache = 1;
          _removeIndependentTransforms(style);
        }
      }
    }
  };
  var _specialProps = {
    clearProps: function clearProps(plugin, target, property, endValue, tween) {
      if (tween.data !== "isFromStart") {
        var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
        pt.u = endValue;
        pt.pr = -10;
        pt.tween = tween;
        plugin._props.push(property);
        return 1;
      }
    }
    /* className feature (about 0.4kb gzipped).
    , className(plugin, target, property, endValue, tween) {
    	let _renderClassName = (ratio, data) => {
    			data.css.render(ratio, data.css);
    			if (!ratio || ratio === 1) {
    				let inline = data.rmv,
    					target = data.t,
    					p;
    				target.setAttribute("class", ratio ? data.e : data.b);
    				for (p in inline) {
    					_removeProperty(target, p);
    				}
    			}
    		},
    		_getAllStyles = (target) => {
    			let styles = {},
    				computed = getComputedStyle(target),
    				p;
    			for (p in computed) {
    				if (isNaN(p) && p !== "cssText" && p !== "length") {
    					styles[p] = computed[p];
    				}
    			}
    			_setDefaults(styles, _parseTransform(target, 1));
    			return styles;
    		},
    		startClassList = target.getAttribute("class"),
    		style = target.style,
    		cssText = style.cssText,
    		cache = target._gsap,
    		classPT = cache.classPT,
    		inlineToRemoveAtEnd = {},
    		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
    		changingVars = {},
    		startVars = _getAllStyles(target),
    		transformRelated = /(transform|perspective)/i,
    		endVars, p;
    	if (classPT) {
    		classPT.r(1, classPT.d);
    		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
    	}
    	target.setAttribute("class", data.e);
    	endVars = _getAllStyles(target, true);
    	target.setAttribute("class", startClassList);
    	for (p in endVars) {
    		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
    			changingVars[p] = endVars[p];
    			if (!style[p] && style[p] !== "0") {
    				inlineToRemoveAtEnd[p] = 1;
    			}
    		}
    	}
    	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
    	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
    		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
    	}
    	_parseTransform(target, true); //to clear the caching of transforms
    	data.css = new gsap.plugins.css();
    	data.css.init(target, changingVars, tween);
    	plugin._props.push(...data.css._props);
    	return 1;
    }
    */
  };
  var _identity2DMatrix = [1, 0, 0, 1, 0, 0];
  var _rotationalProperties = {};
  var _isNullTransform = function _isNullTransform2(value) {
    return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
  };
  var _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray2(target) {
    var matrixString = _getComputedProperty(target, _transformProp);
    return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);
  };
  var _getMatrix = function _getMatrix2(target, force2D) {
    var cache = target._gsap || _getCache(target), style = target.style, matrix = _getComputedTransformMatrixAsArray(target), parent, nextSibling, temp, addedToDOM;
    if (cache.svg && target.getAttribute("transform")) {
      temp = target.transform.baseVal.consolidate().matrix;
      matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
      return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
    } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
      temp = style.display;
      style.display = "block";
      parent = target.parentNode;
      if (!parent || !target.offsetParent && !target.getBoundingClientRect().width) {
        addedToDOM = 1;
        nextSibling = target.nextElementSibling;
        _docElement.appendChild(target);
      }
      matrix = _getComputedTransformMatrixAsArray(target);
      temp ? style.display = temp : _removeProperty(target, "display");
      if (addedToDOM) {
        nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
      }
    }
    return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
  };
  var _applySVGOrigin = function _applySVGOrigin2(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
    var cache = target._gsap, matrix = matrixArray || _getMatrix(target, true), xOriginOld = cache.xOrigin || 0, yOriginOld = cache.yOrigin || 0, xOffsetOld = cache.xOffset || 0, yOffsetOld = cache.yOffset || 0, a = matrix[0], b = matrix[1], c = matrix[2], d = matrix[3], tx = matrix[4], ty = matrix[5], originSplit = origin.split(" "), xOrigin = parseFloat(originSplit[0]) || 0, yOrigin = parseFloat(originSplit[1]) || 0, bounds, determinant, x, y;
    if (!originIsAbsolute) {
      bounds = _getBBox(target);
      xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
      yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
    } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
      x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
      y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
      xOrigin = x;
      yOrigin = y;
    }
    if (smooth || smooth !== false && cache.smooth) {
      tx = xOrigin - xOriginOld;
      ty = yOrigin - yOriginOld;
      cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
      cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
    } else {
      cache.xOffset = cache.yOffset = 0;
    }
    cache.xOrigin = xOrigin;
    cache.yOrigin = yOrigin;
    cache.smooth = !!smooth;
    cache.origin = origin;
    cache.originIsAbsolute = !!originIsAbsolute;
    target.style[_transformOriginProp] = "0px 0px";
    if (pluginToAddPropTweensTo) {
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
    }
    target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
  };
  var _parseTransform = function _parseTransform2(target, uncache) {
    var cache = target._gsap || new GSCache(target);
    if ("x" in cache && !uncache && !cache.uncache) {
      return cache;
    }
    var style = target.style, invertedScaleX = cache.scaleX < 0, px = "px", deg = "deg", cs = getComputedStyle(target), origin = _getComputedProperty(target, _transformOriginProp) || "0", x, y, z, scaleX, scaleY, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix, angle, cos, sin, a, b, c, d, a12, a22, t1, t2, t3, a13, a23, a33, a42, a43, a32;
    x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
    scaleX = scaleY = 1;
    cache.svg = !!(target.getCTM && _isSVG(target));
    if (cs.translate) {
      if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") {
        style[_transformProp] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + (cs[_transformProp] !== "none" ? cs[_transformProp] : "");
      }
      style.scale = style.rotate = style.translate = "none";
    }
    matrix = _getMatrix(target, cache.svg);
    if (cache.svg) {
      if (cache.uncache) {
        t2 = target.getBBox();
        origin = cache.xOrigin - t2.x + "px " + (cache.yOrigin - t2.y) + "px";
        t1 = "";
      } else {
        t1 = !uncache && target.getAttribute("data-svg-origin");
      }
      _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
    }
    xOrigin = cache.xOrigin || 0;
    yOrigin = cache.yOrigin || 0;
    if (matrix !== _identity2DMatrix) {
      a = matrix[0];
      b = matrix[1];
      c = matrix[2];
      d = matrix[3];
      x = a12 = matrix[4];
      y = a22 = matrix[5];
      if (matrix.length === 6) {
        scaleX = Math.sqrt(a * a + b * b);
        scaleY = Math.sqrt(d * d + c * c);
        rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0;
        skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
        skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));
        if (cache.svg) {
          x -= xOrigin - (xOrigin * a + yOrigin * c);
          y -= yOrigin - (xOrigin * b + yOrigin * d);
        }
      } else {
        a32 = matrix[6];
        a42 = matrix[7];
        a13 = matrix[8];
        a23 = matrix[9];
        a33 = matrix[10];
        a43 = matrix[11];
        x = matrix[12];
        y = matrix[13];
        z = matrix[14];
        angle = _atan2(a32, a33);
        rotationX = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a12 * cos + a13 * sin;
          t2 = a22 * cos + a23 * sin;
          t3 = a32 * cos + a33 * sin;
          a13 = a12 * -sin + a13 * cos;
          a23 = a22 * -sin + a23 * cos;
          a33 = a32 * -sin + a33 * cos;
          a43 = a42 * -sin + a43 * cos;
          a12 = t1;
          a22 = t2;
          a32 = t3;
        }
        angle = _atan2(-c, a33);
        rotationY = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a * cos - a13 * sin;
          t2 = b * cos - a23 * sin;
          t3 = c * cos - a33 * sin;
          a43 = d * sin + a43 * cos;
          a = t1;
          b = t2;
          c = t3;
        }
        angle = _atan2(b, a);
        rotation = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(angle);
          sin = Math.sin(angle);
          t1 = a * cos + b * sin;
          t2 = a12 * cos + a22 * sin;
          b = b * cos - a * sin;
          a22 = a22 * cos - a12 * sin;
          a = t1;
          a12 = t2;
        }
        if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
          rotationX = rotation = 0;
          rotationY = 180 - rotationY;
        }
        scaleX = _round(Math.sqrt(a * a + b * b + c * c));
        scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));
        angle = _atan2(a12, a22);
        skewX = Math.abs(angle) > 2e-4 ? angle * _RAD2DEG : 0;
        perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
      }
      if (cache.svg) {
        t1 = target.getAttribute("transform");
        cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
        t1 && target.setAttribute("transform", t1);
      }
    }
    if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
      if (invertedScaleX) {
        scaleX *= -1;
        skewX += rotation <= 0 ? 180 : -180;
        rotation += rotation <= 0 ? 180 : -180;
      } else {
        scaleY *= -1;
        skewX += skewX <= 0 ? 180 : -180;
      }
    }
    uncache = uncache || cache.uncache;
    cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
    cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
    cache.z = z + px;
    cache.scaleX = _round(scaleX);
    cache.scaleY = _round(scaleY);
    cache.rotation = _round(rotation) + deg;
    cache.rotationX = _round(rotationX) + deg;
    cache.rotationY = _round(rotationY) + deg;
    cache.skewX = skewX + deg;
    cache.skewY = skewY + deg;
    cache.transformPerspective = perspective + px;
    if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || !uncache && cache.zOrigin || 0) {
      style[_transformOriginProp] = _firstTwoOnly(origin);
    }
    cache.xOffset = cache.yOffset = 0;
    cache.force3D = _config.force3D;
    cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
    cache.uncache = 0;
    return cache;
  };
  var _firstTwoOnly = function _firstTwoOnly2(value) {
    return (value = value.split(" "))[0] + " " + value[1];
  };
  var _addPxTranslate = function _addPxTranslate2(target, start, value) {
    var unit = getUnit(start);
    return _round(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
  };
  var _renderNon3DTransforms = function _renderNon3DTransforms2(ratio, cache) {
    cache.z = "0px";
    cache.rotationY = cache.rotationX = "0deg";
    cache.force3D = 0;
    _renderCSSTransforms(ratio, cache);
  };
  var _zeroDeg = "0deg";
  var _zeroPx = "0px";
  var _endParenthesis = ") ";
  var _renderCSSTransforms = function _renderCSSTransforms2(ratio, cache) {
    var _ref = cache || this, xPercent = _ref.xPercent, yPercent = _ref.yPercent, x = _ref.x, y = _ref.y, z = _ref.z, rotation = _ref.rotation, rotationY = _ref.rotationY, rotationX = _ref.rotationX, skewX = _ref.skewX, skewY = _ref.skewY, scaleX = _ref.scaleX, scaleY = _ref.scaleY, transformPerspective = _ref.transformPerspective, force3D = _ref.force3D, target = _ref.target, zOrigin = _ref.zOrigin, transforms = "", use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true;
    if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
      var angle = parseFloat(rotationY) * _DEG2RAD, a13 = Math.sin(angle), a33 = Math.cos(angle), cos;
      angle = parseFloat(rotationX) * _DEG2RAD;
      cos = Math.cos(angle);
      x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
      y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
      z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
    }
    if (transformPerspective !== _zeroPx) {
      transforms += "perspective(" + transformPerspective + _endParenthesis;
    }
    if (xPercent || yPercent) {
      transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
    }
    if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
      transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
    }
    if (rotation !== _zeroDeg) {
      transforms += "rotate(" + rotation + _endParenthesis;
    }
    if (rotationY !== _zeroDeg) {
      transforms += "rotateY(" + rotationY + _endParenthesis;
    }
    if (rotationX !== _zeroDeg) {
      transforms += "rotateX(" + rotationX + _endParenthesis;
    }
    if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
      transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
    }
    if (scaleX !== 1 || scaleY !== 1) {
      transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
    }
    target.style[_transformProp] = transforms || "translate(0, 0)";
  };
  var _renderSVGTransforms = function _renderSVGTransforms2(ratio, cache) {
    var _ref2 = cache || this, xPercent = _ref2.xPercent, yPercent = _ref2.yPercent, x = _ref2.x, y = _ref2.y, rotation = _ref2.rotation, skewX = _ref2.skewX, skewY = _ref2.skewY, scaleX = _ref2.scaleX, scaleY = _ref2.scaleY, target = _ref2.target, xOrigin = _ref2.xOrigin, yOrigin = _ref2.yOrigin, xOffset = _ref2.xOffset, yOffset = _ref2.yOffset, forceCSS = _ref2.forceCSS, tx = parseFloat(x), ty = parseFloat(y), a11, a21, a12, a22, temp;
    rotation = parseFloat(rotation);
    skewX = parseFloat(skewX);
    skewY = parseFloat(skewY);
    if (skewY) {
      skewY = parseFloat(skewY);
      skewX += skewY;
      rotation += skewY;
    }
    if (rotation || skewX) {
      rotation *= _DEG2RAD;
      skewX *= _DEG2RAD;
      a11 = Math.cos(rotation) * scaleX;
      a21 = Math.sin(rotation) * scaleX;
      a12 = Math.sin(rotation - skewX) * -scaleY;
      a22 = Math.cos(rotation - skewX) * scaleY;
      if (skewX) {
        skewY *= _DEG2RAD;
        temp = Math.tan(skewX - skewY);
        temp = Math.sqrt(1 + temp * temp);
        a12 *= temp;
        a22 *= temp;
        if (skewY) {
          temp = Math.tan(skewY);
          temp = Math.sqrt(1 + temp * temp);
          a11 *= temp;
          a21 *= temp;
        }
      }
      a11 = _round(a11);
      a21 = _round(a21);
      a12 = _round(a12);
      a22 = _round(a22);
    } else {
      a11 = scaleX;
      a22 = scaleY;
      a21 = a12 = 0;
    }
    if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
      tx = _convertToUnit(target, "x", x, "px");
      ty = _convertToUnit(target, "y", y, "px");
    }
    if (xOrigin || yOrigin || xOffset || yOffset) {
      tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
      ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
    }
    if (xPercent || yPercent) {
      temp = target.getBBox();
      tx = _round(tx + xPercent / 100 * temp.width);
      ty = _round(ty + yPercent / 100 * temp.height);
    }
    temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
    target.setAttribute("transform", temp);
    forceCSS && (target.style[_transformProp] = temp);
  };
  var _addRotationalPropTween = function _addRotationalPropTween2(plugin, target, property, startNum, endValue) {
    var cap = 360, isString = _isString(endValue), endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1), change = endNum - startNum, finalValue = startNum + change + "deg", direction, pt;
    if (isString) {
      direction = endValue.split("_")[1];
      if (direction === "short") {
        change %= cap;
        if (change !== change % (cap / 2)) {
          change += change < 0 ? cap : -cap;
        }
      }
      if (direction === "cw" && change < 0) {
        change = (change + cap * _bigNum2) % cap - ~~(change / cap) * cap;
      } else if (direction === "ccw" && change > 0) {
        change = (change - cap * _bigNum2) % cap - ~~(change / cap) * cap;
      }
    }
    plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
    pt.e = finalValue;
    pt.u = "deg";
    plugin._props.push(property);
    return pt;
  };
  var _assign = function _assign2(target, source) {
    for (var p in source) {
      target[p] = source[p];
    }
    return target;
  };
  var _addRawTransformPTs = function _addRawTransformPTs2(plugin, transforms, target) {
    var startCache = _assign({}, target._gsap), exclude = "perspective,force3D,transformOrigin,svgOrigin", style = target.style, endCache, p, startValue, endValue, startNum, endNum, startUnit, endUnit;
    if (startCache.svg) {
      startValue = target.getAttribute("transform");
      target.setAttribute("transform", "");
      style[_transformProp] = transforms;
      endCache = _parseTransform(target, 1);
      _removeProperty(target, _transformProp);
      target.setAttribute("transform", startValue);
    } else {
      startValue = getComputedStyle(target)[_transformProp];
      style[_transformProp] = transforms;
      endCache = _parseTransform(target, 1);
      style[_transformProp] = startValue;
    }
    for (p in _transformProps) {
      startValue = startCache[p];
      endValue = endCache[p];
      if (startValue !== endValue && exclude.indexOf(p) < 0) {
        startUnit = getUnit(startValue);
        endUnit = getUnit(endValue);
        startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
        endNum = parseFloat(endValue);
        plugin._pt = new PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
        plugin._pt.u = endUnit || 0;
        plugin._props.push(p);
      }
    }
    _assign(endCache, startCache);
  };
  _forEachName("padding,margin,Width,Radius", function(name, index) {
    var t = "Top", r = "Right", b = "Bottom", l = "Left", props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function(side) {
      return index < 2 ? name + side : "border" + side + name;
    });
    _specialProps[index > 1 ? "border" + name : name] = function(plugin, target, property, endValue, tween) {
      var a, vars;
      if (arguments.length < 4) {
        a = props.map(function(prop) {
          return _get(plugin, prop, property);
        });
        vars = a.join(" ");
        return vars.split(a[0]).length === 5 ? a[0] : vars;
      }
      a = (endValue + "").split(" ");
      vars = {};
      props.forEach(function(prop, i) {
        return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
      });
      plugin.init(target, vars, tween);
    };
  });
  var CSSPlugin = {
    name: "css",
    register: _initCore,
    targetTest: function targetTest(target) {
      return target.style && target.nodeType;
    },
    init: function init3(target, vars, tween, index, targets) {
      var props = this._props, style = target.style, startAt = tween.vars.startAt, startValue, endValue, endNum, startNum, type, specialProp, p, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth, hasPriority, inlineProps;
      _pluginInitted || _initCore();
      this.styles = this.styles || _getStyleSaver(target);
      inlineProps = this.styles.props;
      this.tween = tween;
      for (p in vars) {
        if (p === "autoRound") {
          continue;
        }
        endValue = vars[p];
        if (_plugins[p] && _checkPlugin(p, vars, tween, index, target, targets)) {
          continue;
        }
        type = typeof endValue;
        specialProp = _specialProps[p];
        if (type === "function") {
          endValue = endValue.call(tween, index, target, targets);
          type = typeof endValue;
        }
        if (type === "string" && ~endValue.indexOf("random(")) {
          endValue = _replaceRandom(endValue);
        }
        if (specialProp) {
          specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
        } else if (p.substr(0, 2) === "--") {
          startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
          endValue += "";
          _colorExp.lastIndex = 0;
          if (!_colorExp.test(startValue)) {
            startUnit = getUnit(startValue);
            endUnit = getUnit(endValue);
          }
          endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
          this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
          props.push(p);
          inlineProps.push(p, 0, style[p]);
        } else if (type !== "undefined") {
          if (startAt && p in startAt) {
            startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
            _isString(startValue) && ~startValue.indexOf("random(") && (startValue = _replaceRandom(startValue));
            getUnit(startValue + "") || startValue === "auto" || (startValue += _config.units[p] || getUnit(_get(target, p)) || "");
            (startValue + "").charAt(1) === "=" && (startValue = _get(target, p));
          } else {
            startValue = _get(target, p);
          }
          startNum = parseFloat(startValue);
          relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
          relative && (endValue = endValue.substr(2));
          endNum = parseFloat(endValue);
          if (p in _propertyAliases) {
            if (p === "autoAlpha") {
              if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
                startNum = 0;
              }
              inlineProps.push("visibility", 0, style.visibility);
              _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
            }
            if (p !== "scale" && p !== "transform") {
              p = _propertyAliases[p];
              ~p.indexOf(",") && (p = p.split(",")[0]);
            }
          }
          isTransformRelated = p in _transformProps;
          if (isTransformRelated) {
            this.styles.save(p);
            if (!transformPropTween) {
              cache = target._gsap;
              cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform);
              smooth = vars.smoothOrigin !== false && cache.smooth;
              transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1);
              transformPropTween.dep = 1;
            }
            if (p === "scale") {
              this._pt = new PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? _parseRelative(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);
              this._pt.u = 0;
              props.push("scaleY", p);
              p += "X";
            } else if (p === "transformOrigin") {
              inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);
              endValue = _convertKeywordsToPercentages(endValue);
              if (cache.svg) {
                _applySVGOrigin(target, endValue, 0, smooth, 0, this);
              } else {
                endUnit = parseFloat(endValue.split(" ")[2]) || 0;
                endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
                _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
              }
              continue;
            } else if (p === "svgOrigin") {
              _applySVGOrigin(target, endValue, 1, smooth, 0, this);
              continue;
            } else if (p in _rotationalProperties) {
              _addRotationalPropTween(this, cache, p, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);
              continue;
            } else if (p === "smoothOrigin") {
              _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
              continue;
            } else if (p === "force3D") {
              cache[p] = endValue;
              continue;
            } else if (p === "transform") {
              _addRawTransformPTs(this, endValue, target);
              continue;
            }
          } else if (!(p in style)) {
            p = _checkPropPrefix(p) || p;
          }
          if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
            startUnit = (startValue + "").substr((startNum + "").length);
            endNum || (endNum = 0);
            endUnit = getUnit(endValue) || (p in _config.units ? _config.units[p] : startUnit);
            startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
            this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
            this._pt.u = endUnit || 0;
            if (startUnit !== endUnit && endUnit !== "%") {
              this._pt.b = startValue;
              this._pt.r = _renderCSSPropWithBeginning;
            }
          } else if (!(p in style)) {
            if (p in target) {
              this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);
            } else if (p !== "parseTransform") {
              _missingPlugin(p, endValue);
              continue;
            }
          } else {
            _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);
          }
          isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : typeof target[p] === "function" ? inlineProps.push(p, 2, target[p]()) : inlineProps.push(p, 1, startValue || target[p]));
          props.push(p);
        }
      }
      hasPriority && _sortPropTweensByPriority(this);
    },
    render: function render2(ratio, data) {
      if (data.tween._time || !_reverting2()) {
        var pt = data._pt;
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
      } else {
        data.styles.revert();
      }
    },
    get: _get,
    aliases: _propertyAliases,
    getSetter: function getSetter(target, property, plugin) {
      var p = _propertyAliases[property];
      p && p.indexOf(",") < 0 && (property = p);
      return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);
    },
    core: {
      _removeProperty,
      _getMatrix
    }
  };
  gsap.utils.checkPrefix = _checkPropPrefix;
  gsap.core.getStyleSaver = _getStyleSaver;
  (function(positionAndScale, rotation, others, aliases) {
    var all = _forEachName(positionAndScale + "," + rotation + "," + others, function(name) {
      _transformProps[name] = 1;
    });
    _forEachName(rotation, function(name) {
      _config.units[name] = "deg";
      _rotationalProperties[name] = 1;
    });
    _propertyAliases[all[13]] = positionAndScale + "," + rotation;
    _forEachName(aliases, function(name) {
      var split2 = name.split(":");
      _propertyAliases[split2[1]] = all[split2[0]];
    });
  })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
  _forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(name) {
    _config.units[name] = "px";
  });
  gsap.registerPlugin(CSSPlugin);

  // node_modules/gsap/index.js
  var gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap;
  var TweenMaxWithCSS = gsapWithCSS.core.Tween;

  // src/assets/javascripts/config/config.ts
  var EXCLUDED_TAGS = ["STYLE", "SCRIPT", "NOSCRIPT"];
  var FADE_IN_CONFIG = {
    prefersReducedMotion: {
      from: {
        autoAlpha: 0,
        duration: 0.75,
        y: 0
      },
      to: {
        autoAlpha: 1,
        duration: 0.75,
        y: 0
      }
    },
    normal: {
      from: {
        autoAlpha: 0,
        y: 75
      },
      to: {
        autoAlpha: 1,
        duration: 0.5,
        y: 0
      }
    },
    defaults: {
      autoAlpha: 0,
      ease: "power1.inOut",
      repeat: 0,
      paused: true
    }
  };
  var OBSERVER_CONFIG = {
    fades: {
      fadeInSections: gsapWithCSS.utils.toArray("section"),
      fadeInDuration: 0.5,
      fadeInConfig: FADE_IN_CONFIG,
      fadeInIgnore: ".cta__container--header, .cta__container--subtitle"
    },
    slides: {
      sections: gsapWithCSS.utils.toArray("section"),
      slideDuration: 1.25,
      clickPause: 5,
      scrollPause: 10
    },
    clickTargets: ".cta__container--target-selector",
    ignoreTargets: "a, button, header, navigation, .md-tabs",
    emphasisTargets: {
      subtle: ".cta__container--target-selector>button",
      strong: ".cta__container--down-indicator"
    }
  };
  var MAX_WIDTHS = {
    426: "426",
    640: "640",
    854: "854",
    1280: "1280",
    1920: "1920",
    2560: "2560",
    3840: "3840"
  };
  var SUBTLE_EMPHASIS_CONFIG = {
    blinkConfig: {
      startAt: { filter: "brightness(1.1)" },
      autoAlpha: 0.4,
      duration: 1,
      ease: "power1.inOut",
      repeat: -1,
      yoyo: true,
      repeatDelay: 0.5,
      filter: "brightness(1.1)"
    },
    jumpConfig: {
      y: -2,
      duration: 0.5,
      ease: "elastic",
      repeatDelay: 4,
      repeat: -1,
      yoyoEase: "elastic"
    },
    scaleUpConfig: { scale: 1.1, duration: 1, repeatDelay: 4, repeat: -1, ease: "power1.inOut" }
  };
  var STRONG_EMPHASIS_CONFIG = {
    blinkConfig: { yoyoEase: "power1.in", repeat: -1, repeatDelay: 0.5, autoAlpha: 0.4 },
    jumpConfig: {},
    scaleUpConfig: { duration: 1 }
  };

  // src/assets/javascripts/utils/conditionChecks.ts
  var LICENSE_HASHES = ["#reader", "#html", "#markdown", "#plaintext", "#changelog", "#official"];
  var isProd = (url2) => {
    return url2.hostname === "plainlicense.org" && url2.protocol === "https:";
  };
  var isDev = (url2) => {
    return url2.hostname === "localhost" && url2.port === "8000" || url2.hostname === "127.0.0.1" && url2.port === "8000" || typeof window !== "undefined";
  };
  var isOnSite = (url2) => {
    return isProd(url2) || isDev(url2);
  };
  var isHome = (url2) => {
    return url2.pathname === "/" || url2.pathname === "/index.html" && isOnSite(url2);
  };
  var isMainSiteLicensePage = (url2) => {
    return url2.pathname.endsWith("index.html") && url2.pathname.split("/").length === 5 || url2.pathname.endsWith("/") && url2.pathname.split("/").length === 4;
  };
  var isEmbeddedLicensePage = (url2) => {
    const path = url2.pathname.split("/");
    return path[1] === "embed" && !path[path.length - 1].includes("index.html");
  };
  var isLicense = (url2) => {
    return isMainSiteLicensePage(url2) || isEmbeddedLicensePage(url2);
  };
  var isLicenseHash = (url2) => {
    return url2.hash.length > 1 && isLicense(url2) && LICENSE_HASHES.includes(url2.hash);
  };
  var isHelpingIndex = (url2) => {
    return url2.pathname.includes("helping") && (url2.pathname.split("/").length === 3 && url2.pathname.endsWith("index.html") || url2.pathname.split("/").length === 2 && url2.pathname.endsWith("/"));
  };
  var isValidEvent = (value) => {
    return value !== null && value instanceof Event;
  };
  function isValidElement(el, parent) {
    if (el === parent) {
      return false;
    }
    if (!(el instanceof Element)) {
      return false;
    }
    if (EXCLUDED_TAGS.includes(el.tagName)) {
      return false;
    }
    if (el instanceof SVGElement) {
      return true;
    }
    try {
      if (window.getComputedStyle(el)) {
        return true;
      }
    } catch {
      return false;
    }
    return el.innerHTML.trim() !== "";
  }

  // src/assets/javascripts/utils/log.ts
  var isDevelopment = false;
  var url = new URL(window.location.href);
  isDevelopment = isDev(url);
  var logger = {
    error: (message, ...args) => {
      if (isDevelopment) {
        console.error(message, ...args);
      }
    },
    warn: (message, ...args) => {
      if (isDevelopment) {
        console.warn(message, ...args);
      }
    },
    info: (message, ...args) => {
      if (isDevelopment) {
        console.info(message, ...args);
      }
    }
  };

  // src/assets/javascripts/utils/helpers.ts
  var createScript = (src, async2 = true, defer2 = true, ignoreDnt = false) => {
    const alreadyLoaded = document.querySelector(`script[src="${src}"]`);
    if (alreadyLoaded) {
      return;
    }
    const script2 = document.createElement("script");
    script2.type = "text/javascript";
    script2.src = src;
    script2.async = async2;
    script2.defer = defer2;
    if (ignoreDnt) {
      script2.dataset["ignoreDnt"] = "true";
    }
    document.head.appendChild(script2);
  };
  function setCssVariable(name, value) {
    document.documentElement.style.setProperty(name, value);
  }
  function parsePath(path) {
    const parts = path.split("/");
    const base = parts.pop() || "";
    const dir = parts.join("/") || "/";
    const name = base?.split(".").slice(0, -1).join(".") || "";
    const ext = base?.split(".").pop() || "";
    const root = parts[0] === "" ? "/" : "";
    const pathObj = { base, dir, ext, name, root };
    const url2 = URL.parse(path);
    if (url2 instanceof URL) {
      const { hash, host, hostname, href, origin, password, pathname, port, protocol, search, searchParams, username } = url2;
      return {
        base,
        dir,
        ext,
        hash,
        host,
        hostname,
        href,
        name,
        origin,
        password,
        pathname,
        port,
        protocol,
        root,
        search,
        searchParams,
        username
      };
    } else {
      return pathObj;
    }
  }
  function getCircularReplacer() {
    const seen = /* @__PURE__ */ new WeakSet();
    return (_key, value) => {
      if (typeof value === "object" && value !== null) {
        if (seen.has(value)) {
          try {
            return JSON.parse(JSON.stringify(value));
          } catch (err) {
            return "[Circular]";
          }
        }
        seen.add(value);
      }
      return value;
    };
  }

  // external/mkdocs-material/src/templates/assets/javascripts/bundle.ts
  var bundle_exports = {};
  var import_focus_visible = __toESM(require_focus_visible());

  // node_modules/rxjs/node_modules/tslib/tslib.es6.mjs
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve3) {
        resolve3(value);
      });
    }
    return new (P || (P = Promise))(function(resolve3, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve3(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1) throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  }
  function __spreadArray(to, from2, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from2.length, ar; i < l; i++) {
      if (ar || !(i in from2)) {
        if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from2));
  }
  function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function awaitReturn(f) {
      return function(v) {
        return Promise.resolve(v).then(f, reject);
      };
    }
    function verb(n, f) {
      if (g[n]) {
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
        if (f) i[n] = f(i[n]);
      }
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
  }
  function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve3, reject) {
          v = o[n](v), settle(resolve3, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve3, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve3({ value: v2, done: d });
      }, reject);
    }
  }

  // node_modules/rxjs/dist/esm5/internal/util/isFunction.js
  function isFunction(value) {
    return typeof value === "function";
  }

  // node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
  function createErrorClass(createImpl) {
    var _super = function(instance) {
      Error.call(instance);
      instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
  }

  // node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
  var UnsubscriptionError = createErrorClass(function(_super) {
    return function UnsubscriptionErrorImpl(errors) {
      _super(this);
      this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
        return i + 1 + ") " + err.toString();
      }).join("\n  ") : "";
      this.name = "UnsubscriptionError";
      this.errors = errors;
    };
  });

  // node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
  function arrRemove(arr, item) {
    if (arr) {
      var index = arr.indexOf(item);
      0 <= index && arr.splice(index, 1);
    }
  }

  // node_modules/rxjs/dist/esm5/internal/Subscription.js
  var Subscription = function() {
    function Subscription3(initialTeardown) {
      this.initialTeardown = initialTeardown;
      this.closed = false;
      this._parentage = null;
      this._finalizers = null;
    }
    Subscription3.prototype.unsubscribe = function() {
      var e_1, _a, e_2, _b;
      var errors;
      if (!this.closed) {
        this.closed = true;
        var _parentage = this._parentage;
        if (_parentage) {
          this._parentage = null;
          if (Array.isArray(_parentage)) {
            try {
              for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                var parent_1 = _parentage_1_1.value;
                parent_1.remove(this);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
          } else {
            _parentage.remove(this);
          }
        }
        var initialFinalizer = this.initialTeardown;
        if (isFunction(initialFinalizer)) {
          try {
            initialFinalizer();
          } catch (e) {
            errors = e instanceof UnsubscriptionError ? e.errors : [e];
          }
        }
        var _finalizers = this._finalizers;
        if (_finalizers) {
          this._finalizers = null;
          try {
            for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
              var finalizer = _finalizers_1_1.value;
              try {
                execFinalizer(finalizer);
              } catch (err) {
                errors = errors !== null && errors !== void 0 ? errors : [];
                if (err instanceof UnsubscriptionError) {
                  errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                } else {
                  errors.push(err);
                }
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
            } finally {
              if (e_2) throw e_2.error;
            }
          }
        }
        if (errors) {
          throw new UnsubscriptionError(errors);
        }
      }
    };
    Subscription3.prototype.add = function(teardown) {
      var _a;
      if (teardown && teardown !== this) {
        if (this.closed) {
          execFinalizer(teardown);
        } else {
          if (teardown instanceof Subscription3) {
            if (teardown.closed || teardown._hasParent(this)) {
              return;
            }
            teardown._addParent(this);
          }
          (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
        }
      }
    };
    Subscription3.prototype._hasParent = function(parent) {
      var _parentage = this._parentage;
      return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
    };
    Subscription3.prototype._addParent = function(parent) {
      var _parentage = this._parentage;
      this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription3.prototype._removeParent = function(parent) {
      var _parentage = this._parentage;
      if (_parentage === parent) {
        this._parentage = null;
      } else if (Array.isArray(_parentage)) {
        arrRemove(_parentage, parent);
      }
    };
    Subscription3.prototype.remove = function(teardown) {
      var _finalizers = this._finalizers;
      _finalizers && arrRemove(_finalizers, teardown);
      if (teardown instanceof Subscription3) {
        teardown._removeParent(this);
      }
    };
    Subscription3.EMPTY = function() {
      var empty = new Subscription3();
      empty.closed = true;
      return empty;
    }();
    return Subscription3;
  }();
  var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
  function isSubscription(value) {
    return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
  }
  function execFinalizer(finalizer) {
    if (isFunction(finalizer)) {
      finalizer();
    } else {
      finalizer.unsubscribe();
    }
  }

  // node_modules/rxjs/dist/esm5/internal/config.js
  var config3 = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: void 0,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false
  };

  // node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
  var timeoutProvider = {
    setTimeout: function(handler, timeout) {
      var args = [];
      for (var _i2 = 2; _i2 < arguments.length; _i2++) {
        args[_i2 - 2] = arguments[_i2];
      }
      var delegate = timeoutProvider.delegate;
      if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
        return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
      }
      return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
    },
    clearTimeout: function(handle2) {
      var delegate = timeoutProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle2);
    },
    delegate: void 0
  };

  // node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
  function reportUnhandledError(err) {
    timeoutProvider.setTimeout(function() {
      var onUnhandledError = config3.onUnhandledError;
      if (onUnhandledError) {
        onUnhandledError(err);
      } else {
        throw err;
      }
    });
  }

  // node_modules/rxjs/dist/esm5/internal/util/noop.js
  function noop() {
  }

  // node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
  var COMPLETE_NOTIFICATION = function() {
    return createNotification("C", void 0, void 0);
  }();
  function errorNotification(error) {
    return createNotification("E", void 0, error);
  }
  function nextNotification(value) {
    return createNotification("N", value, void 0);
  }
  function createNotification(kind, value, error) {
    return {
      kind,
      value,
      error
    };
  }

  // node_modules/rxjs/dist/esm5/internal/util/errorContext.js
  var context3 = null;
  function errorContext(cb) {
    if (config3.useDeprecatedSynchronousErrorHandling) {
      var isRoot = !context3;
      if (isRoot) {
        context3 = { errorThrown: false, error: null };
      }
      cb();
      if (isRoot) {
        var _a = context3, errorThrown = _a.errorThrown, error = _a.error;
        context3 = null;
        if (errorThrown) {
          throw error;
        }
      }
    } else {
      cb();
    }
  }
  function captureError(err) {
    if (config3.useDeprecatedSynchronousErrorHandling && context3) {
      context3.errorThrown = true;
      context3.error = err;
    }
  }

  // node_modules/rxjs/dist/esm5/internal/Subscriber.js
  var Subscriber = function(_super) {
    __extends(Subscriber2, _super);
    function Subscriber2(destination) {
      var _this = _super.call(this) || this;
      _this.isStopped = false;
      if (destination) {
        _this.destination = destination;
        if (isSubscription(destination)) {
          destination.add(_this);
        }
      } else {
        _this.destination = EMPTY_OBSERVER;
      }
      return _this;
    }
    Subscriber2.create = function(next, error, complete) {
      return new SafeSubscriber(next, error, complete);
    };
    Subscriber2.prototype.next = function(value) {
      if (this.isStopped) {
        handleStoppedNotification(nextNotification(value), this);
      } else {
        this._next(value);
      }
    };
    Subscriber2.prototype.error = function(err) {
      if (this.isStopped) {
        handleStoppedNotification(errorNotification(err), this);
      } else {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber2.prototype.complete = function() {
      if (this.isStopped) {
        handleStoppedNotification(COMPLETE_NOTIFICATION, this);
      } else {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber2.prototype.unsubscribe = function() {
      if (!this.closed) {
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
        this.destination = null;
      }
    };
    Subscriber2.prototype._next = function(value) {
      this.destination.next(value);
    };
    Subscriber2.prototype._error = function(err) {
      try {
        this.destination.error(err);
      } finally {
        this.unsubscribe();
      }
    };
    Subscriber2.prototype._complete = function() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    };
    return Subscriber2;
  }(Subscription);
  var _bind = Function.prototype.bind;
  function bind(fn, thisArg) {
    return _bind.call(fn, thisArg);
  }
  var ConsumerObserver = function() {
    function ConsumerObserver2(partialObserver) {
      this.partialObserver = partialObserver;
    }
    ConsumerObserver2.prototype.next = function(value) {
      var partialObserver = this.partialObserver;
      if (partialObserver.next) {
        try {
          partialObserver.next(value);
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    ConsumerObserver2.prototype.error = function(err) {
      var partialObserver = this.partialObserver;
      if (partialObserver.error) {
        try {
          partialObserver.error(err);
        } catch (error) {
          handleUnhandledError(error);
        }
      } else {
        handleUnhandledError(err);
      }
    };
    ConsumerObserver2.prototype.complete = function() {
      var partialObserver = this.partialObserver;
      if (partialObserver.complete) {
        try {
          partialObserver.complete();
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    return ConsumerObserver2;
  }();
  var SafeSubscriber = function(_super) {
    __extends(SafeSubscriber2, _super);
    function SafeSubscriber2(observerOrNext, error, complete) {
      var _this = _super.call(this) || this;
      var partialObserver;
      if (isFunction(observerOrNext) || !observerOrNext) {
        partialObserver = {
          next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
          error: error !== null && error !== void 0 ? error : void 0,
          complete: complete !== null && complete !== void 0 ? complete : void 0
        };
      } else {
        var context_1;
        if (_this && config3.useDeprecatedNextContext) {
          context_1 = Object.create(observerOrNext);
          context_1.unsubscribe = function() {
            return _this.unsubscribe();
          };
          partialObserver = {
            next: observerOrNext.next && bind(observerOrNext.next, context_1),
            error: observerOrNext.error && bind(observerOrNext.error, context_1),
            complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
          };
        } else {
          partialObserver = observerOrNext;
        }
      }
      _this.destination = new ConsumerObserver(partialObserver);
      return _this;
    }
    return SafeSubscriber2;
  }(Subscriber);
  function handleUnhandledError(error) {
    if (config3.useDeprecatedSynchronousErrorHandling) {
      captureError(error);
    } else {
      reportUnhandledError(error);
    }
  }
  function defaultErrorHandler(err) {
    throw err;
  }
  function handleStoppedNotification(notification, subscriber) {
    var onStoppedNotification = config3.onStoppedNotification;
    onStoppedNotification && timeoutProvider.setTimeout(function() {
      return onStoppedNotification(notification, subscriber);
    });
  }
  var EMPTY_OBSERVER = {
    closed: true,
    next: noop,
    error: defaultErrorHandler,
    complete: noop
  };

  // node_modules/rxjs/dist/esm5/internal/symbol/observable.js
  var observable = function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();

  // node_modules/rxjs/dist/esm5/internal/util/identity.js
  function identity(x) {
    return x;
  }

  // node_modules/rxjs/dist/esm5/internal/util/pipe.js
  function pipe3() {
    var fns = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      fns[_i2] = arguments[_i2];
    }
    return pipeFromArray(fns);
  }
  function pipeFromArray(fns) {
    if (fns.length === 0) {
      return identity;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function(prev, fn) {
        return fn(prev);
      }, input);
    };
  }

  // node_modules/rxjs/dist/esm5/internal/Observable.js
  var Observable = function() {
    function Observable62(subscribe) {
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable62.prototype.lift = function(operator) {
      var observable2 = new Observable62();
      observable2.source = this;
      observable2.operator = operator;
      return observable2;
    };
    Observable62.prototype.subscribe = function(observerOrNext, error, complete) {
      var _this = this;
      var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
      errorContext(function() {
        var _a = _this, operator = _a.operator, source = _a.source;
        subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
      });
      return subscriber;
    };
    Observable62.prototype._trySubscribe = function(sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        sink.error(err);
      }
    };
    Observable62.prototype.forEach = function(next, promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve3, reject) {
        var subscriber = new SafeSubscriber({
          next: function(value) {
            try {
              next(value);
            } catch (err) {
              reject(err);
              subscriber.unsubscribe();
            }
          },
          error: reject,
          complete: resolve3
        });
        _this.subscribe(subscriber);
      });
    };
    Observable62.prototype._subscribe = function(subscriber) {
      var _a;
      return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
    };
    Observable62.prototype[observable] = function() {
      return this;
    };
    Observable62.prototype.pipe = function() {
      var operations = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        operations[_i2] = arguments[_i2];
      }
      return pipeFromArray(operations)(this);
    };
    Observable62.prototype.toPromise = function(promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve3, reject) {
        var value;
        _this.subscribe(function(x) {
          return value = x;
        }, function(err) {
          return reject(err);
        }, function() {
          return resolve3(value);
        });
      });
    };
    Observable62.create = function(subscribe) {
      return new Observable62(subscribe);
    };
    return Observable62;
  }();
  function getPromiseCtor(promiseCtor) {
    var _a;
    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config3.Promise) !== null && _a !== void 0 ? _a : Promise;
  }
  function isObserver(value) {
    return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
  }
  function isSubscriber(value) {
    return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
  }

  // node_modules/rxjs/dist/esm5/internal/util/lift.js
  function hasLift(source) {
    return isFunction(source === null || source === void 0 ? void 0 : source.lift);
  }
  function operate(init5) {
    return function(source) {
      if (hasLift(source)) {
        return source.lift(function(liftedSource) {
          try {
            return init5(liftedSource, this);
          } catch (err) {
            this.error(err);
          }
        });
      }
      throw new TypeError("Unable to lift unknown Observable type");
    };
  }

  // node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
  function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
  }
  var OperatorSubscriber = function(_super) {
    __extends(OperatorSubscriber2, _super);
    function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
      var _this = _super.call(this, destination) || this;
      _this.onFinalize = onFinalize;
      _this.shouldUnsubscribe = shouldUnsubscribe;
      _this._next = onNext ? function(value) {
        try {
          onNext(value);
        } catch (err) {
          destination.error(err);
        }
      } : _super.prototype._next;
      _this._error = onError ? function(err) {
        try {
          onError(err);
        } catch (err2) {
          destination.error(err2);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._error;
      _this._complete = onComplete ? function() {
        try {
          onComplete();
        } catch (err) {
          destination.error(err);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._complete;
      return _this;
    }
    OperatorSubscriber2.prototype.unsubscribe = function() {
      var _a;
      if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
        var closed_1 = this.closed;
        _super.prototype.unsubscribe.call(this);
        !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
      }
    };
    return OperatorSubscriber2;
  }(Subscriber);

  // node_modules/rxjs/dist/esm5/internal/scheduler/animationFrameProvider.js
  var animationFrameProvider = {
    schedule: function(callback) {
      var request2 = requestAnimationFrame;
      var cancel = cancelAnimationFrame;
      var delegate = animationFrameProvider.delegate;
      if (delegate) {
        request2 = delegate.requestAnimationFrame;
        cancel = delegate.cancelAnimationFrame;
      }
      var handle2 = request2(function(timestamp) {
        cancel = void 0;
        callback(timestamp);
      });
      return new Subscription(function() {
        return cancel === null || cancel === void 0 ? void 0 : cancel(handle2);
      });
    },
    requestAnimationFrame: function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      var delegate = animationFrameProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
    },
    cancelAnimationFrame: function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      var delegate = animationFrameProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
    },
    delegate: void 0
  };

  // node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
  var ObjectUnsubscribedError = createErrorClass(function(_super) {
    return function ObjectUnsubscribedErrorImpl() {
      _super(this);
      this.name = "ObjectUnsubscribedError";
      this.message = "object unsubscribed";
    };
  });

  // node_modules/rxjs/dist/esm5/internal/Subject.js
  var Subject = function(_super) {
    __extends(Subject8, _super);
    function Subject8() {
      var _this = _super.call(this) || this;
      _this.closed = false;
      _this.currentObservers = null;
      _this.observers = [];
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }
    Subject8.prototype.lift = function(operator) {
      var subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    };
    Subject8.prototype._throwIfClosed = function() {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
    };
    Subject8.prototype.next = function(value) {
      var _this = this;
      errorContext(function() {
        var e_1, _a;
        _this._throwIfClosed();
        if (!_this.isStopped) {
          if (!_this.currentObservers) {
            _this.currentObservers = Array.from(_this.observers);
          }
          try {
            for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
              var observer = _c.value;
              observer.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        }
      });
    };
    Subject8.prototype.error = function(err) {
      var _this = this;
      errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.hasError = _this.isStopped = true;
          _this.thrownError = err;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().error(err);
          }
        }
      });
    };
    Subject8.prototype.complete = function() {
      var _this = this;
      errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.isStopped = true;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().complete();
          }
        }
      });
    };
    Subject8.prototype.unsubscribe = function() {
      this.isStopped = this.closed = true;
      this.observers = this.currentObservers = null;
    };
    Object.defineProperty(Subject8.prototype, "observed", {
      get: function() {
        var _a;
        return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
      },
      enumerable: false,
      configurable: true
    });
    Subject8.prototype._trySubscribe = function(subscriber) {
      this._throwIfClosed();
      return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject8.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._checkFinalizedStatuses(subscriber);
      return this._innerSubscribe(subscriber);
    };
    Subject8.prototype._innerSubscribe = function(subscriber) {
      var _this = this;
      var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
      if (hasError || isStopped) {
        return EMPTY_SUBSCRIPTION;
      }
      this.currentObservers = null;
      observers.push(subscriber);
      return new Subscription(function() {
        _this.currentObservers = null;
        arrRemove(observers, subscriber);
      });
    };
    Subject8.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped) {
        subscriber.complete();
      }
    };
    Subject8.prototype.asObservable = function() {
      var observable2 = new Observable();
      observable2.source = this;
      return observable2;
    };
    Subject8.create = function(destination, source) {
      return new AnonymousSubject(destination, source);
    };
    return Subject8;
  }(Observable);
  var AnonymousSubject = function(_super) {
    __extends(AnonymousSubject2, _super);
    function AnonymousSubject2(destination, source) {
      var _this = _super.call(this) || this;
      _this.destination = destination;
      _this.source = source;
      return _this;
    }
    AnonymousSubject2.prototype.next = function(value) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
    };
    AnonymousSubject2.prototype.error = function(err) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
    };
    AnonymousSubject2.prototype.complete = function() {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    AnonymousSubject2.prototype._subscribe = function(subscriber) {
      var _a, _b;
      return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
    };
    return AnonymousSubject2;
  }(Subject);

  // node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
  var BehaviorSubject = function(_super) {
    __extends(BehaviorSubject2, _super);
    function BehaviorSubject2(_value) {
      var _this = _super.call(this) || this;
      _this._value = _value;
      return _this;
    }
    Object.defineProperty(BehaviorSubject2.prototype, "value", {
      get: function() {
        return this.getValue();
      },
      enumerable: false,
      configurable: true
    });
    BehaviorSubject2.prototype._subscribe = function(subscriber) {
      var subscription = _super.prototype._subscribe.call(this, subscriber);
      !subscription.closed && subscriber.next(this._value);
      return subscription;
    };
    BehaviorSubject2.prototype.getValue = function() {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
      if (hasError) {
        throw thrownError;
      }
      this._throwIfClosed();
      return _value;
    };
    BehaviorSubject2.prototype.next = function(value) {
      _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject2;
  }(Subject);

  // node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
  var dateTimestampProvider = {
    now: function() {
      return (dateTimestampProvider.delegate || Date).now();
    },
    delegate: void 0
  };

  // node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
  var ReplaySubject = function(_super) {
    __extends(ReplaySubject2, _super);
    function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
      if (_bufferSize === void 0) {
        _bufferSize = Infinity;
      }
      if (_windowTime === void 0) {
        _windowTime = Infinity;
      }
      if (_timestampProvider === void 0) {
        _timestampProvider = dateTimestampProvider;
      }
      var _this = _super.call(this) || this;
      _this._bufferSize = _bufferSize;
      _this._windowTime = _windowTime;
      _this._timestampProvider = _timestampProvider;
      _this._buffer = [];
      _this._infiniteTimeWindow = true;
      _this._infiniteTimeWindow = _windowTime === Infinity;
      _this._bufferSize = Math.max(1, _bufferSize);
      _this._windowTime = Math.max(1, _windowTime);
      return _this;
    }
    ReplaySubject2.prototype.next = function(value) {
      var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
      if (!isStopped) {
        _buffer.push(value);
        !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
      }
      this._trimBuffer();
      _super.prototype.next.call(this, value);
    };
    ReplaySubject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._trimBuffer();
      var subscription = this._innerSubscribe(subscriber);
      var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
      var copy = _buffer.slice();
      for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
        subscriber.next(copy[i]);
      }
      this._checkFinalizedStatuses(subscriber);
      return subscription;
    };
    ReplaySubject2.prototype._trimBuffer = function() {
      var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
      var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
      _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
      if (!_infiniteTimeWindow) {
        var now = _timestampProvider.now();
        var last2 = 0;
        for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
          last2 = i;
        }
        last2 && _buffer.splice(0, last2 + 1);
      }
    };
    return ReplaySubject2;
  }(Subject);

  // node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
  var Action = function(_super) {
    __extends(Action2, _super);
    function Action2(scheduler, work) {
      return _super.call(this) || this;
    }
    Action2.prototype.schedule = function(state, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      return this;
    };
    return Action2;
  }(Subscription);

  // node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
  var intervalProvider = {
    setInterval: function(handler, timeout) {
      var args = [];
      for (var _i2 = 2; _i2 < arguments.length; _i2++) {
        args[_i2 - 2] = arguments[_i2];
      }
      var delegate = intervalProvider.delegate;
      if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
        return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout], __read(args)));
      }
      return setInterval.apply(void 0, __spreadArray([handler, timeout], __read(args)));
    },
    clearInterval: function(handle2) {
      var delegate = intervalProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle2);
    },
    delegate: void 0
  };

  // node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
  var AsyncAction = function(_super) {
    __extends(AsyncAction2, _super);
    function AsyncAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      _this.pending = false;
      return _this;
    }
    AsyncAction2.prototype.schedule = function(state, delay2) {
      var _a;
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (this.closed) {
        return this;
      }
      this.state = state;
      var id = this.id;
      var scheduler = this.scheduler;
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, delay2);
      }
      this.pending = true;
      this.delay = delay2;
      this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay2);
      return this;
    };
    AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
    };
    AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 != null && this.delay === delay2 && this.pending === false) {
        return id;
      }
      if (id != null) {
        intervalProvider.clearInterval(id);
      }
      return void 0;
    };
    AsyncAction2.prototype.execute = function(state, delay2) {
      if (this.closed) {
        return new Error("executing a cancelled action");
      }
      this.pending = false;
      var error = this._execute(state, delay2);
      if (error) {
        return error;
      } else if (this.pending === false && this.id != null) {
        this.id = this.recycleAsyncId(this.scheduler, this.id, null);
      }
    };
    AsyncAction2.prototype._execute = function(state, _delay) {
      var errored = false;
      var errorValue;
      try {
        this.work(state);
      } catch (e) {
        errored = true;
        errorValue = e ? e : new Error("Scheduled action threw falsy error");
      }
      if (errored) {
        this.unsubscribe();
        return errorValue;
      }
    };
    AsyncAction2.prototype.unsubscribe = function() {
      if (!this.closed) {
        var _a = this, id = _a.id, scheduler = _a.scheduler;
        var actions = scheduler.actions;
        this.work = this.state = this.scheduler = null;
        this.pending = false;
        arrRemove(actions, this);
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
        _super.prototype.unsubscribe.call(this);
      }
    };
    return AsyncAction2;
  }(Action);

  // node_modules/rxjs/dist/esm5/internal/Scheduler.js
  var Scheduler = function() {
    function Scheduler2(schedulerActionCtor, now) {
      if (now === void 0) {
        now = Scheduler2.now;
      }
      this.schedulerActionCtor = schedulerActionCtor;
      this.now = now;
    }
    Scheduler2.prototype.schedule = function(work, delay2, state) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      return new this.schedulerActionCtor(this, work).schedule(state, delay2);
    };
    Scheduler2.now = dateTimestampProvider.now;
    return Scheduler2;
  }();

  // node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
  var AsyncScheduler = function(_super) {
    __extends(AsyncScheduler2, _super);
    function AsyncScheduler2(SchedulerAction, now) {
      if (now === void 0) {
        now = Scheduler.now;
      }
      var _this = _super.call(this, SchedulerAction, now) || this;
      _this.actions = [];
      _this._active = false;
      return _this;
    }
    AsyncScheduler2.prototype.flush = function(action) {
      var actions = this.actions;
      if (this._active) {
        actions.push(action);
        return;
      }
      var error;
      this._active = true;
      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while (action = actions.shift());
      this._active = false;
      if (error) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    return AsyncScheduler2;
  }(Scheduler);

  // node_modules/rxjs/dist/esm5/internal/scheduler/async.js
  var asyncScheduler = new AsyncScheduler(AsyncAction);
  var async = asyncScheduler;

  // node_modules/rxjs/dist/esm5/internal/scheduler/QueueAction.js
  var QueueAction = function(_super) {
    __extends(QueueAction2, _super);
    function QueueAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    QueueAction2.prototype.schedule = function(state, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 > 0) {
        return _super.prototype.schedule.call(this, state, delay2);
      }
      this.delay = delay2;
      this.state = state;
      this.scheduler.flush(this);
      return this;
    };
    QueueAction2.prototype.execute = function(state, delay2) {
      return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay2) : this._execute(state, delay2);
    };
    QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
      }
      scheduler.flush(this);
      return 0;
    };
    return QueueAction2;
  }(AsyncAction);

  // node_modules/rxjs/dist/esm5/internal/scheduler/QueueScheduler.js
  var QueueScheduler = function(_super) {
    __extends(QueueScheduler2, _super);
    function QueueScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler2;
  }(AsyncScheduler);

  // node_modules/rxjs/dist/esm5/internal/scheduler/queue.js
  var queueScheduler = new QueueScheduler(QueueAction);

  // node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameAction.js
  var AnimationFrameAction = function(_super) {
    __extends(AnimationFrameAction2, _super);
    function AnimationFrameAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 !== null && delay2 > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
      }
      scheduler.actions.push(this);
      return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function() {
        return scheduler.flush(void 0);
      }));
    };
    AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
      var _a;
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 != null ? delay2 > 0 : this.delay > 0) {
        return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
      }
      var actions = scheduler.actions;
      if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
        animationFrameProvider.cancelAnimationFrame(id);
        scheduler._scheduled = void 0;
      }
      return void 0;
    };
    return AnimationFrameAction2;
  }(AsyncAction);

  // node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameScheduler.js
  var AnimationFrameScheduler = function(_super) {
    __extends(AnimationFrameScheduler2, _super);
    function AnimationFrameScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler2.prototype.flush = function(action) {
      this._active = true;
      var flushId = this._scheduled;
      this._scheduled = void 0;
      var actions = this.actions;
      var error;
      action = action || actions.shift();
      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while ((action = actions[0]) && action.id === flushId && actions.shift());
      this._active = false;
      if (error) {
        while ((action = actions[0]) && action.id === flushId && actions.shift()) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    return AnimationFrameScheduler2;
  }(AsyncScheduler);

  // node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js
  var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);

  // node_modules/rxjs/dist/esm5/internal/observable/empty.js
  var EMPTY = new Observable(function(subscriber) {
    return subscriber.complete();
  });

  // node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
  function isScheduler(value) {
    return value && isFunction(value.schedule);
  }

  // node_modules/rxjs/dist/esm5/internal/util/args.js
  function last(arr) {
    return arr[arr.length - 1];
  }
  function popResultSelector(args) {
    return isFunction(last(args)) ? args.pop() : void 0;
  }
  function popScheduler(args) {
    return isScheduler(last(args)) ? args.pop() : void 0;
  }
  function popNumber(args, defaultValue) {
    return typeof last(args) === "number" ? args.pop() : defaultValue;
  }

  // node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
  var isArrayLike = function(x) {
    return x && typeof x.length === "number" && typeof x !== "function";
  };

  // node_modules/rxjs/dist/esm5/internal/util/isPromise.js
  function isPromise(value) {
    return isFunction(value === null || value === void 0 ? void 0 : value.then);
  }

  // node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
  function isInteropObservable(input) {
    return isFunction(input[observable]);
  }

  // node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
  function isAsyncIterable(obj) {
    return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
  }

  // node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
  function createInvalidObservableTypeError(input) {
    return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
  }

  // node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
  function getSymbolIterator() {
    if (typeof Symbol !== "function" || !Symbol.iterator) {
      return "@@iterator";
    }
    return Symbol.iterator;
  }
  var iterator = getSymbolIterator();

  // node_modules/rxjs/dist/esm5/internal/util/isIterable.js
  function isIterable(input) {
    return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
  }

  // node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
  function readableStreamLikeToAsyncGenerator(readableStream) {
    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
      var reader, _a, value, done;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            reader = readableStream.getReader();
            _b.label = 1;
          case 1:
            _b.trys.push([1, , 9, 10]);
            _b.label = 2;
          case 2:
            if (false) return [3, 8];
            return [4, __await(reader.read())];
          case 3:
            _a = _b.sent(), value = _a.value, done = _a.done;
            if (!done) return [3, 5];
            return [4, __await(void 0)];
          case 4:
            return [2, _b.sent()];
          case 5:
            return [4, __await(value)];
          case 6:
            return [4, _b.sent()];
          case 7:
            _b.sent();
            return [3, 2];
          case 8:
            return [3, 10];
          case 9:
            reader.releaseLock();
            return [7];
          case 10:
            return [2];
        }
      });
    });
  }
  function isReadableStreamLike(obj) {
    return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
  }

  // node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
  function innerFrom(input) {
    if (input instanceof Observable) {
      return input;
    }
    if (input != null) {
      if (isInteropObservable(input)) {
        return fromInteropObservable(input);
      }
      if (isArrayLike(input)) {
        return fromArrayLike(input);
      }
      if (isPromise(input)) {
        return fromPromise(input);
      }
      if (isAsyncIterable(input)) {
        return fromAsyncIterable(input);
      }
      if (isIterable(input)) {
        return fromIterable(input);
      }
      if (isReadableStreamLike(input)) {
        return fromReadableStreamLike(input);
      }
    }
    throw createInvalidObservableTypeError(input);
  }
  function fromInteropObservable(obj) {
    return new Observable(function(subscriber) {
      var obs = obj[observable]();
      if (isFunction(obs.subscribe)) {
        return obs.subscribe(subscriber);
      }
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
  }
  function fromArrayLike(array) {
    return new Observable(function(subscriber) {
      for (var i = 0; i < array.length && !subscriber.closed; i++) {
        subscriber.next(array[i]);
      }
      subscriber.complete();
    });
  }
  function fromPromise(promise) {
    return new Observable(function(subscriber) {
      promise.then(function(value) {
        if (!subscriber.closed) {
          subscriber.next(value);
          subscriber.complete();
        }
      }, function(err) {
        return subscriber.error(err);
      }).then(null, reportUnhandledError);
    });
  }
  function fromIterable(iterable) {
    return new Observable(function(subscriber) {
      var e_1, _a;
      try {
        for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
          var value = iterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      subscriber.complete();
    });
  }
  function fromAsyncIterable(asyncIterable) {
    return new Observable(function(subscriber) {
      process(asyncIterable, subscriber).catch(function(err) {
        return subscriber.error(err);
      });
    });
  }
  function fromReadableStreamLike(readableStream) {
    return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
  }
  function process(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;
    var e_2, _a;
    return __awaiter(this, void 0, void 0, function() {
      var value, e_2_1;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _b.trys.push([0, 5, 6, 11]);
            asyncIterable_1 = __asyncValues(asyncIterable);
            _b.label = 1;
          case 1:
            return [4, asyncIterable_1.next()];
          case 2:
            if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
            value = asyncIterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return [2];
            }
            _b.label = 3;
          case 3:
            return [3, 1];
          case 4:
            return [3, 11];
          case 5:
            e_2_1 = _b.sent();
            e_2 = { error: e_2_1 };
            return [3, 11];
          case 6:
            _b.trys.push([6, , 9, 10]);
            if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
            return [4, _a.call(asyncIterable_1)];
          case 7:
            _b.sent();
            _b.label = 8;
          case 8:
            return [3, 10];
          case 9:
            if (e_2) throw e_2.error;
            return [7];
          case 10:
            return [7];
          case 11:
            subscriber.complete();
            return [2];
        }
      });
    });
  }

  // node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
  function executeSchedule(parentSubscription, scheduler, work, delay2, repeat2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (repeat2 === void 0) {
      repeat2 = false;
    }
    var scheduleSubscription = scheduler.schedule(function() {
      work();
      if (repeat2) {
        parentSubscription.add(this.schedule(null, delay2));
      } else {
        this.unsubscribe();
      }
    }, delay2);
    parentSubscription.add(scheduleSubscription);
    if (!repeat2) {
      return scheduleSubscription;
    }
  }

  // node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
  function observeOn(scheduler, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return operate(function(source, subscriber) {
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.next(value);
        }, delay2);
      }, function() {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.complete();
        }, delay2);
      }, function(err) {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.error(err);
        }, delay2);
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
  function subscribeOn(scheduler, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return operate(function(source, subscriber) {
      subscriber.add(scheduler.schedule(function() {
        return source.subscribe(subscriber);
      }, delay2));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
  function scheduleObservable(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
  }

  // node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
  function schedulePromise(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
  }

  // node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
  function scheduleArray(input, scheduler) {
    return new Observable(function(subscriber) {
      var i = 0;
      return scheduler.schedule(function() {
        if (i === input.length) {
          subscriber.complete();
        } else {
          subscriber.next(input[i++]);
          if (!subscriber.closed) {
            this.schedule();
          }
        }
      });
    });
  }

  // node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
  function scheduleIterable(input, scheduler) {
    return new Observable(function(subscriber) {
      var iterator2;
      executeSchedule(subscriber, scheduler, function() {
        iterator2 = input[iterator]();
        executeSchedule(subscriber, scheduler, function() {
          var _a;
          var value;
          var done;
          try {
            _a = iterator2.next(), value = _a.value, done = _a.done;
          } catch (err) {
            subscriber.error(err);
            return;
          }
          if (done) {
            subscriber.complete();
          } else {
            subscriber.next(value);
          }
        }, 0, true);
      });
      return function() {
        return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
      };
    });
  }

  // node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
  function scheduleAsyncIterable(input, scheduler) {
    if (!input) {
      throw new Error("Iterable cannot be null");
    }
    return new Observable(function(subscriber) {
      executeSchedule(subscriber, scheduler, function() {
        var iterator2 = input[Symbol.asyncIterator]();
        executeSchedule(subscriber, scheduler, function() {
          iterator2.next().then(function(result) {
            if (result.done) {
              subscriber.complete();
            } else {
              subscriber.next(result.value);
            }
          });
        }, 0, true);
      });
    });
  }

  // node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
  function scheduleReadableStreamLike(input, scheduler) {
    return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
  }

  // node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
  function scheduled(input, scheduler) {
    if (input != null) {
      if (isInteropObservable(input)) {
        return scheduleObservable(input, scheduler);
      }
      if (isArrayLike(input)) {
        return scheduleArray(input, scheduler);
      }
      if (isPromise(input)) {
        return schedulePromise(input, scheduler);
      }
      if (isAsyncIterable(input)) {
        return scheduleAsyncIterable(input, scheduler);
      }
      if (isIterable(input)) {
        return scheduleIterable(input, scheduler);
      }
      if (isReadableStreamLike(input)) {
        return scheduleReadableStreamLike(input, scheduler);
      }
    }
    throw createInvalidObservableTypeError(input);
  }

  // node_modules/rxjs/dist/esm5/internal/observable/from.js
  function from(input, scheduler) {
    return scheduler ? scheduled(input, scheduler) : innerFrom(input);
  }

  // node_modules/rxjs/dist/esm5/internal/observable/of.js
  function of() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var scheduler = popScheduler(args);
    return from(args, scheduler);
  }

  // node_modules/rxjs/dist/esm5/internal/observable/throwError.js
  function throwError(errorOrErrorFactory, scheduler) {
    var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
      return errorOrErrorFactory;
    };
    var init5 = function(subscriber) {
      return subscriber.error(errorFactory());
    };
    return new Observable(scheduler ? function(subscriber) {
      return scheduler.schedule(init5, 0, subscriber);
    } : init5);
  }

  // node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
  var EmptyError = createErrorClass(function(_super) {
    return function EmptyErrorImpl() {
      _super(this);
      this.name = "EmptyError";
      this.message = "no elements in sequence";
    };
  });

  // node_modules/rxjs/dist/esm5/internal/util/isDate.js
  function isValidDate(value) {
    return value instanceof Date && !isNaN(value);
  }

  // node_modules/rxjs/dist/esm5/internal/operators/map.js
  function map(project, thisArg) {
    return operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        subscriber.next(project.call(thisArg, value, index++));
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
  var isArray = Array.isArray;
  function callOrApply(fn, args) {
    return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
  }
  function mapOneOrManyArgs(fn) {
    return map(function(args) {
      return callOrApply(fn, args);
    });
  }

  // node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
  var isArray2 = Array.isArray;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectProto = Object.prototype;
  var getKeys = Object.keys;
  function argsArgArrayOrObject(args) {
    if (args.length === 1) {
      var first_1 = args[0];
      if (isArray2(first_1)) {
        return { args: first_1, keys: null };
      }
      if (isPOJO(first_1)) {
        var keys = getKeys(first_1);
        return {
          args: keys.map(function(key) {
            return first_1[key];
          }),
          keys
        };
      }
    }
    return { args, keys: null };
  }
  function isPOJO(obj) {
    return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
  }

  // node_modules/rxjs/dist/esm5/internal/util/createObject.js
  function createObject(keys, values) {
    return keys.reduce(function(result, key, i) {
      return result[key] = values[i], result;
    }, {});
  }

  // node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js
  function combineLatest() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var scheduler = popScheduler(args);
    var resultSelector = popResultSelector(args);
    var _a = argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
    if (observables.length === 0) {
      return from([], scheduler);
    }
    var result = new Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
      return createObject(keys, values);
    } : identity));
    return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
  }
  function combineLatestInit(observables, scheduler, valueTransform) {
    if (valueTransform === void 0) {
      valueTransform = identity;
    }
    return function(subscriber) {
      maybeSchedule(scheduler, function() {
        var length = observables.length;
        var values = new Array(length);
        var active = length;
        var remainingFirstValues = length;
        var _loop_1 = function(i2) {
          maybeSchedule(scheduler, function() {
            var source = from(observables[i2], scheduler);
            var hasFirstValue = false;
            source.subscribe(createOperatorSubscriber(subscriber, function(value) {
              values[i2] = value;
              if (!hasFirstValue) {
                hasFirstValue = true;
                remainingFirstValues--;
              }
              if (!remainingFirstValues) {
                subscriber.next(valueTransform(values.slice()));
              }
            }, function() {
              if (!--active) {
                subscriber.complete();
              }
            }));
          }, subscriber);
        };
        for (var i = 0; i < length; i++) {
          _loop_1(i);
        }
      }, subscriber);
    };
  }
  function maybeSchedule(scheduler, execute, subscription) {
    if (scheduler) {
      executeSchedule(subscription, scheduler, execute);
    } else {
      execute();
    }
  }

  // node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
  function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
    var buffer = [];
    var active = 0;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      if (isComplete && !buffer.length && !active) {
        subscriber.complete();
      }
    };
    var outerNext = function(value) {
      return active < concurrent ? doInnerSub(value) : buffer.push(value);
    };
    var doInnerSub = function(value) {
      expand && subscriber.next(value);
      active++;
      var innerComplete = false;
      innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
        onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
        if (expand) {
          outerNext(innerValue);
        } else {
          subscriber.next(innerValue);
        }
      }, function() {
        innerComplete = true;
      }, void 0, function() {
        if (innerComplete) {
          try {
            active--;
            var _loop_1 = function() {
              var bufferedValue = buffer.shift();
              if (innerSubScheduler) {
                executeSchedule(subscriber, innerSubScheduler, function() {
                  return doInnerSub(bufferedValue);
                });
              } else {
                doInnerSub(bufferedValue);
              }
            };
            while (buffer.length && active < concurrent) {
              _loop_1();
            }
            checkComplete();
          } catch (err) {
            subscriber.error(err);
          }
        }
      }));
    };
    source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
      isComplete = true;
      checkComplete();
    }));
    return function() {
      additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
    };
  }

  // node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
  function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    if (isFunction(resultSelector)) {
      return mergeMap(function(a, i) {
        return map(function(b, ii) {
          return resultSelector(a, b, i, ii);
        })(innerFrom(project(a, i)));
      }, concurrent);
    } else if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return operate(function(source, subscriber) {
      return mergeInternals(source, subscriber, project, concurrent);
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js
  function mergeAll(concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    return mergeMap(identity, concurrent);
  }

  // node_modules/rxjs/dist/esm5/internal/operators/concatAll.js
  function concatAll() {
    return mergeAll(1);
  }

  // node_modules/rxjs/dist/esm5/internal/observable/concat.js
  function concat() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    return concatAll()(from(args, popScheduler(args)));
  }

  // node_modules/rxjs/dist/esm5/internal/observable/defer.js
  function defer(observableFactory) {
    return new Observable(function(subscriber) {
      innerFrom(observableFactory()).subscribe(subscriber);
    });
  }

  // node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js
  var nodeEventEmitterMethods = ["addListener", "removeListener"];
  var eventTargetMethods = ["addEventListener", "removeEventListener"];
  var jqueryMethods = ["on", "off"];
  function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction(options)) {
      resultSelector = options;
      options = void 0;
    }
    if (resultSelector) {
      return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
    }
    var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler, options);
      };
    }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];
    if (!add) {
      if (isArrayLike(target)) {
        return mergeMap(function(subTarget) {
          return fromEvent(subTarget, eventName, options);
        })(innerFrom(target));
      }
    }
    if (!add) {
      throw new TypeError("Invalid event target");
    }
    return new Observable(function(subscriber) {
      var handler = function() {
        var args = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          args[_i2] = arguments[_i2];
        }
        return subscriber.next(1 < args.length ? args : args[0]);
      };
      add(handler);
      return function() {
        return remove(handler);
      };
    });
  }
  function toCommonHandlerRegistry(target, eventName) {
    return function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler);
      };
    };
  }
  function isNodeStyleEventEmitter(target) {
    return isFunction(target.addListener) && isFunction(target.removeListener);
  }
  function isJQueryStyleEventEmitter(target) {
    return isFunction(target.on) && isFunction(target.off);
  }
  function isEventTarget(target) {
    return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
  }

  // node_modules/rxjs/dist/esm5/internal/observable/fromEventPattern.js
  function fromEventPattern(addHandler, removeHandler, resultSelector) {
    if (resultSelector) {
      return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs(resultSelector));
    }
    return new Observable(function(subscriber) {
      var handler = function() {
        var e = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          e[_i2] = arguments[_i2];
        }
        return subscriber.next(e.length === 1 ? e[0] : e);
      };
      var retValue = addHandler(handler);
      return isFunction(removeHandler) ? function() {
        return removeHandler(handler, retValue);
      } : void 0;
    });
  }

  // node_modules/rxjs/dist/esm5/internal/observable/timer.js
  function timer(dueTime, intervalOrScheduler, scheduler) {
    if (dueTime === void 0) {
      dueTime = 0;
    }
    if (scheduler === void 0) {
      scheduler = async;
    }
    var intervalDuration = -1;
    if (intervalOrScheduler != null) {
      if (isScheduler(intervalOrScheduler)) {
        scheduler = intervalOrScheduler;
      } else {
        intervalDuration = intervalOrScheduler;
      }
    }
    return new Observable(function(subscriber) {
      var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
      if (due < 0) {
        due = 0;
      }
      var n = 0;
      return scheduler.schedule(function() {
        if (!subscriber.closed) {
          subscriber.next(n++);
          if (0 <= intervalDuration) {
            this.schedule(void 0, intervalDuration);
          } else {
            subscriber.complete();
          }
        }
      }, due);
    });
  }

  // node_modules/rxjs/dist/esm5/internal/observable/merge.js
  function merge() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var scheduler = popScheduler(args);
    var concurrent = popNumber(args, Infinity);
    var sources = args;
    return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));
  }

  // node_modules/rxjs/dist/esm5/internal/observable/never.js
  var NEVER = new Observable(noop);

  // node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js
  var isArray3 = Array.isArray;
  function argsOrArgArray(args) {
    return args.length === 1 && isArray3(args[0]) ? args[0] : args;
  }

  // node_modules/rxjs/dist/esm5/internal/operators/filter.js
  function filter(predicate, thisArg) {
    return operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        return predicate.call(thisArg, value, index++) && subscriber.next(value);
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/observable/zip.js
  function zip() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var resultSelector = popResultSelector(args);
    var sources = argsOrArgArray(args);
    return sources.length ? new Observable(function(subscriber) {
      var buffers = sources.map(function() {
        return [];
      });
      var completed = sources.map(function() {
        return false;
      });
      subscriber.add(function() {
        buffers = completed = null;
      });
      var _loop_1 = function(sourceIndex2) {
        innerFrom(sources[sourceIndex2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
          buffers[sourceIndex2].push(value);
          if (buffers.every(function(buffer) {
            return buffer.length;
          })) {
            var result = buffers.map(function(buffer) {
              return buffer.shift();
            });
            subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray([], __read(result))) : result);
            if (buffers.some(function(buffer, i) {
              return !buffer.length && completed[i];
            })) {
              subscriber.complete();
            }
          }
        }, function() {
          completed[sourceIndex2] = true;
          !buffers[sourceIndex2].length && subscriber.complete();
        }));
      };
      for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
        _loop_1(sourceIndex);
      }
      return function() {
        buffers = completed = null;
      };
    }) : EMPTY;
  }

  // node_modules/rxjs/dist/esm5/internal/operators/audit.js
  function audit(durationSelector) {
    return operate(function(source, subscriber) {
      var hasValue = false;
      var lastValue = null;
      var durationSubscriber = null;
      var isComplete = false;
      var endDuration = function() {
        durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
        durationSubscriber = null;
        if (hasValue) {
          hasValue = false;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
        isComplete && subscriber.complete();
      };
      var cleanupDuration = function() {
        durationSubscriber = null;
        isComplete && subscriber.complete();
      };
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        lastValue = value;
        if (!durationSubscriber) {
          innerFrom(durationSelector(value)).subscribe(durationSubscriber = createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
        }
      }, function() {
        isComplete = true;
        (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/auditTime.js
  function auditTime(duration, scheduler) {
    if (scheduler === void 0) {
      scheduler = asyncScheduler;
    }
    return audit(function() {
      return timer(duration, scheduler);
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/bufferCount.js
  function bufferCount(bufferSize, startBufferEvery) {
    if (startBufferEvery === void 0) {
      startBufferEvery = null;
    }
    startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
    return operate(function(source, subscriber) {
      var buffers = [];
      var count = 0;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a, e_2, _b;
        var toEmit = null;
        if (count++ % startBufferEvery === 0) {
          buffers.push([]);
        }
        try {
          for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
            var buffer = buffers_1_1.value;
            buffer.push(value);
            if (bufferSize <= buffer.length) {
              toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
              toEmit.push(buffer);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        if (toEmit) {
          try {
            for (var toEmit_1 = __values(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
              var buffer = toEmit_1_1.value;
              arrRemove(buffers, buffer);
              subscriber.next(buffer);
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return)) _b.call(toEmit_1);
            } finally {
              if (e_2) throw e_2.error;
            }
          }
        }
      }, function() {
        var e_3, _a;
        try {
          for (var buffers_2 = __values(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
            var buffer = buffers_2_1.value;
            subscriber.next(buffer);
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return)) _a.call(buffers_2);
          } finally {
            if (e_3) throw e_3.error;
          }
        }
        subscriber.complete();
      }, void 0, function() {
        buffers = null;
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/catchError.js
  function catchError(selector3) {
    return operate(function(source, subscriber) {
      var innerSub = null;
      var syncUnsub = false;
      var handledResult;
      innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
        handledResult = innerFrom(selector3(err, catchError(selector3)(source)));
        if (innerSub) {
          innerSub.unsubscribe();
          innerSub = null;
          handledResult.subscribe(subscriber);
        } else {
          syncUnsub = true;
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      }
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/scanInternals.js
  function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
    return function(source, subscriber) {
      var hasState = hasSeed;
      var state = seed;
      var index = 0;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        var i = index++;
        state = hasState ? accumulator(state, value, i) : (hasState = true, value);
        emitOnNext && subscriber.next(state);
      }, emitBeforeComplete && function() {
        hasState && subscriber.next(state);
        subscriber.complete();
      }));
    };
  }

  // node_modules/rxjs/dist/esm5/internal/operators/combineLatest.js
  function combineLatest2() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var resultSelector = popResultSelector(args);
    return resultSelector ? pipe3(combineLatest2.apply(void 0, __spreadArray([], __read(args))), mapOneOrManyArgs(resultSelector)) : operate(function(source, subscriber) {
      combineLatestInit(__spreadArray([source], __read(argsOrArgArray(args))))(subscriber);
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/combineLatestWith.js
  function combineLatestWith() {
    var otherSources = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      otherSources[_i2] = arguments[_i2];
    }
    return combineLatest2.apply(void 0, __spreadArray([], __read(otherSources)));
  }

  // node_modules/rxjs/dist/esm5/internal/operators/debounce.js
  function debounce(durationSelector) {
    return operate(function(source, subscriber) {
      var hasValue = false;
      var lastValue = null;
      var durationSubscriber = null;
      var emit = function() {
        durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
        durationSubscriber = null;
        if (hasValue) {
          hasValue = false;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
      };
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
        hasValue = true;
        lastValue = value;
        durationSubscriber = createOperatorSubscriber(subscriber, emit, noop);
        innerFrom(durationSelector(value)).subscribe(durationSubscriber);
      }, function() {
        emit();
        subscriber.complete();
      }, void 0, function() {
        lastValue = durationSubscriber = null;
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/debounceTime.js
  function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) {
      scheduler = asyncScheduler;
    }
    return operate(function(source, subscriber) {
      var activeTask = null;
      var lastValue = null;
      var lastTime = null;
      var emit = function() {
        if (activeTask) {
          activeTask.unsubscribe();
          activeTask = null;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
      };
      function emitWhenIdle() {
        var targetTime = lastTime + dueTime;
        var now = scheduler.now();
        if (now < targetTime) {
          activeTask = this.schedule(void 0, targetTime - now);
          subscriber.add(activeTask);
          return;
        }
        emit();
      }
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        lastValue = value;
        lastTime = scheduler.now();
        if (!activeTask) {
          activeTask = scheduler.schedule(emitWhenIdle, dueTime);
          subscriber.add(activeTask);
        }
      }, function() {
        emit();
        subscriber.complete();
      }, void 0, function() {
        lastValue = activeTask = null;
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/defaultIfEmpty.js
  function defaultIfEmpty(defaultValue) {
    return operate(function(source, subscriber) {
      var hasValue = false;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        subscriber.next(value);
      }, function() {
        if (!hasValue) {
          subscriber.next(defaultValue);
        }
        subscriber.complete();
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/take.js
  function take(count) {
    return count <= 0 ? function() {
      return EMPTY;
    } : operate(function(source, subscriber) {
      var seen = 0;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (++seen <= count) {
          subscriber.next(value);
          if (count <= seen) {
            subscriber.complete();
          }
        }
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/ignoreElements.js
  function ignoreElements() {
    return operate(function(source, subscriber) {
      source.subscribe(createOperatorSubscriber(subscriber, noop));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/mapTo.js
  function mapTo(value) {
    return map(function() {
      return value;
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/delayWhen.js
  function delayWhen(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) {
      return function(source) {
        return concat(subscriptionDelay.pipe(take(1), ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
      };
    }
    return mergeMap(function(value, index) {
      return innerFrom(delayDurationSelector(value, index)).pipe(take(1), mapTo(value));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/delay.js
  function delay(due, scheduler) {
    if (scheduler === void 0) {
      scheduler = asyncScheduler;
    }
    var duration = timer(due, scheduler);
    return delayWhen(function() {
      return duration;
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js
  function distinctUntilChanged(comparator, keySelector) {
    if (keySelector === void 0) {
      keySelector = identity;
    }
    comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
    return operate(function(source, subscriber) {
      var previousKey;
      var first2 = true;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        var currentKey = keySelector(value);
        if (first2 || !comparator(previousKey, currentKey)) {
          first2 = false;
          previousKey = currentKey;
          subscriber.next(value);
        }
      }));
    });
  }
  function defaultCompare(a, b) {
    return a === b;
  }

  // node_modules/rxjs/dist/esm5/internal/operators/distinctUntilKeyChanged.js
  function distinctUntilKeyChanged(key, compare) {
    return distinctUntilChanged(function(x, y) {
      return compare ? compare(x[key], y[key]) : x[key] === y[key];
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/throwIfEmpty.js
  function throwIfEmpty(errorFactory) {
    if (errorFactory === void 0) {
      errorFactory = defaultErrorFactory;
    }
    return operate(function(source, subscriber) {
      var hasValue = false;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        subscriber.next(value);
      }, function() {
        return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
      }));
    });
  }
  function defaultErrorFactory() {
    return new EmptyError();
  }

  // node_modules/rxjs/dist/esm5/internal/operators/endWith.js
  function endWith() {
    var values = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      values[_i2] = arguments[_i2];
    }
    return function(source) {
      return concat(source, of.apply(void 0, __spreadArray([], __read(values))));
    };
  }

  // node_modules/rxjs/dist/esm5/internal/operators/finalize.js
  function finalize(callback) {
    return operate(function(source, subscriber) {
      try {
        source.subscribe(subscriber);
      } finally {
        subscriber.add(callback);
      }
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/first.js
  function first(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(predicate ? filter(function(v, i) {
        return predicate(v, i, source);
      }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
        return new EmptyError();
      }));
    };
  }

  // node_modules/rxjs/dist/esm5/internal/operators/takeLast.js
  function takeLast(count) {
    return count <= 0 ? function() {
      return EMPTY;
    } : operate(function(source, subscriber) {
      var buffer = [];
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        buffer.push(value);
        count < buffer.length && buffer.shift();
      }, function() {
        var e_1, _a;
        try {
          for (var buffer_1 = __values(buffer), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
            var value = buffer_1_1.value;
            subscriber.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return)) _a.call(buffer_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        subscriber.complete();
      }, void 0, function() {
        buffer = null;
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/merge.js
  function merge2() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var scheduler = popScheduler(args);
    var concurrent = popNumber(args, Infinity);
    args = argsOrArgArray(args);
    return operate(function(source, subscriber) {
      mergeAll(concurrent)(from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/mergeWith.js
  function mergeWith() {
    var otherSources = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      otherSources[_i2] = arguments[_i2];
    }
    return merge2.apply(void 0, __spreadArray([], __read(otherSources)));
  }

  // node_modules/rxjs/dist/esm5/internal/operators/repeat.js
  function repeat(countOrConfig) {
    var _a;
    var count = Infinity;
    var delay2;
    if (countOrConfig != null) {
      if (typeof countOrConfig === "object") {
        _a = countOrConfig.count, count = _a === void 0 ? Infinity : _a, delay2 = countOrConfig.delay;
      } else {
        count = countOrConfig;
      }
    }
    return count <= 0 ? function() {
      return EMPTY;
    } : operate(function(source, subscriber) {
      var soFar = 0;
      var sourceSub;
      var resubscribe = function() {
        sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
        sourceSub = null;
        if (delay2 != null) {
          var notifier = typeof delay2 === "number" ? timer(delay2) : innerFrom(delay2(soFar));
          var notifierSubscriber_1 = createOperatorSubscriber(subscriber, function() {
            notifierSubscriber_1.unsubscribe();
            subscribeToSource();
          });
          notifier.subscribe(notifierSubscriber_1);
        } else {
          subscribeToSource();
        }
      };
      var subscribeToSource = function() {
        var syncUnsub = false;
        sourceSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, function() {
          if (++soFar < count) {
            if (sourceSub) {
              resubscribe();
            } else {
              syncUnsub = true;
            }
          } else {
            subscriber.complete();
          }
        }));
        if (syncUnsub) {
          resubscribe();
        }
      };
      subscribeToSource();
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/scan.js
  function scan(accumulator, seed) {
    return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
  }

  // node_modules/rxjs/dist/esm5/internal/operators/share.js
  function share(options) {
    if (options === void 0) {
      options = {};
    }
    var _a = options.connector, connector = _a === void 0 ? function() {
      return new Subject();
    } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
    return function(wrapperSource) {
      var connection;
      var resetConnection;
      var subject;
      var refCount = 0;
      var hasCompleted = false;
      var hasErrored = false;
      var cancelReset = function() {
        resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
        resetConnection = void 0;
      };
      var reset = function() {
        cancelReset();
        connection = subject = void 0;
        hasCompleted = hasErrored = false;
      };
      var resetAndUnsubscribe = function() {
        var conn = connection;
        reset();
        conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
      };
      return operate(function(source, subscriber) {
        refCount++;
        if (!hasErrored && !hasCompleted) {
          cancelReset();
        }
        var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
        subscriber.add(function() {
          refCount--;
          if (refCount === 0 && !hasErrored && !hasCompleted) {
            resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
          }
        });
        dest.subscribe(subscriber);
        if (!connection && refCount > 0) {
          connection = new SafeSubscriber({
            next: function(value) {
              return dest.next(value);
            },
            error: function(err) {
              hasErrored = true;
              cancelReset();
              resetConnection = handleReset(reset, resetOnError, err);
              dest.error(err);
            },
            complete: function() {
              hasCompleted = true;
              cancelReset();
              resetConnection = handleReset(reset, resetOnComplete);
              dest.complete();
            }
          });
          innerFrom(source).subscribe(connection);
        }
      })(wrapperSource);
    };
  }
  function handleReset(reset, on) {
    var args = [];
    for (var _i2 = 2; _i2 < arguments.length; _i2++) {
      args[_i2 - 2] = arguments[_i2];
    }
    if (on === true) {
      reset();
      return;
    }
    if (on === false) {
      return;
    }
    var onSubscriber = new SafeSubscriber({
      next: function() {
        onSubscriber.unsubscribe();
        reset();
      }
    });
    return innerFrom(on.apply(void 0, __spreadArray([], __read(args)))).subscribe(onSubscriber);
  }

  // node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js
  function shareReplay(configOrBufferSize, windowTime, scheduler) {
    var _a, _b, _c;
    var bufferSize;
    var refCount = false;
    if (configOrBufferSize && typeof configOrBufferSize === "object") {
      _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
    } else {
      bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
    }
    return share({
      connector: function() {
        return new ReplaySubject(bufferSize, windowTime, scheduler);
      },
      resetOnError: true,
      resetOnComplete: false,
      resetOnRefCountZero: refCount
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/skip.js
  function skip(count) {
    return filter(function(_, index) {
      return count <= index;
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/skipUntil.js
  function skipUntil(notifier) {
    return operate(function(source, subscriber) {
      var taking = false;
      var skipSubscriber = createOperatorSubscriber(subscriber, function() {
        skipSubscriber === null || skipSubscriber === void 0 ? void 0 : skipSubscriber.unsubscribe();
        taking = true;
      }, noop);
      innerFrom(notifier).subscribe(skipSubscriber);
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        return taking && subscriber.next(value);
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/startWith.js
  function startWith() {
    var values = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      values[_i2] = arguments[_i2];
    }
    var scheduler = popScheduler(values);
    return operate(function(source, subscriber) {
      (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/switchMap.js
  function switchMap(project, resultSelector) {
    return operate(function(source, subscriber) {
      var innerSubscriber = null;
      var index = 0;
      var isComplete = false;
      var checkComplete = function() {
        return isComplete && !innerSubscriber && subscriber.complete();
      };
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
        var innerIndex = 0;
        var outerIndex = index++;
        innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
          return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
        }, function() {
          innerSubscriber = null;
          checkComplete();
        }));
      }, function() {
        isComplete = true;
        checkComplete();
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js
  function takeUntil(notifier) {
    return operate(function(source, subscriber) {
      innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
        return subscriber.complete();
      }, noop));
      !subscriber.closed && source.subscribe(subscriber);
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/takeWhile.js
  function takeWhile(predicate, inclusive) {
    if (inclusive === void 0) {
      inclusive = false;
    }
    return operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        var result = predicate(value, index++);
        (result || inclusive) && subscriber.next(value);
        !result && subscriber.complete();
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/tap.js
  function tap(observerOrNext, error, complete) {
    var tapObserver = isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
    return tapObserver ? operate(function(source, subscriber) {
      var _a;
      (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
      var isUnsub = true;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        var _a2;
        (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
        subscriber.next(value);
      }, function() {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
        subscriber.complete();
      }, function(err) {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
        subscriber.error(err);
      }, function() {
        var _a2, _b;
        if (isUnsub) {
          (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
        }
        (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
      }));
    }) : identity;
  }

  // node_modules/rxjs/dist/esm5/internal/operators/throttle.js
  function throttle(durationSelector, config6) {
    return operate(function(source, subscriber) {
      var _a = config6 !== null && config6 !== void 0 ? config6 : {}, _b = _a.leading, leading = _b === void 0 ? true : _b, _c = _a.trailing, trailing = _c === void 0 ? false : _c;
      var hasValue = false;
      var sendValue = null;
      var throttled = null;
      var isComplete = false;
      var endThrottling = function() {
        throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
        throttled = null;
        if (trailing) {
          send2();
          isComplete && subscriber.complete();
        }
      };
      var cleanupThrottling = function() {
        throttled = null;
        isComplete && subscriber.complete();
      };
      var startThrottle = function(value) {
        return throttled = innerFrom(durationSelector(value)).subscribe(createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
      };
      var send2 = function() {
        if (hasValue) {
          hasValue = false;
          var value = sendValue;
          sendValue = null;
          subscriber.next(value);
          !isComplete && startThrottle(value);
        }
      };
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        sendValue = value;
        !(throttled && !throttled.closed) && (leading ? send2() : startThrottle(value));
      }, function() {
        isComplete = true;
        !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/throttleTime.js
  function throttleTime(duration, scheduler, config6) {
    if (scheduler === void 0) {
      scheduler = asyncScheduler;
    }
    var duration$ = timer(duration, scheduler);
    return throttle(function() {
      return duration$;
    }, config6);
  }

  // node_modules/rxjs/dist/esm5/internal/operators/withLatestFrom.js
  function withLatestFrom() {
    var inputs = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      inputs[_i2] = arguments[_i2];
    }
    var project = popResultSelector(inputs);
    return operate(function(source, subscriber) {
      var len = inputs.length;
      var otherValues = new Array(len);
      var hasValue = inputs.map(function() {
        return false;
      });
      var ready = false;
      var _loop_1 = function(i2) {
        innerFrom(inputs[i2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
          otherValues[i2] = value;
          if (!ready && !hasValue[i2]) {
            hasValue[i2] = true;
            (ready = hasValue.every(identity)) && (hasValue = null);
          }
        }, noop));
      };
      for (var i = 0; i < len; i++) {
        _loop_1(i);
      }
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (ready) {
          var values = __spreadArray([value], __read(otherValues));
          subscriber.next(project ? project.apply(void 0, __spreadArray([], __read(values))) : values);
        }
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/zip.js
  function zip2() {
    var sources = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      sources[_i2] = arguments[_i2];
    }
    return operate(function(source, subscriber) {
      zip.apply(void 0, __spreadArray([source], __read(sources))).subscribe(subscriber);
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/zipWith.js
  function zipWith() {
    var otherInputs = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      otherInputs[_i2] = arguments[_i2];
    }
    return zip2.apply(void 0, __spreadArray([], __read(otherInputs)));
  }

  // external/mkdocs-material/src/templates/assets/javascripts/browser/document/index.ts
  function watchDocument() {
    const document$5 = new ReplaySubject(1);
    fromEvent(document, "DOMContentLoaded", { once: true }).subscribe(() => document$5.next(document));
    return document$5;
  }

  // external/mkdocs-material/src/templates/assets/javascripts/browser/element/_/index.ts
  function getElements(selector3, node = document) {
    return Array.from(node.querySelectorAll(selector3));
  }
  function getElement(selector3, node = document) {
    const el = getOptionalElement(selector3, node);
    if (typeof el === "undefined")
      throw new ReferenceError(
        `Missing element: expected "${selector3}" to be present`
      );
    return el;
  }
  function getOptionalElement(selector3, node = document) {
    return node.querySelector(selector3) || void 0;
  }
  function getActiveElement() {
    return document.activeElement?.shadowRoot?.activeElement ?? document.activeElement ?? void 0;
  }

  // external/mkdocs-material/src/templates/assets/javascripts/browser/element/focus/index.ts
  var observer$ = merge(
    fromEvent(document.body, "focusin"),
    fromEvent(document.body, "focusout")
  ).pipe(
    debounceTime(1),
    startWith(void 0),
    map(() => getActiveElement() || document.body),
    shareReplay(1)
  );
  function watchElementFocus(el) {
    return observer$.pipe(
      map((active) => el.contains(active)),
      distinctUntilChanged()
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/browser/element/hover/index.ts
  function watchElementHover(el, timeout) {
    return defer(
      () => merge(
        fromEvent(el, "mouseenter").pipe(map(() => true)),
        fromEvent(el, "mouseleave").pipe(map(() => false))
      ).pipe(
        timeout ? debounce((active) => timer(+!active * timeout)) : identity,
        startWith(el.matches(":hover"))
      )
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/utilities/h/index.ts
  function appendChild(el, child) {
    if (typeof child === "string" || typeof child === "number") {
      el.innerHTML += child.toString();
    } else if (child instanceof Node) {
      el.appendChild(child);
    } else if (Array.isArray(child)) {
      for (const node of child)
        appendChild(el, node);
    }
  }
  function h(tag, attributes, ...children) {
    const el = document.createElement(tag);
    if (attributes)
      for (const attr of Object.keys(attributes)) {
        if (typeof attributes[attr] === "undefined")
          continue;
        if (typeof attributes[attr] !== "boolean")
          el.setAttribute(attr, attributes[attr]);
        else
          el.setAttribute(attr, "");
      }
    for (const child of children)
      appendChild(el, child);
    return el;
  }

  // external/mkdocs-material/src/templates/assets/javascripts/utilities/round/index.ts
  function round(value) {
    if (value > 999) {
      const digits = +((value - 950) % 1e3 > 99);
      return `${((value + 1e-6) / 1e3).toFixed(digits)}k`;
    } else {
      return value.toString();
    }
  }

  // external/mkdocs-material/src/templates/assets/javascripts/browser/script/index.ts
  function watchScript(src) {
    const script2 = h("script", { src });
    return defer(() => {
      document.head.appendChild(script2);
      return merge(
        fromEvent(script2, "load"),
        fromEvent(script2, "error").pipe(
          switchMap(() => throwError(() => new ReferenceError(`Invalid script: ${src}`)))
        )
      ).pipe(
        map(() => void 0),
        finalize(() => document.head.removeChild(script2)),
        take(1)
      );
    });
  }

  // external/mkdocs-material/src/templates/assets/javascripts/browser/element/size/_/index.ts
  var entry$ = new Subject();
  var observer$2 = defer(() => typeof ResizeObserver === "undefined" ? watchScript("https://unpkg.com/resize-observer-polyfill") : of(void 0)).pipe(
    map(() => new ResizeObserver((entries) => entries.forEach((entry) => entry$.next(entry)))),
    switchMap((observer) => merge(NEVER, of(observer)).pipe(
      finalize(() => observer.disconnect())
    )),
    shareReplay(1)
  );
  function getElementSize(el) {
    return {
      width: el.offsetWidth,
      height: el.offsetHeight
    };
  }
  function watchElementSize(el) {
    let target = el;
    while (target.clientWidth === 0)
      if (target.parentElement)
        target = target.parentElement;
      else
        break;
    return observer$2.pipe(
      tap((observer) => observer.observe(target)),
      switchMap((observer) => entry$.pipe(
        filter((entry) => entry.target === target),
        finalize(() => observer.unobserve(target))
      )),
      map(() => getElementSize(el)),
      startWith(getElementSize(el))
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/browser/element/size/content/index.ts
  function getElementContentSize(el) {
    return {
      width: el.scrollWidth,
      height: el.scrollHeight
    };
  }
  function getElementContainer(el) {
    let parent = el.parentElement;
    while (parent)
      if (el.scrollWidth <= parent.scrollWidth && el.scrollHeight <= parent.scrollHeight)
        parent = (el = parent).parentElement;
      else
        break;
    return parent ? el : void 0;
  }
  function getElementContainers(el) {
    const containers = [];
    let parent = el.parentElement;
    while (parent) {
      if (el.clientWidth > parent.clientWidth || el.clientHeight > parent.clientHeight)
        containers.push(parent);
      parent = (el = parent).parentElement;
    }
    if (containers.length === 0)
      containers.push(document.documentElement);
    return containers;
  }

  // external/mkdocs-material/src/templates/assets/javascripts/browser/element/offset/_/index.ts
  function getElementOffset(el) {
    return {
      x: el.offsetLeft,
      y: el.offsetTop
    };
  }
  function getElementOffsetAbsolute(el) {
    const rect = el.getBoundingClientRect();
    return {
      x: rect.x + window.scrollX,
      y: rect.y + window.scrollY
    };
  }
  function watchElementOffset(el) {
    return merge(
      fromEvent(window, "load"),
      fromEvent(window, "resize")
    ).pipe(
      auditTime(0, animationFrameScheduler),
      map(() => getElementOffset(el)),
      startWith(getElementOffset(el))
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/browser/element/offset/content/index.ts
  function getElementContentOffset(el) {
    return {
      x: el.scrollLeft,
      y: el.scrollTop
    };
  }
  function watchElementContentOffset(el) {
    return merge(
      fromEvent(el, "scroll"),
      fromEvent(window, "scroll"),
      fromEvent(window, "resize")
    ).pipe(
      auditTime(0, animationFrameScheduler),
      map(() => getElementContentOffset(el)),
      startWith(getElementContentOffset(el))
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/browser/element/visibility/index.ts
  var entry$2 = new Subject();
  var observer$3 = defer(() => of(
    new IntersectionObserver((entries) => {
      for (const entry of entries)
        entry$2.next(entry);
    }, {
      threshold: 0
    })
  )).pipe(
    switchMap(
      (observer) => merge(NEVER, of(observer)).pipe(
        finalize(() => observer.disconnect())
      )
    ),
    shareReplay(1)
  );
  function watchElementVisibility(el) {
    return observer$3.pipe(
      tap((observer) => observer.observe(el)),
      switchMap(
        (observer) => entry$2.pipe(
          filter(({ target }) => target === el),
          finalize(() => observer.unobserve(el)),
          map(({ isIntersecting }) => isIntersecting)
        )
      )
    );
  }
  function watchElementBoundary(el, threshold = 16) {
    return watchElementContentOffset(el).pipe(
      map(({ y }) => {
        const visible = getElementSize(el);
        const content = getElementContentSize(el);
        return y >= content.height - visible.height - threshold;
      }),
      distinctUntilChanged()
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/browser/toggle/index.ts
  var toggles = {
    drawer: getElement("[data-md-toggle=drawer]"),
    search: getElement("[data-md-toggle=search]")
  };
  function getToggle(name) {
    return toggles[name].checked;
  }
  function setToggle(name, value) {
    if (toggles[name].checked !== value)
      toggles[name].click();
  }
  function watchToggle(name) {
    const el = toggles[name];
    return fromEvent(el, "change").pipe(
      map(() => el.checked),
      startWith(el.checked)
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/browser/keyboard/index.ts
  function isSusceptibleToKeyboard(el, type) {
    switch (el.constructor) {
      /* Input elements */
      case HTMLInputElement:
        if (el.type === "radio")
          return /^Arrow/.test(type);
        else
          return true;
      /* Select element and textarea */
      case HTMLSelectElement:
      case HTMLTextAreaElement:
        return true;
      /* Everything else */
      default:
        return el.isContentEditable;
    }
  }
  function watchComposition() {
    return merge(
      fromEvent(window, "compositionstart").pipe(map(() => true)),
      fromEvent(window, "compositionend").pipe(map(() => false))
    ).pipe(
      startWith(false)
    );
  }
  function watchKeyboard() {
    const keyboard$2 = fromEvent(window, "keydown").pipe(
      filter((ev) => !(ev.metaKey || ev.ctrlKey)),
      map((ev) => ({
        mode: getToggle("search") ? "search" : "global",
        type: ev.key,
        claim() {
          ev.preventDefault();
          ev.stopPropagation();
        }
      })),
      filter(({ mode, type }) => {
        if (mode === "global") {
          const active = getActiveElement();
          if (typeof active !== "undefined")
            return !isSusceptibleToKeyboard(active, type);
        }
        return true;
      }),
      share()
    );
    return watchComposition().pipe(
      switchMap((active) => !active ? keyboard$2 : EMPTY)
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/browser/location/_/index.ts
  function getLocation() {
    return new URL(location.href);
  }
  function setLocation(url2, navigate = false) {
    if (feature("navigation.instant") && !navigate) {
      const el = h("a", { href: url2.href });
      document.body.appendChild(el);
      el.click();
      el.remove();
    } else {
      location.href = url2.href;
    }
  }
  function watchLocation() {
    return new Subject();
  }

  // external/mkdocs-material/src/templates/assets/javascripts/browser/location/hash/index.ts
  function getLocationHash() {
    return location.hash.slice(1);
  }
  function setLocationHash(hash) {
    const el = h("a", { href: hash });
    el.addEventListener("click", (ev) => ev.stopPropagation());
    el.click();
  }
  function watchLocationHash(location$3) {
    return merge(
      fromEvent(window, "hashchange"),
      location$3
    ).pipe(
      map(getLocationHash),
      startWith(getLocationHash()),
      filter((hash) => hash.length > 0),
      shareReplay(1)
    );
  }
  function watchLocationTarget(location$3) {
    return watchLocationHash(location$3).pipe(
      map((id) => getOptionalElement(`[id="${id}"]`)),
      filter((el) => typeof el !== "undefined")
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/browser/media/index.ts
  function watchMedia(query) {
    const media = matchMedia(query);
    return fromEventPattern((next) => media.addListener(() => next(media.matches))).pipe(
      startWith(media.matches)
    );
  }
  function watchPrint() {
    const media = matchMedia("print");
    return merge(
      fromEvent(window, "beforeprint").pipe(map(() => true)),
      fromEvent(window, "afterprint").pipe(map(() => false))
    ).pipe(
      startWith(media.matches)
    );
  }
  function at(query$, factory) {
    return query$.pipe(
      switchMap((active) => active ? factory() : EMPTY)
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/browser/request/index.ts
  function request(url2, options) {
    return new Observable((observer) => {
      const req = new XMLHttpRequest();
      req.open("GET", `${url2}`);
      req.responseType = "blob";
      req.addEventListener("load", () => {
        if (req.status >= 200 && req.status < 300) {
          observer.next(req.response);
          observer.complete();
        } else {
          observer.error(new Error(req.statusText));
        }
      });
      req.addEventListener("error", () => {
        observer.error(new Error("Network error"));
      });
      req.addEventListener("abort", () => {
        observer.complete();
      });
      if (typeof options?.progress$ !== "undefined") {
        req.addEventListener("progress", (event) => {
          if (event.lengthComputable) {
            options.progress$.next(event.loaded / event.total * 100);
          } else {
            const length = req.getResponseHeader("Content-Length") ?? 0;
            options.progress$.next(event.loaded / +length * 100);
          }
        });
        options.progress$.next(5);
      }
      req.send();
      return () => req.abort();
    });
  }
  function requestJSON(url2, options) {
    return request(url2, options).pipe(
      switchMap((res) => res.text()),
      map((body) => JSON.parse(body)),
      shareReplay(1)
    );
  }
  function requestHTML(url2, options) {
    const dom = new DOMParser();
    return request(url2, options).pipe(
      switchMap((res) => res.text()),
      map((res) => dom.parseFromString(res, "text/html")),
      shareReplay(1)
    );
  }
  function requestXML(url2, options) {
    const dom = new DOMParser();
    return request(url2, options).pipe(
      switchMap((res) => res.text()),
      map((res) => dom.parseFromString(res, "text/xml")),
      shareReplay(1)
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/browser/viewport/offset/index.ts
  function getViewportOffset() {
    return {
      x: Math.max(0, scrollX),
      y: Math.max(0, scrollY)
    };
  }
  function watchViewportOffset() {
    return merge(
      fromEvent(window, "scroll", { passive: true }),
      fromEvent(window, "resize", { passive: true })
    ).pipe(
      map(getViewportOffset),
      startWith(getViewportOffset())
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/browser/viewport/size/index.ts
  function getViewportSize() {
    return {
      width: innerWidth,
      height: innerHeight
    };
  }
  function watchViewportSize() {
    return fromEvent(window, "resize", { passive: true }).pipe(
      map(getViewportSize),
      startWith(getViewportSize())
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/browser/viewport/_/index.ts
  function watchViewport() {
    return combineLatest([
      watchViewportOffset(),
      watchViewportSize()
    ]).pipe(
      map(([offset, size]) => ({ offset, size })),
      shareReplay(1)
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/browser/viewport/at/index.ts
  function watchViewportAt(el, { viewport$: viewport$5, header$: header$3 }) {
    const size$ = viewport$5.pipe(
      distinctUntilKeyChanged("size")
    );
    const offset$ = combineLatest([size$, header$3]).pipe(
      map(() => getElementOffset(el))
    );
    return combineLatest([header$3, viewport$5, offset$]).pipe(
      map(([{ height }, { offset, size }, { x, y }]) => ({
        offset: {
          x: offset.x - x,
          y: offset.y - y + height
        },
        size
      }))
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/browser/worker/index.ts
  function recv(worker2) {
    return fromEvent(worker2, "message", (ev) => ev.data);
  }
  function send(worker2) {
    const send$ = new Subject();
    send$.subscribe((data) => worker2.postMessage(data));
    return send$;
  }
  function watchWorker(url2, worker2 = new Worker(url2)) {
    const recv$ = recv(worker2);
    const send$ = send(worker2);
    const worker$ = new Subject();
    worker$.subscribe(send$);
    const done$ = send$.pipe(ignoreElements(), endWith(true));
    return worker$.pipe(
      ignoreElements(),
      mergeWith(recv$.pipe(takeUntil(done$))),
      share()
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/_/index.ts
  var script = getElement("#__config");
  var config4 = JSON.parse(script.textContent);
  config4.base = `${new URL(config4.base, getLocation())}`;
  function configuration() {
    return config4;
  }
  function feature(flag) {
    return config4.features.includes(flag);
  }
  function translation(key, value) {
    return typeof value !== "undefined" ? config4.translations[key].replace("#", value.toString()) : config4.translations[key];
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/_/index.ts
  function getComponentElement(type, node = document) {
    return getElement(`[data-md-component=${type}]`, node);
  }
  function getComponentElements(type, node = document) {
    return getElements(`[data-md-component=${type}]`, node);
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/announce/index.ts
  function watchAnnounce(el) {
    const button = getElement(".md-typeset > :first-child", el);
    return fromEvent(button, "click", { once: true }).pipe(
      map(() => getElement(".md-typeset", el)),
      map((content) => ({ hash: __md_hash(content.innerHTML) }))
    );
  }
  function mountAnnounce(el) {
    if (!feature("announce.dismiss") || !el.childElementCount)
      return EMPTY;
    if (!el.hidden) {
      const content = getElement(".md-typeset", el);
      if (__md_hash(content.innerHTML) === __md_get("__announce"))
        el.hidden = true;
    }
    return defer(() => {
      const push$ = new Subject();
      push$.subscribe(({ hash }) => {
        el.hidden = true;
        __md_set("__announce", hash);
      });
      return watchAnnounce(el).pipe(
        tap((state) => push$.next(state)),
        finalize(() => push$.complete()),
        map((state) => ({ ref: el, ...state }))
      );
    });
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/consent/index.ts
  function watchConsent(el, { target$: target$2 }) {
    return target$2.pipe(
      map((target) => ({ hidden: target !== el }))
    );
  }
  function mountConsent(el, options) {
    const internal$ = new Subject();
    internal$.subscribe(({ hidden }) => {
      el.hidden = hidden;
    });
    return watchConsent(el, options).pipe(
      tap((state) => internal$.next(state)),
      finalize(() => internal$.complete()),
      map((state) => ({ ref: el, ...state }))
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/templates/tooltip/index.tsx
  function renderTooltip(id, style) {
    if (style === "inline") {
      return /* @__PURE__ */ h("div", { class: "md-tooltip md-tooltip--inline", id, role: "tooltip" }, /* @__PURE__ */ h("div", { class: "md-tooltip__inner md-typeset" }));
    } else {
      return /* @__PURE__ */ h("div", { class: "md-tooltip", id, role: "tooltip" }, /* @__PURE__ */ h("div", { class: "md-tooltip__inner md-typeset" }));
    }
  }
  function renderInlineTooltip2(...children) {
    return /* @__PURE__ */ h("div", { class: "md-tooltip2", role: "tooltip" }, /* @__PURE__ */ h("div", { class: "md-tooltip2__inner md-typeset" }, children));
  }

  // external/mkdocs-material/src/templates/assets/javascripts/templates/annotation/index.tsx
  function renderAnnotation(id, prefix) {
    prefix = prefix ? `${prefix}_annotation_${id}` : void 0;
    if (prefix) {
      const anchor = prefix ? `#${prefix}` : void 0;
      return /* @__PURE__ */ h("aside", { class: "md-annotation", tabIndex: 0 }, renderTooltip(prefix), /* @__PURE__ */ h("a", { href: anchor, class: "md-annotation__index", tabIndex: -1 }, /* @__PURE__ */ h("span", { "data-md-annotation-id": id })));
    } else {
      return /* @__PURE__ */ h("aside", { class: "md-annotation", tabIndex: 0 }, renderTooltip(prefix), /* @__PURE__ */ h("span", { class: "md-annotation__index", tabIndex: -1 }, /* @__PURE__ */ h("span", { "data-md-annotation-id": id })));
    }
  }

  // external/mkdocs-material/src/templates/assets/javascripts/templates/clipboard/index.tsx
  function renderClipboardButton(id) {
    return /* @__PURE__ */ h(
      "button",
      {
        class: "md-clipboard md-icon",
        title: translation("clipboard.copy"),
        "data-clipboard-target": `#${id} > code`
      }
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/templates/search/index.tsx
  var import_escape_html = __toESM(require_escape_html());
  function renderSearchDocument(document2, flag) {
    const parent = flag & 2 /* PARENT */;
    const teaser = flag & 1 /* TEASER */;
    const missing = Object.keys(document2.terms).filter((key) => !document2.terms[key]).reduce((list, key) => [
      ...list,
      /* @__PURE__ */ h("del", null, (0, import_escape_html.default)(key)),
      " "
    ], []).slice(0, -1);
    const config6 = configuration();
    const url2 = new URL(document2.location, config6.base);
    if (feature("search.highlight"))
      url2.searchParams.set(
        "h",
        Object.entries(document2.terms).filter(([, match]) => match).reduce((highlight2, [value]) => `${highlight2} ${value}`.trim(), "")
      );
    const { tags } = configuration();
    return /* @__PURE__ */ h("a", { href: `${url2}`, class: "md-search-result__link", tabIndex: -1 }, /* @__PURE__ */ h(
      "article",
      {
        class: "md-search-result__article md-typeset",
        "data-md-score": document2.score.toFixed(2)
      },
      parent > 0 && /* @__PURE__ */ h("div", { class: "md-search-result__icon md-icon" }),
      parent > 0 && /* @__PURE__ */ h("h1", null, document2.title),
      parent <= 0 && /* @__PURE__ */ h("h2", null, document2.title),
      teaser > 0 && document2.text.length > 0 && document2.text,
      document2.tags && /* @__PURE__ */ h("nav", { class: "md-tags" }, document2.tags.map((tag) => {
        const type = tags ? tag in tags ? `md-tag-icon md-tag--${tags[tag]}` : "md-tag-icon" : "";
        return /* @__PURE__ */ h("span", { class: `md-tag ${type}` }, tag);
      })),
      teaser > 0 && missing.length > 0 && /* @__PURE__ */ h("p", { class: "md-search-result__terms" }, translation("search.result.term.missing"), ": ", ...missing)
    ));
  }
  function renderSearchResultItem(result) {
    const threshold = result[0].score;
    const docs = [...result];
    const config6 = configuration();
    const parent = docs.findIndex((doc) => {
      const l = `${new URL(doc.location, config6.base)}`;
      return !l.includes("#");
    });
    const [article] = docs.splice(parent, 1);
    let index = docs.findIndex((doc) => doc.score < threshold);
    if (index === -1)
      index = docs.length;
    const best = docs.slice(0, index);
    const more = docs.slice(index);
    const children = [
      renderSearchDocument(article, 2 /* PARENT */ | +(!parent && index === 0)),
      ...best.map((section) => renderSearchDocument(section, 1 /* TEASER */)),
      ...more.length ? [
        /* @__PURE__ */ h("details", { class: "md-search-result__more" }, /* @__PURE__ */ h("summary", { tabIndex: -1 }, /* @__PURE__ */ h("div", null, more.length > 0 && more.length === 1 ? translation("search.result.more.one") : translation("search.result.more.other", more.length))), ...more.map((section) => renderSearchDocument(section, 1 /* TEASER */)))
      ] : []
    ];
    return /* @__PURE__ */ h("li", { class: "md-search-result__item" }, children);
  }

  // external/mkdocs-material/src/templates/assets/javascripts/templates/source/index.tsx
  function renderSourceFacts(facts) {
    return /* @__PURE__ */ h("ul", { class: "md-source__facts" }, Object.entries(facts).map(([key, value]) => /* @__PURE__ */ h("li", { class: `md-source__fact md-source__fact--${key}` }, typeof value === "number" ? round(value) : value)));
  }

  // external/mkdocs-material/src/templates/assets/javascripts/templates/tabbed/index.tsx
  function renderTabbedControl(type) {
    const classes = `tabbed-control tabbed-control--${type}`;
    return /* @__PURE__ */ h("div", { class: classes, hidden: true }, /* @__PURE__ */ h("button", { class: "tabbed-button", tabIndex: -1, "aria-hidden": "true" }));
  }

  // external/mkdocs-material/src/templates/assets/javascripts/templates/table/index.tsx
  function renderTable(table) {
    return /* @__PURE__ */ h("div", { class: "md-typeset__scrollwrap" }, /* @__PURE__ */ h("div", { class: "md-typeset__table" }, table));
  }

  // external/mkdocs-material/src/templates/assets/javascripts/templates/version/index.tsx
  function renderVersion(version) {
    const config6 = configuration();
    const url2 = new URL(`../${version.version}/`, config6.base);
    return /* @__PURE__ */ h("li", { class: "md-version__item" }, /* @__PURE__ */ h("a", { href: `${url2}`, class: "md-version__link" }, version.title, config6.version?.alias && version.aliases.length > 0 && /* @__PURE__ */ h("span", { class: "md-version__alias" }, version.aliases[0])));
  }
  function renderVersionSelector(versions, active) {
    const config6 = configuration();
    versions = versions.filter((version) => !version.properties?.hidden);
    return /* @__PURE__ */ h("div", { class: "md-version" }, /* @__PURE__ */ h(
      "button",
      {
        class: "md-version__current",
        "aria-label": translation("select.version")
      },
      active.title,
      config6.version?.alias && active.aliases.length > 0 && /* @__PURE__ */ h("span", { class: "md-version__alias" }, active.aliases[0])
    ), /* @__PURE__ */ h("ul", { class: "md-version__list" }, versions.map(renderVersion)));
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/tooltip2/index.ts
  var sequence = 0;
  function watchTooltip2(el) {
    const active$ = combineLatest([
      watchElementFocus(el),
      watchElementHover(el)
    ]).pipe(
      map(([focus, hover]) => focus || hover),
      distinctUntilChanged()
    );
    const offset$ = defer(() => getElementContainers(el)).pipe(
      mergeMap(watchElementContentOffset),
      throttleTime(1),
      // Note that we need to poll the value again if the active state changes,
      // as otherwise the tooltip might be misplaced. This particularly happens
      // when using third-party integrations like tablesort that change the
      // position of elements  see https://t.ly/Y-V7X
      combineLatestWith(active$),
      map(() => getElementOffsetAbsolute(el))
    );
    return active$.pipe(
      first((active) => active),
      switchMap(() => combineLatest([active$, offset$])),
      map(([active, offset]) => ({ active, offset })),
      share()
    );
  }
  function mountTooltip2(el, dependencies) {
    const { content$: content$2, viewport$: viewport$5 } = dependencies;
    const id = `__tooltip2_${sequence++}`;
    return defer(() => {
      const push$ = new Subject();
      const show$ = new BehaviorSubject(false);
      push$.pipe(ignoreElements(), endWith(false)).subscribe(show$);
      const node$ = show$.pipe(
        debounce((active) => timer(+!active * 250, queueScheduler)),
        distinctUntilChanged(),
        switchMap((active) => active ? content$2 : EMPTY),
        tap((node) => node.id = id),
        share()
      );
      combineLatest([
        push$.pipe(map(({ active }) => active)),
        node$.pipe(
          switchMap((node) => watchElementHover(node, 250)),
          startWith(false)
        )
      ]).pipe(map((states) => states.some((active) => active))).subscribe(show$);
      const origin$ = show$.pipe(
        filter((active) => active),
        withLatestFrom(node$, viewport$5),
        map(([_, node, { size }]) => {
          const host = el.getBoundingClientRect();
          const x = host.width / 2;
          if (node.role === "tooltip") {
            return { x, y: 8 + host.height };
          } else if (host.y >= size.height / 2) {
            const { height } = getElementSize(node);
            return { x, y: -16 - height };
          } else {
            return { x, y: 16 + host.height };
          }
        })
      );
      combineLatest([node$, push$, origin$]).subscribe(([node, { offset }, origin]) => {
        node.style.setProperty("--md-tooltip-host-x", `${offset.x}px`);
        node.style.setProperty("--md-tooltip-host-y", `${offset.y}px`);
        node.style.setProperty("--md-tooltip-x", `${origin.x}px`);
        node.style.setProperty("--md-tooltip-y", `${origin.y}px`);
        node.classList.toggle("md-tooltip2--top", origin.y < 0);
        node.classList.toggle("md-tooltip2--bottom", origin.y >= 0);
      });
      show$.pipe(
        filter((active) => active),
        withLatestFrom(node$, (_, node) => node),
        filter((node) => node.role === "tooltip")
      ).subscribe((node) => {
        const size = getElementSize(getElement(":scope > *", node));
        node.style.setProperty("--md-tooltip-width", `${size.width}px`);
        node.style.setProperty("--md-tooltip-tail", `${0}px`);
      });
      show$.pipe(
        distinctUntilChanged(),
        observeOn(animationFrameScheduler),
        withLatestFrom(node$)
      ).subscribe(([active, node]) => {
        node.classList.toggle("md-tooltip2--active", active);
      });
      combineLatest([
        show$.pipe(filter((active) => active)),
        node$
      ]).subscribe(([_, node]) => {
        if (node.role === "dialog") {
          el.setAttribute("aria-controls", id);
          el.setAttribute("aria-haspopup", "dialog");
        } else {
          el.setAttribute("aria-describedby", id);
        }
      });
      show$.pipe(filter((active) => !active)).subscribe(() => {
        el.removeAttribute("aria-controls");
        el.removeAttribute("aria-describedby");
        el.removeAttribute("aria-haspopup");
      });
      return watchTooltip2(el).pipe(
        tap((state) => push$.next(state)),
        finalize(() => push$.complete()),
        map((state) => ({ ref: el, ...state }))
      );
    });
  }
  function mountInlineTooltip2(el, { viewport$: viewport$5 }, container = document.body) {
    return mountTooltip2(el, {
      content$: new Observable((observer) => {
        const title = el.title;
        const node = renderInlineTooltip2(title);
        observer.next(node);
        el.removeAttribute("title");
        container.append(node);
        return () => {
          node.remove();
          el.setAttribute("title", title);
        };
      }),
      viewport$: viewport$5
    });
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/content/annotation/_/index.ts
  function watchAnnotation(el, container) {
    const offset$ = defer(() => combineLatest([
      watchElementOffset(el),
      watchElementContentOffset(container)
    ])).pipe(
      map(([{ x, y }, scroll]) => {
        const { width, height } = getElementSize(el);
        return {
          x: x - scroll.x + width / 2,
          y: y - scroll.y + height / 2
        };
      })
    );
    return watchElementFocus(el).pipe(
      switchMap(
        (active) => offset$.pipe(
          map((offset) => ({ active, offset })),
          take(+!active || Infinity)
        )
      )
    );
  }
  function mountAnnotation(el, container, { target$: target$2 }) {
    const [tooltip, index] = Array.from(el.children);
    return defer(() => {
      const push$ = new Subject();
      const done$ = push$.pipe(ignoreElements(), endWith(true));
      push$.subscribe({
        /* Handle emission */
        next({ offset }) {
          el.style.setProperty("--md-tooltip-x", `${offset.x}px`);
          el.style.setProperty("--md-tooltip-y", `${offset.y}px`);
        },
        /* Handle complete */
        complete() {
          el.style.removeProperty("--md-tooltip-x");
          el.style.removeProperty("--md-tooltip-y");
        }
      });
      watchElementVisibility(el).pipe(
        takeUntil(done$)
      ).subscribe((visible) => {
        el.toggleAttribute("data-md-visible", visible);
      });
      merge(
        push$.pipe(filter(({ active }) => active)),
        push$.pipe(debounceTime(250), filter(({ active }) => !active))
      ).subscribe({
        /* Handle emission */
        next({ active }) {
          if (active)
            el.prepend(tooltip);
          else
            tooltip.remove();
        },
        /* Handle complete */
        complete() {
          el.prepend(tooltip);
        }
      });
      push$.pipe(
        auditTime(16, animationFrameScheduler)
      ).subscribe(({ active }) => {
        tooltip.classList.toggle("md-tooltip--active", active);
      });
      push$.pipe(
        throttleTime(125, animationFrameScheduler),
        filter(() => !!el.offsetParent),
        map(() => el.offsetParent.getBoundingClientRect()),
        map(({ x }) => x)
      ).subscribe({
        /* Handle emission */
        next(origin) {
          if (origin)
            el.style.setProperty("--md-tooltip-0", `${-origin}px`);
          else
            el.style.removeProperty("--md-tooltip-0");
        },
        /* Handle complete */
        complete() {
          el.style.removeProperty("--md-tooltip-0");
        }
      });
      fromEvent(index, "click").pipe(
        takeUntil(done$),
        filter((ev) => !(ev.metaKey || ev.ctrlKey))
      ).subscribe((ev) => {
        ev.stopPropagation();
        ev.preventDefault();
      });
      fromEvent(index, "mousedown").pipe(
        takeUntil(done$),
        withLatestFrom(push$)
      ).subscribe(([ev, { active }]) => {
        if (ev.button !== 0 || ev.metaKey || ev.ctrlKey) {
          ev.preventDefault();
        } else if (active) {
          ev.preventDefault();
          const parent = el.parentElement.closest(".md-annotation");
          if (parent instanceof HTMLElement)
            parent.focus();
          else
            getActiveElement()?.blur();
        }
      });
      target$2.pipe(
        takeUntil(done$),
        filter((target) => target === tooltip),
        delay(125)
      ).subscribe(() => el.focus());
      return watchAnnotation(el, container).pipe(
        tap((state) => push$.next(state)),
        finalize(() => push$.complete()),
        map((state) => ({ ref: el, ...state }))
      );
    });
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/content/annotation/list/index.ts
  function findHosts(container) {
    return container.tagName === "CODE" ? getElements(".c, .c1, .cm", container) : [container];
  }
  function findMarkers(container) {
    const markers = [];
    for (const el of findHosts(container)) {
      const nodes = [];
      const it = document.createNodeIterator(el, NodeFilter.SHOW_TEXT);
      for (let node = it.nextNode(); node; node = it.nextNode())
        nodes.push(node);
      for (let text of nodes) {
        let match;
        while (match = /(\(\d+\))(!)?/.exec(text.textContent)) {
          const [, id, force] = match;
          if (typeof force === "undefined") {
            const marker = text.splitText(match.index);
            text = marker.splitText(id.length);
            markers.push(marker);
          } else {
            text.textContent = id;
            markers.push(text);
            break;
          }
        }
      }
    }
    return markers;
  }
  function swap(source, target) {
    target.append(...Array.from(source.childNodes));
  }
  function mountAnnotationList(el, container, { target$: target$2, print$: print$2 }) {
    const parent = container.closest("[id]");
    const prefix = parent?.id;
    const annotations = /* @__PURE__ */ new Map();
    for (const marker of findMarkers(container)) {
      const [, id] = marker.textContent.match(/\((\d+)\)/);
      if (getOptionalElement(`:scope > li:nth-child(${id})`, el)) {
        annotations.set(id, renderAnnotation(id, prefix));
        marker.replaceWith(annotations.get(id));
      }
    }
    if (annotations.size === 0)
      return EMPTY;
    return defer(() => {
      const push$ = new Subject();
      const done$ = push$.pipe(ignoreElements(), endWith(true));
      const pairs = [];
      for (const [id, annotation] of annotations)
        pairs.push([
          getElement(".md-typeset", annotation),
          getElement(`:scope > li:nth-child(${id})`, el)
        ]);
      print$2.pipe(takeUntil(done$)).subscribe((active) => {
        el.hidden = !active;
        el.classList.toggle("md-annotation-list", active);
        for (const [inner, child] of pairs)
          if (!active)
            swap(child, inner);
          else
            swap(inner, child);
      });
      return merge(
        ...[...annotations].map(([, annotation]) => mountAnnotation(annotation, container, { target$: target$2 }))
      ).pipe(
        finalize(() => push$.complete()),
        share()
      );
    });
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/content/annotation/block/index.ts
  function findList(el) {
    if (el.nextElementSibling) {
      const sibling = el.nextElementSibling;
      if (sibling.tagName === "OL")
        return sibling;
      else if (sibling.tagName === "P" && !sibling.children.length)
        return findList(sibling);
    }
    return void 0;
  }
  function mountAnnotationBlock(el, options) {
    return defer(() => {
      const list = findList(el);
      return typeof list !== "undefined" ? mountAnnotationList(list, el, options) : EMPTY;
    });
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/content/code/_/index.ts
  var import_clipboard = __toESM(require_clipboard());
  var sequence2 = 0;
  function findCandidateList(el) {
    if (el.nextElementSibling) {
      const sibling = el.nextElementSibling;
      if (sibling.tagName === "OL")
        return sibling;
      else if (sibling.tagName === "P" && !sibling.children.length)
        return findCandidateList(sibling);
    }
    return void 0;
  }
  function watchCodeBlock(el) {
    return watchElementSize(el).pipe(
      map(({ width }) => {
        const content = getElementContentSize(el);
        return {
          scrollable: content.width > width
        };
      }),
      distinctUntilKeyChanged("scrollable")
    );
  }
  function mountCodeBlock(el, options) {
    const { matches: hover } = matchMedia("(hover)");
    const factory$ = defer(() => {
      const push$ = new Subject();
      const done$ = push$.pipe(takeLast(1));
      push$.subscribe(({ scrollable }) => {
        if (scrollable && hover)
          el.setAttribute("tabindex", "0");
        else
          el.removeAttribute("tabindex");
      });
      const content$2 = [];
      if (import_clipboard.default.isSupported()) {
        if (el.closest(".copy") || feature("content.code.copy") && !el.closest(".no-copy")) {
          const parent = el.closest("pre");
          parent.id = `__code_${sequence2++}`;
          const button = renderClipboardButton(parent.id);
          parent.insertBefore(button, el);
          if (feature("content.tooltips"))
            content$2.push(mountInlineTooltip2(button, { viewport$ }));
        }
      }
      const container = el.closest(".highlight");
      if (container instanceof HTMLElement) {
        const list = findCandidateList(container);
        if (typeof list !== "undefined" && (container.classList.contains("annotate") || feature("content.code.annotate"))) {
          const annotations$ = mountAnnotationList(list, el, options);
          content$2.push(
            watchElementSize(container).pipe(
              takeUntil(done$),
              map(({ width, height }) => width && height),
              distinctUntilChanged(),
              switchMap((active) => active ? annotations$ : EMPTY)
            )
          );
        }
      }
      const spans = getElements(":scope > span[id]", el);
      if (spans.length)
        el.classList.add("md-code__content");
      return watchCodeBlock(el).pipe(
        tap((state) => push$.next(state)),
        finalize(() => push$.complete()),
        map((state) => ({ ref: el, ...state })),
        mergeWith(...content$2)
      );
    });
    if (feature("content.lazy"))
      return watchElementVisibility(el).pipe(
        filter((visible) => visible),
        take(1),
        switchMap(() => factory$)
      );
    return factory$;
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/content/details/index.ts
  function watchDetails(el, { target$: target$2, print$: print$2 }) {
    let open = true;
    return merge(
      /* Open and focus details on location target */
      target$2.pipe(
        map((target) => target.closest("details:not([open])")),
        filter((details) => el === details),
        map(() => ({
          action: "open",
          reveal: true
        }))
      ),
      /* Open details on print and close afterwards */
      print$2.pipe(
        filter((active) => active || !open),
        tap(() => open = el.open),
        map((active) => ({
          action: active ? "open" : "close"
        }))
      )
    );
  }
  function mountDetails(el, options) {
    return defer(() => {
      const push$ = new Subject();
      push$.subscribe(({ action, reveal }) => {
        el.toggleAttribute("open", action === "open");
        if (reveal)
          el.scrollIntoView();
      });
      return watchDetails(el, options).pipe(
        tap((state) => push$.next(state)),
        finalize(() => push$.complete()),
        map((state) => ({ ref: el, ...state }))
      );
    });
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/content/mermaid/index.css
  var mermaid_default = {};

  // external/mkdocs-material/src/templates/assets/javascripts/components/content/mermaid/index.ts
  var mermaid$;
  var sequence3 = 0;
  function fetchScripts() {
    return typeof mermaid === "undefined" || mermaid instanceof Element ? watchScript("https://unpkg.com/mermaid@11/dist/mermaid.min.js") : of(void 0);
  }
  function mountMermaid(el) {
    el.classList.remove("mermaid");
    mermaid$ || (mermaid$ = fetchScripts().pipe(
      tap(() => mermaid.initialize({
        startOnLoad: false,
        themeCSS: mermaid_default,
        sequence: {
          actorFontSize: "16px",
          // Hack: mitigate https://bit.ly/3y0NEi3
          messageFontSize: "16px",
          noteFontSize: "16px"
        }
      })),
      map(() => void 0),
      shareReplay(1)
    ));
    mermaid$.subscribe(async () => {
      el.classList.add("mermaid");
      const id = `__mermaid_${sequence3++}`;
      const host = h("div", { class: "mermaid" });
      const text = el.textContent;
      const { svg, fn } = await mermaid.render(id, text);
      const shadow = host.attachShadow({ mode: "closed" });
      shadow.innerHTML = svg;
      el.replaceWith(host);
      fn?.(shadow);
    });
    return mermaid$.pipe(
      map(() => ({ ref: el }))
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/content/table/index.ts
  var sentinel = h("table");
  function mountDataTable(el) {
    el.replaceWith(sentinel);
    sentinel.replaceWith(renderTable(el));
    return of({ ref: el });
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/content/tabs/index.ts
  function watchContentTabs(inputs) {
    const initial = inputs.find((input) => input.checked) || inputs[0];
    return merge(...inputs.map(
      (input) => fromEvent(input, "change").pipe(
        map(() => getElement(`label[for="${input.id}"]`))
      )
    )).pipe(
      startWith(getElement(`label[for="${initial.id}"]`)),
      map((active) => ({ active }))
    );
  }
  function mountContentTabs(el, { viewport$: viewport$5, target$: target$2 }) {
    const container = getElement(".tabbed-labels", el);
    const inputs = getElements(":scope > input", el);
    const prev = renderTabbedControl("prev");
    el.append(prev);
    const next = renderTabbedControl("next");
    el.append(next);
    return defer(() => {
      const push$ = new Subject();
      const done$ = push$.pipe(ignoreElements(), endWith(true));
      combineLatest([push$, watchElementSize(el), watchElementVisibility(el)]).pipe(
        takeUntil(done$),
        auditTime(1, animationFrameScheduler)
      ).subscribe({
        /* Handle emission */
        next([{ active }, size]) {
          const offset = getElementOffset(active);
          const { width } = getElementSize(active);
          el.style.setProperty("--md-indicator-x", `${offset.x}px`);
          el.style.setProperty("--md-indicator-width", `${width}px`);
          const content = getElementContentOffset(container);
          if (offset.x < content.x || offset.x + width > content.x + size.width)
            container.scrollTo({
              left: Math.max(0, offset.x - 16),
              behavior: "smooth"
            });
        },
        /* Handle complete */
        complete() {
          el.style.removeProperty("--md-indicator-x");
          el.style.removeProperty("--md-indicator-width");
        }
      });
      combineLatest([
        watchElementContentOffset(container),
        watchElementSize(container)
      ]).pipe(
        takeUntil(done$)
      ).subscribe(([offset, size]) => {
        const content = getElementContentSize(container);
        prev.hidden = offset.x < 16;
        next.hidden = offset.x > content.width - size.width - 16;
      });
      merge(
        fromEvent(prev, "click").pipe(map(() => -1)),
        fromEvent(next, "click").pipe(map(() => 1))
      ).pipe(
        takeUntil(done$)
      ).subscribe((direction) => {
        const { width } = getElementSize(container);
        container.scrollBy({
          left: width * direction,
          behavior: "smooth"
        });
      });
      target$2.pipe(
        takeUntil(done$),
        filter((input) => inputs.includes(input))
      ).subscribe((input) => input.click());
      container.classList.add("tabbed-labels--linked");
      for (const input of inputs) {
        const label = getElement(`label[for="${input.id}"]`);
        label.replaceChildren(h("a", {
          href: `#${label.htmlFor}`,
          tabIndex: -1
        }, ...Array.from(label.childNodes)));
        fromEvent(label.firstElementChild, "click").pipe(
          takeUntil(done$),
          filter((ev) => !(ev.metaKey || ev.ctrlKey)),
          tap((ev) => {
            ev.preventDefault();
            ev.stopPropagation();
          })
        ).subscribe(() => {
          history.replaceState({}, "", `#${label.htmlFor}`);
          label.click();
        });
      }
      if (feature("content.tabs.link"))
        push$.pipe(
          skip(1),
          withLatestFrom(viewport$5)
        ).subscribe(([{ active }, { offset }]) => {
          const tab = active.innerText.trim();
          if (active.hasAttribute("data-md-switching")) {
            active.removeAttribute("data-md-switching");
          } else {
            const y = el.offsetTop - offset.y;
            for (const set of getElements("[data-tabs]"))
              for (const input of getElements(
                ":scope > input",
                set
              )) {
                const label = getElement(`label[for="${input.id}"]`);
                if (label !== active && label.innerText.trim() === tab) {
                  label.setAttribute("data-md-switching", "");
                  input.click();
                  break;
                }
              }
            window.scrollTo({
              top: el.offsetTop - y
            });
            const tabs = __md_get("__tabs") || [];
            __md_set("__tabs", [.../* @__PURE__ */ new Set([tab, ...tabs])]);
          }
        });
      push$.pipe(takeUntil(done$)).subscribe(() => {
        for (const media of getElements("audio, video", el))
          media.pause();
      });
      return watchContentTabs(inputs).pipe(
        tap((state) => push$.next(state)),
        finalize(() => push$.complete()),
        map((state) => ({ ref: el, ...state }))
      );
    }).pipe(
      subscribeOn(asyncScheduler)
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/content/_/index.ts
  function mountContent(el, { viewport$: viewport$5, target$: target$2, print$: print$2 }) {
    return merge(
      ...getElements(".annotate:not(.highlight)", el).map((child) => mountAnnotationBlock(child, { target$: target$2, print$: print$2 })),
      ...getElements("pre:not(.mermaid) > code", el).map((child) => mountCodeBlock(child, { target$: target$2, print$: print$2 })),
      ...getElements("pre.mermaid", el).map((child) => mountMermaid(child)),
      ...getElements("table:not([class])", el).map((child) => mountDataTable(child)),
      ...getElements("details", el).map((child) => mountDetails(child, { target$: target$2, print$: print$2 })),
      ...getElements("[data-tabs]", el).map((child) => mountContentTabs(child, { viewport$: viewport$5, target$: target$2 })),
      ...getElements("[title]", el).filter(() => feature("content.tooltips")).map((child) => mountInlineTooltip2(child, { viewport$: viewport$5 }))
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/dialog/index.ts
  function watchDialog(_el, { alert$: alert$2 }) {
    return alert$2.pipe(
      switchMap(
        (message) => merge(
          of(true),
          of(false).pipe(delay(2e3))
        ).pipe(
          map((active) => ({ message, active }))
        )
      )
    );
  }
  function mountDialog(el, options) {
    const inner = getElement(".md-typeset", el);
    return defer(() => {
      const push$ = new Subject();
      push$.subscribe(({ message, active }) => {
        el.classList.toggle("md-dialog--active", active);
        inner.textContent = message;
      });
      return watchDialog(el, options).pipe(
        tap((state) => push$.next(state)),
        finalize(() => push$.complete()),
        map((state) => ({ ref: el, ...state }))
      );
    });
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/tooltip/index.ts
  var sequence4 = 0;
  function watchTooltip(el, host) {
    document.body.append(el);
    const { width } = getElementSize(el);
    el.style.setProperty("--md-tooltip-width", `${width}px`);
    el.remove();
    const container = getElementContainer(host);
    const scroll$ = typeof container !== "undefined" ? watchElementContentOffset(container) : of({ x: 0, y: 0 });
    const active$ = merge(
      watchElementFocus(host),
      watchElementHover(host)
    ).pipe(
      distinctUntilChanged()
    );
    return combineLatest([active$, scroll$]).pipe(
      map(([active, scroll]) => {
        let { x, y } = getElementOffset(host);
        const size = getElementSize(host);
        const table = host.closest("table");
        if (table && host.parentElement) {
          x += table.offsetLeft + host.parentElement.offsetLeft;
          y += table.offsetTop + host.parentElement.offsetTop;
        }
        return {
          active,
          offset: {
            x: x - scroll.x + size.width / 2 - width / 2,
            y: y - scroll.y + size.height + 8
          }
        };
      })
    );
  }
  function mountTooltip(el) {
    const title = el.title;
    if (!title.length)
      return EMPTY;
    const id = `__tooltip_${sequence4++}`;
    const tooltip = renderTooltip(id, "inline");
    const typeset = getElement(".md-typeset", tooltip);
    typeset.innerHTML = title;
    return defer(() => {
      const push$ = new Subject();
      push$.subscribe({
        /* Handle emission */
        next({ offset }) {
          tooltip.style.setProperty("--md-tooltip-x", `${offset.x}px`);
          tooltip.style.setProperty("--md-tooltip-y", `${offset.y}px`);
        },
        /* Handle complete */
        complete() {
          tooltip.style.removeProperty("--md-tooltip-x");
          tooltip.style.removeProperty("--md-tooltip-y");
        }
      });
      merge(
        push$.pipe(filter(({ active }) => active)),
        push$.pipe(debounceTime(250), filter(({ active }) => !active))
      ).subscribe({
        /* Handle emission */
        next({ active }) {
          if (active) {
            el.insertAdjacentElement("afterend", tooltip);
            el.setAttribute("aria-describedby", id);
            el.removeAttribute("title");
          } else {
            tooltip.remove();
            el.removeAttribute("aria-describedby");
            el.setAttribute("title", title);
          }
        },
        /* Handle complete */
        complete() {
          tooltip.remove();
          el.removeAttribute("aria-describedby");
          el.setAttribute("title", title);
        }
      });
      push$.pipe(
        auditTime(16, animationFrameScheduler)
      ).subscribe(({ active }) => {
        tooltip.classList.toggle("md-tooltip--active", active);
      });
      push$.pipe(
        throttleTime(125, animationFrameScheduler),
        filter(() => !!el.offsetParent),
        map(() => el.offsetParent.getBoundingClientRect()),
        map(({ x }) => x)
      ).subscribe({
        /* Handle emission */
        next(origin) {
          if (origin)
            tooltip.style.setProperty("--md-tooltip-0", `${-origin}px`);
          else
            tooltip.style.removeProperty("--md-tooltip-0");
        },
        /* Handle complete */
        complete() {
          tooltip.style.removeProperty("--md-tooltip-0");
        }
      });
      return watchTooltip(tooltip, el).pipe(
        tap((state) => push$.next(state)),
        finalize(() => push$.complete()),
        map((state) => ({ ref: el, ...state }))
      );
    }).pipe(
      subscribeOn(asyncScheduler)
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/header/_/index.ts
  function isHidden({ viewport$: viewport$5 }) {
    if (!feature("header.autohide"))
      return of(false);
    const direction$ = viewport$5.pipe(
      map(({ offset: { y } }) => y),
      bufferCount(2, 1),
      map(([a, b]) => [a < b, b]),
      distinctUntilKeyChanged(0)
    );
    const hidden$ = combineLatest([viewport$5, direction$]).pipe(
      filter(([{ offset }, [, y]]) => Math.abs(y - offset.y) > 100),
      map(([, [direction]]) => direction),
      distinctUntilChanged()
    );
    const search$ = watchToggle("search");
    return combineLatest([viewport$5, search$]).pipe(
      map(([{ offset }, search]) => offset.y > 400 && !search),
      distinctUntilChanged(),
      switchMap((active) => active ? hidden$ : of(false)),
      startWith(false)
    );
  }
  function watchHeader(el, options) {
    return defer(() => combineLatest([
      watchElementSize(el),
      isHidden(options)
    ])).pipe(
      map(([{ height }, hidden]) => ({
        height,
        hidden
      })),
      distinctUntilChanged((a, b) => a.height === b.height && a.hidden === b.hidden),
      shareReplay(1)
    );
  }
  function mountHeader(el, { header$: header$3, main$: main$2 }) {
    return defer(() => {
      const push$ = new Subject();
      const done$ = push$.pipe(ignoreElements(), endWith(true));
      push$.pipe(
        distinctUntilKeyChanged("active"),
        combineLatestWith(header$3)
      ).subscribe(([{ active }, { hidden }]) => {
        el.classList.toggle("md-header--shadow", active && !hidden);
        el.hidden = hidden;
      });
      const tooltips = from(getElements("[title]", el)).pipe(
        filter(() => feature("content.tooltips")),
        mergeMap((child) => mountTooltip(child))
      );
      main$2.subscribe(push$);
      return header$3.pipe(
        takeUntil(done$),
        map((state) => ({ ref: el, ...state })),
        mergeWith(tooltips.pipe(takeUntil(done$)))
      );
    });
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/header/title/index.ts
  function watchHeaderTitle(el, { viewport$: viewport$5, header$: header$3 }) {
    return watchViewportAt(el, { viewport$: viewport$5, header$: header$3 }).pipe(
      map(({ offset: { y } }) => {
        const { height } = getElementSize(el);
        return {
          active: y >= height
        };
      }),
      distinctUntilKeyChanged("active")
    );
  }
  function mountHeaderTitle(el, options) {
    return defer(() => {
      const push$ = new Subject();
      push$.subscribe({
        /* Handle emission */
        next({ active }) {
          el.classList.toggle("md-header__title--active", active);
        },
        /* Handle complete */
        complete() {
          el.classList.remove("md-header__title--active");
        }
      });
      const heading = getOptionalElement(".md-content h1");
      if (typeof heading === "undefined")
        return EMPTY;
      return watchHeaderTitle(heading, options).pipe(
        tap((state) => push$.next(state)),
        finalize(() => push$.complete()),
        map((state) => ({ ref: el, ...state }))
      );
    });
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/main/index.ts
  function watchMain(el, { viewport$: viewport$5, header$: header$3 }) {
    const adjust$ = header$3.pipe(
      map(({ height }) => height),
      distinctUntilChanged()
    );
    const border$ = adjust$.pipe(
      switchMap(
        () => watchElementSize(el).pipe(
          map(({ height }) => ({
            top: el.offsetTop,
            bottom: el.offsetTop + height
          })),
          distinctUntilKeyChanged("bottom")
        )
      )
    );
    return combineLatest([adjust$, border$, viewport$5]).pipe(
      map(([header, { top, bottom }, { offset: { y }, size: { height } }]) => {
        height = Math.max(
          0,
          height - Math.max(0, top - y, header) - Math.max(0, height + y - bottom)
        );
        return {
          offset: top - header,
          height,
          active: top - header <= y
        };
      }),
      distinctUntilChanged((a, b) => a.offset === b.offset && a.height === b.height && a.active === b.active)
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/palette/index.ts
  function watchPalette(inputs) {
    const current = __md_get("__palette") || {
      index: inputs.findIndex((input) => matchMedia(
        input.getAttribute("data-md-color-media")
      ).matches)
    };
    const index = Math.max(0, Math.min(current.index, inputs.length - 1));
    return of(...inputs).pipe(
      mergeMap((input) => fromEvent(input, "change").pipe(map(() => input))),
      startWith(inputs[index]),
      map((input) => ({
        index: inputs.indexOf(input),
        color: {
          media: input.getAttribute("data-md-color-media"),
          scheme: input.getAttribute("data-md-color-scheme"),
          primary: input.getAttribute("data-md-color-primary"),
          accent: input.getAttribute("data-md-color-accent")
        }
      })),
      shareReplay(1)
    );
  }
  function mountPalette(el) {
    const inputs = getElements("input", el);
    const meta = h("meta", { name: "theme-color" });
    document.head.appendChild(meta);
    const scheme = h("meta", { name: "color-scheme" });
    document.head.appendChild(scheme);
    const media$ = watchMedia("(prefers-color-scheme: light)");
    return defer(() => {
      const push$ = new Subject();
      push$.subscribe((palette) => {
        document.body.setAttribute("data-md-color-switching", "");
        if (palette.color.media === "(prefers-color-scheme)") {
          const media = matchMedia("(prefers-color-scheme: light)");
          const input = document.querySelector(
            media.matches ? "[data-md-color-media='(prefers-color-scheme: light)']" : "[data-md-color-media='(prefers-color-scheme: dark)']"
          );
          palette.color.scheme = input.getAttribute("data-md-color-scheme");
          palette.color.primary = input.getAttribute("data-md-color-primary");
          palette.color.accent = input.getAttribute("data-md-color-accent");
        }
        for (const [key, value] of Object.entries(palette.color))
          document.body.setAttribute(`data-md-color-${key}`, value);
        for (let index = 0; index < inputs.length; index++) {
          const label = inputs[index].nextElementSibling;
          if (label instanceof HTMLElement)
            label.hidden = palette.index !== index;
        }
        __md_set("__palette", palette);
      });
      fromEvent(el, "keydown").pipe(
        filter((ev) => ev.key === "Enter"),
        withLatestFrom(push$, (_, palette) => palette)
      ).subscribe(({ index }) => {
        index = (index + 1) % inputs.length;
        inputs[index].click();
        inputs[index].focus();
      });
      push$.pipe(
        map(() => {
          const header = getComponentElement("header");
          const style = window.getComputedStyle(header);
          scheme.content = style.colorScheme;
          return style.backgroundColor.match(/\d+/g).map((value) => (+value).toString(16).padStart(2, "0")).join("");
        })
      ).subscribe((color) => meta.content = `#${color}`);
      push$.pipe(observeOn(asyncScheduler)).subscribe(() => {
        document.body.removeAttribute("data-md-color-switching");
      });
      return watchPalette(inputs).pipe(
        takeUntil(media$.pipe(skip(1))),
        repeat(),
        tap((state) => push$.next(state)),
        finalize(() => push$.complete()),
        map((state) => ({ ref: el, ...state }))
      );
    });
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/progress/index.ts
  function mountProgress(el, { progress$: progress$2 }) {
    return defer(() => {
      const push$ = new Subject();
      push$.subscribe(({ value }) => {
        el.style.setProperty("--md-progress-value", `${value}`);
      });
      return progress$2.pipe(
        tap((value) => push$.next({ value })),
        finalize(() => push$.complete()),
        map((value) => ({ ref: el, value }))
      );
    });
  }

  // external/mkdocs-material/src/templates/assets/javascripts/integrations/clipboard/index.ts
  var import_clipboard2 = __toESM(require_clipboard());
  function extract(el) {
    el.setAttribute("data-md-copying", "");
    const copy = el.closest("[data-copy]");
    const text = copy ? copy.getAttribute("data-copy") : el.innerText;
    el.removeAttribute("data-md-copying");
    return text.trimEnd();
  }
  function setupClipboardJS({ alert$: alert$2 }) {
    if (import_clipboard2.default.isSupported()) {
      new Observable((subscriber) => {
        new import_clipboard2.default("[data-clipboard-target], [data-clipboard-text]", {
          text: (el) => el.getAttribute("data-clipboard-text") || extract(getElement(
            el.getAttribute("data-clipboard-target")
          ))
        }).on("success", (ev) => subscriber.next(ev));
      }).pipe(
        tap((ev) => {
          const trigger = ev.trigger;
          trigger.focus();
        }),
        map(() => translation("clipboard.copied"))
      ).subscribe(alert$2);
    }
  }

  // external/mkdocs-material/src/templates/assets/javascripts/integrations/sitemap/index.ts
  function resolve(url2, base) {
    url2.protocol = base.protocol;
    url2.hostname = base.hostname;
    return url2;
  }
  function extract2(document2, base) {
    const sitemap = /* @__PURE__ */ new Map();
    for (const el of getElements("url", document2)) {
      const url2 = getElement("loc", el);
      const links = [resolve(new URL(url2.textContent), base)];
      sitemap.set(`${links[0]}`, links);
      for (const link of getElements("[rel=alternate]", el)) {
        const href = link.getAttribute("href");
        if (href != null)
          links.push(resolve(new URL(href), base));
      }
    }
    return sitemap;
  }
  function fetchSitemap(base) {
    return requestXML(new URL("sitemap.xml", base)).pipe(
      map((document2) => extract2(document2, new URL(base))),
      catchError(() => of(/* @__PURE__ */ new Map()))
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/integrations/instant/index.ts
  function handle(ev, sitemap) {
    if (!(ev.target instanceof Element))
      return EMPTY;
    const el = ev.target.closest("a");
    if (el === null)
      return EMPTY;
    if (el.target || ev.metaKey || ev.ctrlKey)
      return EMPTY;
    const url2 = new URL(el.href);
    url2.search = url2.hash = "";
    if (!sitemap.has(`${url2}`))
      return EMPTY;
    ev.preventDefault();
    return of(new URL(el.href));
  }
  function head(document2) {
    const tags = /* @__PURE__ */ new Map();
    for (const el of getElements(":scope > *", document2.head))
      tags.set(el.outerHTML, el);
    return tags;
  }
  function resolve2(document2) {
    for (const el of getElements("[href], [src]", document2))
      for (const key of ["href", "src"]) {
        const value = el.getAttribute(key);
        if (value && !/^(?:[a-z]+:)?\/\//i.test(value)) {
          el[key] = el[key];
          break;
        }
      }
    return of(document2);
  }
  function inject(next) {
    for (const selector3 of [
      "[data-md-component=announce]",
      "[data-md-component=container]",
      "[data-md-component=header-topic]",
      "[data-md-component=outdated]",
      "[data-md-component=logo]",
      "[data-md-component=skip]",
      ...feature("navigation.tabs.sticky") ? ["[data-md-component=tabs]"] : []
    ]) {
      const source = getOptionalElement(selector3);
      const target = getOptionalElement(selector3, next);
      if (typeof source !== "undefined" && typeof target !== "undefined") {
        source.replaceWith(target);
      }
    }
    const tags = head(document);
    for (const [html, el] of head(next))
      if (tags.has(html))
        tags.delete(html);
      else
        document.head.appendChild(el);
    for (const el of tags.values()) {
      const name = el.getAttribute("name");
      if (name !== "theme-color" && name !== "color-scheme")
        el.remove();
    }
    const container = getComponentElement("container");
    return concat(getElements("script", container)).pipe(
      switchMap((el) => {
        const script2 = next.createElement("script");
        if (el.src) {
          for (const name of el.getAttributeNames())
            script2.setAttribute(name, el.getAttribute(name));
          el.replaceWith(script2);
          return new Observable((observer) => {
            script2.onload = () => observer.complete();
          });
        } else {
          script2.textContent = el.textContent;
          el.replaceWith(script2);
          return EMPTY;
        }
      }),
      ignoreElements(),
      endWith(document)
    );
  }
  function setupInstantNavigation({ location$: location$3, viewport$: viewport$5, progress$: progress$2 }) {
    const config6 = configuration();
    if (location.protocol === "file:")
      return EMPTY;
    const sitemap$ = fetchSitemap(config6.base);
    of(document).subscribe(resolve2);
    const instant$ = fromEvent(document.body, "click").pipe(
      combineLatestWith(sitemap$),
      switchMap(([ev, sitemap]) => handle(ev, sitemap)),
      share()
    );
    const history$ = fromEvent(window, "popstate").pipe(
      map(getLocation),
      share()
    );
    instant$.pipe(withLatestFrom(viewport$5)).subscribe(([url2, { offset }]) => {
      history.replaceState(offset, "");
      history.pushState(null, "", url2);
    });
    merge(instant$, history$).subscribe(location$3);
    const document$5 = location$3.pipe(
      distinctUntilKeyChanged("pathname"),
      switchMap(
        (url2) => requestHTML(url2, { progress$: progress$2 }).pipe(
          catchError(() => {
            setLocation(url2, true);
            return EMPTY;
          })
        )
      ),
      // The document was successfully fetched and parsed, so we can inject its
      // contents into the currently active document
      switchMap(resolve2),
      switchMap(inject),
      share()
    );
    merge(
      document$5.pipe(withLatestFrom(location$3, (_, url2) => url2)),
      // Handle instant navigation events that are triggered by the user clicking
      // on an anchor link with a hash fragment different from the current one, as
      // well as from popstate events, which are emitted when the user navigates
      // back and forth between pages. We use a two-layered subscription to scope
      // the scroll restoration to the current page, as we don't need to restore
      // the viewport offset when the user navigates to a different page, as this
      // is already handled by the previous observable.
      document$5.pipe(
        switchMap(() => location$3),
        distinctUntilKeyChanged("pathname"),
        switchMap(() => location$3),
        distinctUntilKeyChanged("hash")
      ),
      // Handle instant navigation events that are triggered by the user clicking
      // on an anchor link with the same hash fragment as the current one in the
      // URL. It is essential that we only intercept those from instant navigation
      // events and not from history change events, or we'll end up in and endless
      // loop. The top-level history entry must be removed, as it will be replaced
      // with a new one, which would otherwise lead to a duplicate entry.
      location$3.pipe(
        distinctUntilChanged((a, b) => a.pathname === b.pathname && a.hash === b.hash),
        switchMap(() => instant$),
        tap(() => history.back())
      )
    ).subscribe((url2) => {
      if (history.state !== null || !url2.hash) {
        window.scrollTo(0, history.state?.y ?? 0);
      } else {
        history.scrollRestoration = "auto";
        setLocationHash(url2.hash);
        history.scrollRestoration = "manual";
      }
    });
    location$3.subscribe(() => {
      history.scrollRestoration = "manual";
    });
    fromEvent(window, "beforeunload").subscribe(() => {
      history.scrollRestoration = "auto";
    });
    viewport$5.pipe(
      distinctUntilKeyChanged("offset"),
      debounceTime(100)
    ).subscribe(({ offset }) => {
      history.replaceState(offset, "");
    });
    return document$5;
  }

  // external/mkdocs-material/src/templates/assets/javascripts/integrations/search/highlighter/index.ts
  var import_escape_html2 = __toESM(require_escape_html());
  function setupSearchHighlighter(config6) {
    const regex = config6.separator.split("|").map((term) => {
      const temp = term.replace(/(\(\?[!=<][^)]+\))/g, "");
      return temp.length === 0 ? "\uFFFD" : term;
    }).join("|");
    const separator = new RegExp(regex, "img");
    const highlight2 = (_, data, term) => {
      return `${data}<mark data-md-highlight>${term}</mark>`;
    };
    return (query) => {
      query = query.replace(/[\s*+\-:~^]+/g, " ").trim();
      const match = new RegExp(`(^|${config6.separator}|)(${query.replace(/[|\\{}()[\]^$+*?.-]/g, "\\$&").replace(separator, "|")})`, "img");
      return (value) => (0, import_escape_html2.default)(value).replace(match, highlight2).replace(/<\/mark>(\s+)<mark[^>]*>/img, "$1");
    };
  }

  // external/mkdocs-material/src/templates/assets/javascripts/integrations/search/worker/message/index.ts
  function isSearchReadyMessage(message) {
    return message.type === 1 /* READY */;
  }
  function isSearchResultMessage(message) {
    return message.type === 3 /* RESULT */;
  }

  // external/mkdocs-material/src/templates/assets/javascripts/integrations/search/worker/_/index.ts
  function setupSearchWorker(url2, index$2) {
    const worker$ = watchWorker(url2);
    merge(
      of(location.protocol !== "file:"),
      watchToggle("search")
    ).pipe(
      first((active) => active),
      switchMap(() => index$2)
    ).subscribe(({ config: config6, docs }) => worker$.next({
      type: 0 /* SETUP */,
      data: {
        config: config6,
        docs,
        options: {
          suggest: feature("search.suggest")
        }
      }
    }));
    return worker$;
  }

  // external/mkdocs-material/src/templates/assets/javascripts/integrations/version/findurl/index.ts
  function selectedVersionCorrespondingURL(params) {
    const {
      selectedVersionSitemap,
      selectedVersionBaseURL,
      currentLocation,
      currentBaseURL
    } = params;
    const current_path = safeURLParse(currentBaseURL)?.pathname;
    if (current_path === void 0) {
      return;
    }
    const currentRelativePath = stripPrefix(currentLocation.pathname, current_path);
    if (currentRelativePath === void 0) {
      return;
    }
    const sitemapCommonPrefix = shortestCommonPrefix(selectedVersionSitemap.keys());
    if (!selectedVersionSitemap.has(sitemapCommonPrefix)) {
      return;
    }
    const potentialSitemapURL = safeURLParse(currentRelativePath, sitemapCommonPrefix);
    if (!potentialSitemapURL || !selectedVersionSitemap.has(potentialSitemapURL.href)) {
      return;
    }
    const result = safeURLParse(currentRelativePath, selectedVersionBaseURL);
    if (!result) {
      return;
    }
    result.hash = currentLocation.hash;
    result.search = currentLocation.search;
    return result;
  }
  function safeURLParse(url2, base) {
    try {
      return new URL(url2, base);
    } catch {
      return;
    }
  }
  function stripPrefix(s, prefix) {
    if (s.startsWith(prefix)) {
      return s.slice(prefix.length);
    }
    return void 0;
  }
  function commonPrefixLen(s1, s2) {
    const max = Math.min(s1.length, s2.length);
    let result;
    for (result = 0; result < max; ++result) {
      if (s1[result] !== s2[result]) {
        break;
      }
    }
    return result;
  }
  function shortestCommonPrefix(strs) {
    let result;
    for (const s of strs) {
      if (result === void 0) {
        result = s;
      } else {
        result = result.slice(0, commonPrefixLen(result, s));
      }
    }
    return result ?? "";
  }

  // external/mkdocs-material/src/templates/assets/javascripts/integrations/version/index.ts
  function setupVersionSelector({ document$: document$5 }) {
    const config6 = configuration();
    const versions$ = requestJSON(
      new URL("../versions.json", config6.base)
    ).pipe(
      catchError(() => EMPTY)
      // @todo refactor instant loading
    );
    const current$ = versions$.pipe(
      map((versions) => {
        const [, current] = config6.base.match(/([^/]+)\/?$/);
        return versions.find(({ version, aliases }) => version === current || aliases.includes(current)) || versions[0];
      })
    );
    versions$.pipe(
      map((versions) => new Map(versions.map((version) => [
        `${new URL(`../${version.version}/`, config6.base)}`,
        version
      ]))),
      switchMap(
        (urls) => fromEvent(document.body, "click").pipe(
          filter((ev) => !ev.metaKey && !ev.ctrlKey),
          withLatestFrom(current$),
          switchMap(([ev, current]) => {
            if (ev.target instanceof Element) {
              const el = ev.target.closest("a");
              if (el && !el.target && urls.has(el.href)) {
                const url2 = el.href;
                if (!ev.target.closest(".md-version")) {
                  const version = urls.get(url2);
                  if (version === current)
                    return EMPTY;
                }
                ev.preventDefault();
                return of(new URL(url2));
              }
            }
            return EMPTY;
          }),
          switchMap((selectedVersionBaseURL) => {
            return fetchSitemap(selectedVersionBaseURL).pipe(
              map(
                (sitemap) => selectedVersionCorrespondingURL({
                  selectedVersionSitemap: sitemap,
                  selectedVersionBaseURL,
                  currentLocation: getLocation(),
                  currentBaseURL: config6.base
                }) ?? selectedVersionBaseURL
              )
            );
          })
        )
      )
    ).subscribe((url2) => setLocation(url2, true));
    combineLatest([versions$, current$]).subscribe(([versions, current]) => {
      const topic = getElement(".md-header__topic");
      topic.appendChild(renderVersionSelector(versions, current));
    });
    document$5.pipe(switchMap(() => current$)).subscribe((current) => {
      let outdated = __md_get("__outdated", sessionStorage);
      if (outdated === null) {
        outdated = true;
        let ignored = config6.version?.default || "latest";
        if (!Array.isArray(ignored))
          ignored = [ignored];
        main: for (const ignore of ignored)
          for (const version of current.aliases.concat(current.version))
            if (new RegExp(ignore, "i").test(version)) {
              outdated = false;
              break main;
            }
        __md_set("__outdated", outdated, sessionStorage);
      }
      if (outdated)
        for (const warning of getComponentElements("outdated"))
          warning.hidden = false;
    });
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/search/query/index.ts
  function watchSearchQuery(el, { worker$ }) {
    const { searchParams } = getLocation();
    if (searchParams.has("q")) {
      setToggle("search", true);
      el.value = searchParams.get("q");
      el.focus();
      watchToggle("search").pipe(
        first((active) => !active)
      ).subscribe(() => {
        const url2 = getLocation();
        url2.searchParams.delete("q");
        history.replaceState({}, "", `${url2}`);
      });
    }
    const focus$ = watchElementFocus(el);
    const value$ = merge(
      worker$.pipe(first(isSearchReadyMessage)),
      fromEvent(el, "keyup"),
      focus$
    ).pipe(
      map(() => el.value),
      distinctUntilChanged()
    );
    return combineLatest([value$, focus$]).pipe(
      map(([value, focus]) => ({ value, focus })),
      shareReplay(1)
    );
  }
  function mountSearchQuery(el, { worker$ }) {
    const push$ = new Subject();
    const done$ = push$.pipe(ignoreElements(), endWith(true));
    combineLatest([
      worker$.pipe(first(isSearchReadyMessage)),
      push$
    ], (_, query) => query).pipe(
      distinctUntilKeyChanged("value")
    ).subscribe(({ value }) => worker$.next({
      type: 2 /* QUERY */,
      data: value
    }));
    push$.pipe(
      distinctUntilKeyChanged("focus")
    ).subscribe(({ focus }) => {
      if (focus)
        setToggle("search", focus);
    });
    fromEvent(el.form, "reset").pipe(
      takeUntil(done$)
    ).subscribe(() => el.focus());
    const label = getElement("header [for=__search]");
    fromEvent(label, "click").subscribe(() => el.focus());
    return watchSearchQuery(el, { worker$ }).pipe(
      tap((state) => push$.next(state)),
      finalize(() => push$.complete()),
      map((state) => ({ ref: el, ...state })),
      shareReplay(1)
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/search/result/index.ts
  function mountSearchResult(el, { worker$, query$ }) {
    const push$ = new Subject();
    const boundary$ = watchElementBoundary(el.parentElement).pipe(
      filter(Boolean)
    );
    const container = el.parentElement;
    const meta = getElement(":scope > :first-child", el);
    const list = getElement(":scope > :last-child", el);
    watchToggle("search").subscribe((active) => list.setAttribute(
      "role",
      active ? "list" : "presentation"
    ));
    push$.pipe(
      withLatestFrom(query$),
      skipUntil(worker$.pipe(first(isSearchReadyMessage)))
    ).subscribe(([{ items }, { value }]) => {
      switch (items.length) {
        /* No results */
        case 0:
          meta.textContent = value.length ? translation("search.result.none") : translation("search.result.placeholder");
          break;
        /* One result */
        case 1:
          meta.textContent = translation("search.result.one");
          break;
        /* Multiple result */
        default:
          const count = round(items.length);
          meta.textContent = translation("search.result.other", count);
      }
    });
    const render$ = push$.pipe(
      tap(() => list.innerHTML = ""),
      switchMap(({ items }) => merge(
        of(...items.slice(0, 10)),
        of(...items.slice(10)).pipe(
          bufferCount(4),
          zipWith(boundary$),
          switchMap(([chunk]) => chunk)
        )
      )),
      map(renderSearchResultItem),
      share()
    );
    render$.subscribe((item) => list.appendChild(item));
    render$.pipe(
      mergeMap((item) => {
        const details = getOptionalElement("details", item);
        if (typeof details === "undefined")
          return EMPTY;
        return fromEvent(details, "toggle").pipe(
          takeUntil(push$),
          map(() => details)
        );
      })
    ).subscribe((details) => {
      if (details.open === false && details.offsetTop <= container.scrollTop)
        container.scrollTo({ top: details.offsetTop });
    });
    const result$ = worker$.pipe(
      filter(isSearchResultMessage),
      map(({ data }) => data)
    );
    return result$.pipe(
      tap((state) => push$.next(state)),
      finalize(() => push$.complete()),
      map((state) => ({ ref: el, ...state }))
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/search/share/index.ts
  function watchSearchShare(_el, { query$ }) {
    return query$.pipe(
      map(({ value }) => {
        const url2 = getLocation();
        url2.hash = "";
        value = value.replace(/\s+/g, "+").replace(/&/g, "%26").replace(/=/g, "%3D");
        url2.search = `q=${value}`;
        return { url: url2 };
      })
    );
  }
  function mountSearchShare(el, options) {
    const push$ = new Subject();
    const done$ = push$.pipe(ignoreElements(), endWith(true));
    push$.subscribe(({ url: url2 }) => {
      el.setAttribute("data-clipboard-text", el.href);
      el.href = `${url2}`;
    });
    fromEvent(el, "click").pipe(
      takeUntil(done$)
    ).subscribe((ev) => ev.preventDefault());
    return watchSearchShare(el, options).pipe(
      tap((state) => push$.next(state)),
      finalize(() => push$.complete()),
      map((state) => ({ ref: el, ...state }))
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/search/suggest/index.ts
  function mountSearchSuggest(el, { worker$, keyboard$: keyboard$2 }) {
    const push$ = new Subject();
    const query = getComponentElement("search-query");
    const query$ = merge(
      fromEvent(query, "keydown"),
      fromEvent(query, "focus")
    ).pipe(
      observeOn(asyncScheduler),
      map(() => query.value),
      distinctUntilChanged()
    );
    push$.pipe(
      combineLatestWith(query$),
      map(([{ suggest }, value]) => {
        const words = value.split(/([\s-]+)/);
        if (suggest?.length && words[words.length - 1]) {
          const last2 = suggest[suggest.length - 1];
          if (last2.startsWith(words[words.length - 1]))
            words[words.length - 1] = last2;
        } else {
          words.length = 0;
        }
        return words;
      })
    ).subscribe(
      (words) => el.innerHTML = words.join("").replace(/\s/g, "&nbsp;")
    );
    keyboard$2.pipe(
      filter(({ mode }) => mode === "search")
    ).subscribe((key) => {
      switch (key.type) {
        /* Right arrow: accept current suggestion */
        case "ArrowRight":
          if (el.innerText.length && query.selectionStart === query.value.length)
            query.value = el.innerText;
          break;
      }
    });
    const result$ = worker$.pipe(
      filter(isSearchResultMessage),
      map(({ data }) => data)
    );
    return result$.pipe(
      tap((state) => push$.next(state)),
      finalize(() => push$.complete()),
      map(() => ({ ref: el }))
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/search/_/index.ts
  function mountSearch(el, { index$: index$2, keyboard$: keyboard$2 }) {
    const config6 = configuration();
    try {
      const worker$ = setupSearchWorker(config6.search, index$2);
      const query = getComponentElement("search-query", el);
      const result = getComponentElement("search-result", el);
      fromEvent(el, "click").pipe(
        filter(({ target }) => target instanceof Element && !!target.closest("a"))
      ).subscribe(() => setToggle("search", false));
      keyboard$2.pipe(
        filter(({ mode }) => mode === "search")
      ).subscribe((key) => {
        const active = getActiveElement();
        switch (key.type) {
          /* Enter: go to first (best) result */
          case "Enter":
            if (active === query) {
              const anchors = /* @__PURE__ */ new Map();
              for (const anchor of getElements(
                ":first-child [href]",
                result
              )) {
                const article = anchor.firstElementChild;
                anchors.set(anchor, parseFloat(
                  article.getAttribute("data-md-score")
                ));
              }
              if (anchors.size) {
                const [[best]] = [...anchors].sort(([, a], [, b]) => b - a);
                best.click();
              }
              key.claim();
            }
            break;
          /* Escape or Tab: close search */
          case "Escape":
          case "Tab":
            setToggle("search", false);
            query.blur();
            break;
          /* Vertical arrows: select previous or next search result */
          case "ArrowUp":
          case "ArrowDown":
            if (typeof active === "undefined") {
              query.focus();
            } else {
              const els = [query, ...getElements(
                ":not(details) > [href], summary, details[open] [href]",
                result
              )];
              const i = Math.max(0, (Math.max(0, els.indexOf(active)) + els.length + (key.type === "ArrowUp" ? -1 : 1)) % els.length);
              els[i].focus();
            }
            key.claim();
            break;
          /* All other keys: hand to search query */
          default:
            if (query !== getActiveElement())
              query.focus();
        }
      });
      keyboard$2.pipe(
        filter(({ mode }) => mode === "global")
      ).subscribe((key) => {
        switch (key.type) {
          /* Open search and select query */
          case "f":
          case "s":
          case "/":
            query.focus();
            query.select();
            key.claim();
            break;
        }
      });
      const query$ = mountSearchQuery(query, { worker$ });
      return merge(
        query$,
        mountSearchResult(result, { worker$, query$ })
      ).pipe(
        mergeWith(
          ...getComponentElements("search-share", el).map((child) => mountSearchShare(child, { query$ })),
          ...getComponentElements("search-suggest", el).map((child) => mountSearchSuggest(child, { worker$, keyboard$: keyboard$2 }))
        )
      );
    } catch (err) {
      el.hidden = true;
      return NEVER;
    }
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/search/highlight/index.ts
  function mountSearchHiglight(el, { index$: index$2, location$: location$3 }) {
    return combineLatest([
      index$2,
      location$3.pipe(
        startWith(getLocation()),
        filter((url2) => !!url2.searchParams.get("h"))
      )
    ]).pipe(
      map(([index, url2]) => setupSearchHighlighter(index.config)(
        url2.searchParams.get("h")
      )),
      map((fn) => {
        const nodes = /* @__PURE__ */ new Map();
        const it = document.createNodeIterator(el, NodeFilter.SHOW_TEXT);
        for (let node = it.nextNode(); node; node = it.nextNode()) {
          if (node.parentElement?.offsetHeight) {
            const original = node.textContent;
            const replaced = fn(original);
            if (replaced.length > original.length)
              nodes.set(node, replaced);
          }
        }
        for (const [node, text] of nodes) {
          const { childNodes } = h("span", null, text);
          node.replaceWith(...Array.from(childNodes));
        }
        return { ref: el, nodes };
      })
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/sidebar/index.ts
  function watchSidebar(el, { viewport$: viewport$5, main$: main$2 }) {
    const parent = el.closest(".md-grid");
    const adjust = parent.offsetTop - parent.parentElement.offsetTop;
    return combineLatest([main$2, viewport$5]).pipe(
      map(([{ offset, height }, { offset: { y } }]) => {
        height = height + Math.min(adjust, Math.max(0, y - offset)) - adjust;
        return {
          height,
          locked: y >= offset + adjust
        };
      }),
      distinctUntilChanged((a, b) => a.height === b.height && a.locked === b.locked)
    );
  }
  function mountSidebar(el, { header$: header$3, ...options }) {
    const inner = getElement(".md-sidebar__scrollwrap", el);
    const { y } = getElementOffset(inner);
    return defer(() => {
      const push$ = new Subject();
      const done$ = push$.pipe(ignoreElements(), endWith(true));
      const next$ = push$.pipe(
        auditTime(0, animationFrameScheduler)
      );
      next$.pipe(withLatestFrom(header$3)).subscribe({
        /* Handle emission */
        next([{ height }, { height: offset }]) {
          inner.style.height = `${height - 2 * y}px`;
          el.style.top = `${offset}px`;
        },
        /* Handle complete */
        complete() {
          inner.style.height = "";
          el.style.top = "";
        }
      });
      next$.pipe(first()).subscribe(() => {
        for (const item of getElements(".md-nav__link--active[href]", el)) {
          if (!item.clientHeight)
            continue;
          const container = item.closest(".md-sidebar__scrollwrap");
          if (typeof container !== "undefined") {
            const offset = item.offsetTop - container.offsetTop;
            const { height } = getElementSize(container);
            container.scrollTo({
              top: offset - height / 2
            });
          }
        }
      });
      from(getElements("label[tabindex]", el)).pipe(
        mergeMap(
          (label) => fromEvent(label, "click").pipe(
            observeOn(asyncScheduler),
            map(() => label),
            takeUntil(done$)
          )
        )
      ).subscribe((label) => {
        const input = getElement(`[id="${label.htmlFor}"]`);
        const nav = getElement(`[aria-labelledby="${label.id}"]`);
        nav.setAttribute("aria-expanded", `${input.checked}`);
      });
      return watchSidebar(el, options).pipe(
        tap((state) => push$.next(state)),
        finalize(() => push$.complete()),
        map((state) => ({ ref: el, ...state }))
      );
    });
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/source/facts/github/index.ts
  function fetchSourceFactsFromGitHub(user, repo) {
    if (typeof repo !== "undefined") {
      const url2 = `https://api.github.com/repos/${user}/${repo}`;
      return zip(
        /* Fetch version */
        requestJSON(`${url2}/releases/latest`).pipe(
          catchError(() => EMPTY),
          // @todo refactor instant loading
          map((release) => ({
            version: release.tag_name
          })),
          defaultIfEmpty({})
        ),
        /* Fetch stars and forks */
        requestJSON(url2).pipe(
          catchError(() => EMPTY),
          // @todo refactor instant loading
          map((info) => ({
            stars: info.stargazers_count,
            forks: info.forks_count
          })),
          defaultIfEmpty({})
        )
      ).pipe(
        map(([release, info]) => ({ ...release, ...info }))
      );
    } else {
      const url2 = `https://api.github.com/users/${user}`;
      return requestJSON(url2).pipe(
        map((info) => ({
          repositories: info.public_repos
        })),
        defaultIfEmpty({})
      );
    }
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/source/facts/gitlab/index.ts
  function fetchSourceFactsFromGitLab(base, project) {
    const url2 = `https://${base}/api/v4/projects/${encodeURIComponent(project)}`;
    return zip(
      /* Fetch version */
      requestJSON(`${url2}/releases/permalink/latest`).pipe(
        catchError(() => EMPTY),
        // @todo refactor instant loading
        map(({ tag_name }) => ({
          version: tag_name
        })),
        defaultIfEmpty({})
      ),
      /* Fetch stars and forks */
      requestJSON(url2).pipe(
        catchError(() => EMPTY),
        // @todo refactor instant loading
        map(({ star_count, forks_count }) => ({
          stars: star_count,
          forks: forks_count
        })),
        defaultIfEmpty({})
      )
    ).pipe(
      map(([release, info]) => ({ ...release, ...info }))
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/source/facts/_/index.ts
  function fetchSourceFacts(url2) {
    let match = url2.match(/^.+github\.com\/([^/]+)\/?([^/]+)?/i);
    if (match) {
      const [, user, repo] = match;
      return fetchSourceFactsFromGitHub(user, repo);
    }
    match = url2.match(/^.+?([^/]*gitlab[^/]+)\/(.+?)\/?$/i);
    if (match) {
      const [, base, slug] = match;
      return fetchSourceFactsFromGitLab(base, slug);
    }
    return EMPTY;
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/source/_/index.ts
  var fetch$;
  function watchSource(el) {
    return fetch$ || (fetch$ = defer(() => {
      const cached = __md_get("__source", sessionStorage);
      if (cached) {
        return of(cached);
      } else {
        const els = getComponentElements("consent");
        if (els.length) {
          const consent = __md_get("__consent");
          if (!(consent && consent.github))
            return EMPTY;
        }
        return fetchSourceFacts(el.href).pipe(
          tap((facts) => __md_set("__source", facts, sessionStorage))
        );
      }
    }).pipe(
      catchError(() => EMPTY),
      filter((facts) => Object.keys(facts).length > 0),
      map((facts) => ({ facts })),
      shareReplay(1)
    ));
  }
  function mountSource(el) {
    const inner = getElement(":scope > :last-child", el);
    return defer(() => {
      const push$ = new Subject();
      push$.subscribe(({ facts }) => {
        inner.appendChild(renderSourceFacts(facts));
        inner.classList.add("md-source__repository--active");
      });
      return watchSource(el).pipe(
        tap((state) => push$.next(state)),
        finalize(() => push$.complete()),
        map((state) => ({ ref: el, ...state }))
      );
    });
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/tabs/index.ts
  function watchTabs(el, { viewport$: viewport$5, header$: header$3 }) {
    return watchElementSize(document.body).pipe(
      switchMap(() => watchViewportAt(el, { header$: header$3, viewport$: viewport$5 })),
      map(({ offset: { y } }) => {
        return {
          hidden: y >= 10
        };
      }),
      distinctUntilKeyChanged("hidden")
    );
  }
  function mountTabs(el, options) {
    return defer(() => {
      const push$ = new Subject();
      push$.subscribe({
        /* Handle emission */
        next({ hidden }) {
          el.hidden = hidden;
        },
        /* Handle complete */
        complete() {
          el.hidden = false;
        }
      });
      return (feature("navigation.tabs.sticky") ? of({ hidden: false }) : watchTabs(el, options)).pipe(
        tap((state) => push$.next(state)),
        finalize(() => push$.complete()),
        map((state) => ({ ref: el, ...state }))
      );
    });
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/toc/index.ts
  function watchTableOfContents(el, { viewport$: viewport$5, header$: header$3 }) {
    const table = /* @__PURE__ */ new Map();
    const anchors = getElements(".md-nav__link", el);
    for (const anchor of anchors) {
      const id = decodeURIComponent(anchor.hash.substring(1));
      const target = getOptionalElement(`[id="${id}"]`);
      if (typeof target !== "undefined")
        table.set(anchor, target);
    }
    const adjust$ = header$3.pipe(
      distinctUntilKeyChanged("height"),
      map(({ height }) => {
        const main = getComponentElement("main");
        const grid = getElement(":scope > :first-child", main);
        return height + 0.8 * (grid.offsetTop - main.offsetTop);
      }),
      share()
    );
    const partition$ = watchElementSize(document.body).pipe(
      distinctUntilKeyChanged("height"),
      /* Build index to map anchor paths to vertical offsets */
      switchMap(
        (body) => defer(() => {
          let path = [];
          return of([...table].reduce((index, [anchor, target]) => {
            while (path.length) {
              const last2 = table.get(path[path.length - 1]);
              if (last2.tagName >= target.tagName) {
                path.pop();
              } else {
                break;
              }
            }
            let offset = target.offsetTop;
            while (!offset && target.parentElement) {
              target = target.parentElement;
              offset = target.offsetTop;
            }
            let parent = target.offsetParent;
            for (; parent; parent = parent.offsetParent)
              offset += parent.offsetTop;
            return index.set(
              [...path = [...path, anchor]].reverse(),
              offset
            );
          }, /* @__PURE__ */ new Map()));
        }).pipe(
          /* Sort index by vertical offset (see https://bit.ly/30z6QSO) */
          map((index) => new Map([...index].sort(([, a], [, b]) => a - b))),
          combineLatestWith(adjust$),
          /* Re-compute partition when viewport offset changes */
          switchMap(
            ([index, adjust]) => viewport$5.pipe(
              scan(([prev, next], { offset: { y }, size }) => {
                const last2 = y + size.height >= Math.floor(body.height);
                while (next.length) {
                  const [, offset] = next[0];
                  if (offset - adjust < y || last2) {
                    prev = [...prev, next.shift()];
                  } else {
                    break;
                  }
                }
                while (prev.length) {
                  const [, offset] = prev[prev.length - 1];
                  if (offset - adjust >= y && !last2) {
                    next = [prev.pop(), ...next];
                  } else {
                    break;
                  }
                }
                return [prev, next];
              }, [[], [...index]]),
              distinctUntilChanged((a, b) => a[0] === b[0] && a[1] === b[1])
            )
          )
        )
      )
    );
    return partition$.pipe(
      map(([prev, next]) => ({
        prev: prev.map(([path]) => path),
        next: next.map(([path]) => path)
      })),
      /* Extract anchor list migrations */
      startWith({ prev: [], next: [] }),
      bufferCount(2, 1),
      map(([a, b]) => {
        if (a.prev.length < b.prev.length) {
          return {
            prev: b.prev.slice(Math.max(0, a.prev.length - 1), b.prev.length),
            next: []
          };
        } else {
          return {
            prev: b.prev.slice(-1),
            next: b.next.slice(0, b.next.length - a.next.length)
          };
        }
      })
    );
  }
  function mountTableOfContents(el, { viewport$: viewport$5, header$: header$3, main$: main$2, target$: target$2 }) {
    return defer(() => {
      const push$ = new Subject();
      const done$ = push$.pipe(ignoreElements(), endWith(true));
      push$.subscribe(({ prev, next }) => {
        for (const [anchor] of next) {
          anchor.classList.remove("md-nav__link--passed");
          anchor.classList.remove("md-nav__link--active");
        }
        for (const [index, [anchor]] of prev.entries()) {
          anchor.classList.add("md-nav__link--passed");
          anchor.classList.toggle(
            "md-nav__link--active",
            index === prev.length - 1
          );
        }
      });
      if (feature("toc.follow")) {
        const smooth$ = merge(
          viewport$5.pipe(debounceTime(1), map(() => void 0)),
          viewport$5.pipe(debounceTime(250), map(() => "smooth"))
        );
        push$.pipe(
          filter(({ prev }) => prev.length > 0),
          combineLatestWith(main$2.pipe(observeOn(asyncScheduler))),
          withLatestFrom(smooth$)
        ).subscribe(([[{ prev }], behavior]) => {
          const [anchor] = prev[prev.length - 1];
          if (anchor.offsetHeight) {
            const container = getElementContainer(anchor);
            if (typeof container !== "undefined") {
              const offset = anchor.offsetTop - container.offsetTop;
              const { height } = getElementSize(container);
              container.scrollTo({
                top: offset - height / 2,
                behavior
              });
            }
          }
        });
      }
      if (feature("navigation.tracking"))
        viewport$5.pipe(
          takeUntil(done$),
          distinctUntilKeyChanged("offset"),
          debounceTime(250),
          skip(1),
          takeUntil(target$2.pipe(skip(1))),
          repeat({ delay: 250 }),
          withLatestFrom(push$)
        ).subscribe(([, { prev }]) => {
          const url2 = getLocation();
          const anchor = prev[prev.length - 1];
          if (anchor && anchor.length) {
            const [active] = anchor;
            const { hash } = new URL(active.href);
            if (url2.hash !== hash) {
              url2.hash = hash;
              history.replaceState({}, "", `${url2}`);
            }
          } else {
            url2.hash = "";
            history.replaceState({}, "", `${url2}`);
          }
        });
      return watchTableOfContents(el, { viewport$: viewport$5, header$: header$3 }).pipe(
        tap((state) => push$.next(state)),
        finalize(() => push$.complete()),
        map((state) => ({ ref: el, ...state }))
      );
    });
  }

  // external/mkdocs-material/src/templates/assets/javascripts/components/top/index.ts
  function watchBackToTop(_el, { viewport$: viewport$5, main$: main$2, target$: target$2 }) {
    const direction$ = viewport$5.pipe(
      map(({ offset: { y } }) => y),
      bufferCount(2, 1),
      map(([a, b]) => a > b && b > 0),
      distinctUntilChanged()
    );
    const active$ = main$2.pipe(
      map(({ active }) => active)
    );
    return combineLatest([active$, direction$]).pipe(
      map(([active, direction]) => !(active && direction)),
      distinctUntilChanged(),
      takeUntil(target$2.pipe(skip(1))),
      endWith(true),
      repeat({ delay: 250 }),
      map((hidden) => ({ hidden }))
    );
  }
  function mountBackToTop(el, { viewport$: viewport$5, header$: header$3, main$: main$2, target$: target$2 }) {
    const push$ = new Subject();
    const done$ = push$.pipe(ignoreElements(), endWith(true));
    push$.subscribe({
      /* Handle emission */
      next({ hidden }) {
        el.hidden = hidden;
        if (hidden) {
          el.setAttribute("tabindex", "-1");
          el.blur();
        } else {
          el.removeAttribute("tabindex");
        }
      },
      /* Handle complete */
      complete() {
        el.style.top = "";
        el.hidden = true;
        el.removeAttribute("tabindex");
      }
    });
    header$3.pipe(
      takeUntil(done$),
      distinctUntilKeyChanged("height")
    ).subscribe(({ height }) => {
      el.style.top = `${height + 16}px`;
    });
    fromEvent(el, "click").subscribe((ev) => {
      ev.preventDefault();
      window.scrollTo({ top: 0 });
    });
    return watchBackToTop(el, { viewport$: viewport$5, main$: main$2, target$: target$2 }).pipe(
      tap((state) => push$.next(state)),
      finalize(() => push$.complete()),
      map((state) => ({ ref: el, ...state }))
    );
  }

  // external/mkdocs-material/src/templates/assets/javascripts/patches/ellipsis/index.ts
  function patchEllipsis({ document$: document$5, viewport$: viewport$5 }) {
    document$5.pipe(
      switchMap(() => getElements(".md-ellipsis")),
      mergeMap(
        (el) => watchElementVisibility(el).pipe(
          takeUntil(document$5.pipe(skip(1))),
          filter((visible) => visible),
          map(() => el),
          take(1)
        )
      ),
      filter((el) => el.offsetWidth < el.scrollWidth),
      mergeMap((el) => {
        const text = el.innerText;
        const host = el.closest("a") || el;
        host.title = text;
        if (!feature("content.tooltips"))
          return EMPTY;
        return mountInlineTooltip2(host, { viewport$: viewport$5 }).pipe(
          takeUntil(document$5.pipe(skip(1))),
          finalize(() => host.removeAttribute("title"))
        );
      })
    ).subscribe();
    if (feature("content.tooltips"))
      document$5.pipe(
        switchMap(() => getElements(".md-status")),
        mergeMap((el) => mountInlineTooltip2(el, { viewport$: viewport$5 }))
      ).subscribe();
  }

  // external/mkdocs-material/src/templates/assets/javascripts/patches/indeterminate/index.ts
  function patchIndeterminate({ document$: document$5, tablet$: tablet$2 }) {
    document$5.pipe(
      switchMap(() => getElements(
        ".md-toggle--indeterminate"
      )),
      tap((el) => {
        el.indeterminate = true;
        el.checked = false;
      }),
      mergeMap(
        (el) => fromEvent(el, "change").pipe(
          takeWhile(() => el.classList.contains("md-toggle--indeterminate")),
          map(() => el)
        )
      ),
      withLatestFrom(tablet$2)
    ).subscribe(([el, tablet]) => {
      el.classList.remove("md-toggle--indeterminate");
      if (tablet)
        el.checked = false;
    });
  }

  // external/mkdocs-material/src/templates/assets/javascripts/patches/scrollfix/index.ts
  function isAppleDevice() {
    return /(iPad|iPhone|iPod)/.test(navigator.userAgent);
  }
  function patchScrollfix({ document$: document$5 }) {
    document$5.pipe(
      switchMap(() => getElements("[data-md-scrollfix]")),
      tap((el) => el.removeAttribute("data-md-scrollfix")),
      filter(isAppleDevice),
      mergeMap(
        (el) => fromEvent(el, "touchstart").pipe(
          map(() => el)
        )
      )
    ).subscribe((el) => {
      const top = el.scrollTop;
      if (top === 0) {
        el.scrollTop = 1;
      } else if (top + el.offsetHeight === el.scrollHeight) {
        el.scrollTop = top - 1;
      }
    });
  }

  // external/mkdocs-material/src/templates/assets/javascripts/patches/scrolllock/index.ts
  function patchScrolllock({ viewport$: viewport$5, tablet$: tablet$2 }) {
    combineLatest([watchToggle("search"), tablet$2]).pipe(
      map(([active, tablet]) => active && !tablet),
      switchMap(
        (active) => of(active).pipe(
          delay(active ? 400 : 100)
        )
      ),
      withLatestFrom(viewport$5)
    ).subscribe(([active, { offset: { y } }]) => {
      if (active) {
        document.body.setAttribute("data-md-scrolllock", "");
        document.body.style.top = `-${y}px`;
      } else {
        const value = -1 * parseInt(document.body.style.top, 10);
        document.body.removeAttribute("data-md-scrolllock");
        document.body.style.top = "";
        if (value)
          window.scrollTo(0, value);
      }
    });
  }

  // external/mkdocs-material/src/templates/assets/javascripts/polyfills/index.ts
  if (!Object.entries)
    Object.entries = function(obj) {
      const data = [];
      for (const key of Object.keys(obj))
        data.push([key, obj[key]]);
      return data;
    };
  if (!Object.values)
    Object.values = function(obj) {
      const data = [];
      for (const key of Object.keys(obj))
        data.push(obj[key]);
      return data;
    };
  if (typeof Element !== "undefined") {
    if (!Element.prototype.scrollTo)
      Element.prototype.scrollTo = function(x, y) {
        if (typeof x === "object") {
          this.scrollLeft = x.left;
          this.scrollTop = x.top;
        } else {
          this.scrollLeft = x;
          this.scrollTop = y;
        }
      };
    if (!Element.prototype.replaceWith)
      Element.prototype.replaceWith = function(...nodes) {
        const parent = this.parentNode;
        if (parent) {
          if (nodes.length === 0)
            parent.removeChild(this);
          for (let i = nodes.length - 1; i >= 0; i--) {
            let node = nodes[i];
            if (typeof node === "string")
              node = document.createTextNode(node);
            else if (node.parentNode)
              node.parentNode.removeChild(node);
            if (!i)
              parent.replaceChild(node, this);
            else
              parent.insertBefore(this.previousSibling, node);
          }
        }
      };
  }

  // external/mkdocs-material/src/templates/assets/javascripts/bundle.ts
  function fetchSearchIndex() {
    if (location.protocol === "file:") {
      return watchScript(
        `${new URL("search/search_index.js", config5.base)}`
      ).pipe(
        // @ts-ignore - @todo fix typings
        map(() => __index),
        shareReplay(1)
      );
    } else {
      return requestJSON(
        new URL("search/search_index.json", config5.base)
      );
    }
  }
  document.documentElement.classList.remove("no-js");
  document.documentElement.classList.add("js");
  var document$ = watchDocument();
  var location$ = watchLocation();
  var target$ = watchLocationTarget(location$);
  var keyboard$ = watchKeyboard();
  var viewport$2 = watchViewport();
  var tablet$ = watchMedia("(min-width: 960px)");
  var screen$ = watchMedia("(min-width: 1220px)");
  var print$ = watchPrint();
  var config5 = configuration();
  var index$ = document.forms.namedItem("search") ? fetchSearchIndex() : NEVER;
  var alert$ = new Subject();
  setupClipboardJS({ alert$ });
  var progress$ = new Subject();
  if (feature("navigation.instant"))
    setupInstantNavigation({ location$, viewport$: viewport$2, progress$ }).subscribe(document$);
  if (config5.version?.provider === "mike")
    setupVersionSelector({ document$ });
  merge(location$, target$).pipe(
    delay(125)
  ).subscribe(() => {
    setToggle("drawer", false);
    setToggle("search", false);
  });
  keyboard$.pipe(
    filter(({ mode }) => mode === "global")
  ).subscribe((key) => {
    switch (key.type) {
      /* Go to previous page */
      case "p":
      case ",":
        const prev = getOptionalElement("link[rel=prev]");
        if (typeof prev !== "undefined")
          setLocation(prev);
        break;
      /* Go to next page */
      case "n":
      case ".":
        const next = getOptionalElement("link[rel=next]");
        if (typeof next !== "undefined")
          setLocation(next);
        break;
      /* Expand navigation, see https://bit.ly/3ZjG5io */
      case "Enter":
        const active = getActiveElement();
        if (active instanceof HTMLLabelElement)
          active.click();
    }
  });
  patchEllipsis({ viewport$: viewport$2, document$ });
  patchIndeterminate({ document$, tablet$ });
  patchScrollfix({ document$ });
  patchScrolllock({ viewport$: viewport$2, tablet$ });
  var header$ = watchHeader(getComponentElement("header"), { viewport$: viewport$2 });
  var main$ = document$.pipe(
    map(() => getComponentElement("main")),
    switchMap((el) => watchMain(el, { viewport$: viewport$2, header$ })),
    shareReplay(1)
  );
  var control$ = merge(
    ...getComponentElements("consent").map((el) => mountConsent(el, { target$ })),
    ...getComponentElements("dialog").map((el) => mountDialog(el, { alert$ })),
    ...getComponentElements("palette").map((el) => mountPalette(el)),
    ...getComponentElements("progress").map((el) => mountProgress(el, { progress$ })),
    ...getComponentElements("search").map((el) => mountSearch(el, { index$, keyboard$ })),
    ...getComponentElements("source").map((el) => mountSource(el))
  );
  var content$ = defer(() => merge(
    ...getComponentElements("announce").map((el) => mountAnnounce(el)),
    ...getComponentElements("content").map((el) => mountContent(el, { viewport$: viewport$2, target$, print$ })),
    ...getComponentElements("content").map(
      (el) => feature("search.highlight") ? mountSearchHiglight(el, { index$, location$ }) : EMPTY
    ),
    ...getComponentElements("header").map((el) => mountHeader(el, { viewport$: viewport$2, header$, main$ })),
    ...getComponentElements("header-title").map((el) => mountHeaderTitle(el, { viewport$: viewport$2, header$ })),
    ...getComponentElements("sidebar").map(
      (el) => el.getAttribute("data-md-type") === "navigation" ? at(screen$, () => mountSidebar(el, { viewport$: viewport$2, header$, main$ })) : at(tablet$, () => mountSidebar(el, { viewport$: viewport$2, header$, main$ }))
    ),
    ...getComponentElements("tabs").map((el) => mountTabs(el, { viewport$: viewport$2, header$ })),
    ...getComponentElements("toc").map((el) => mountTableOfContents(el, {
      viewport$: viewport$2,
      header$,
      main$,
      target$
    })),
    ...getComponentElements("top").map((el) => mountBackToTop(el, { viewport$: viewport$2, header$, main$, target$ }))
  ));
  var component$ = document$.pipe(
    switchMap(() => content$),
    mergeWith(control$),
    shareReplay(1)
  );
  component$.subscribe();
  window.document$ = document$;
  window.location$ = location$;
  window.target$ = target$;
  window.keyboard$ = keyboard$;
  window.viewport$ = viewport$2;
  window.tablet$ = tablet$;
  window.screen$ = screen$;
  window.print$ = print$;
  window.alert$ = alert$;
  window.progress$ = progress$;
  window.component$ = component$;

  // src/assets/javascripts/utils/eventHandlers.ts
  var import_tablesort = __toESM(require_tablesort());
  var customWindow = window;
  var { location$: location$2, viewport$: viewport$3 } = customWindow;
  var preventDefault = (ev) => {
    ev.preventDefault();
    return ev;
  };
  var watchMediaQuery = (query) => {
    const mql = customWindow.matchMedia(query);
    const listener = mql.addEventListener || customWindow.matchMedia(query).addListener;
    const remover = mql.removeEventListener || customWindow.matchMedia(query).removeListener;
    return merge(fromEventPattern((handler) => listener("change", () => handler(mql.matches)), (handler) => remover("change", () => handler(mql.matches))), of(mql.matches).pipe(startWith(mql.matches))).pipe(debounceTime(150), distinctUntilChanged(), shareReplay(1));
  };
  var isPageVisible$ = fromEvent(document, "visibilitychange").pipe(map(() => !document.hidden || document.visibilityState === "visible"), debounceTime(200), distinctUntilChanged(), startWith(document.visibilityState === "visible"), shareReplay(1));
  var prefersReducedMotion$ = watchMediaQuery("(prefers-reduced-motion: reduce)").pipe(share());
  var header$2 = watchHeader(getComponentElement("header"), { viewport$: viewport$3 });
  function isPartiallyInViewport(el) {
    return watchViewportAt(el, { viewport$: viewport$3, header$: header$2 }).pipe(map(({ offset: { y }, size: { height } }) => {
      const elementHeight = el.offsetHeight;
      return y < height && y + elementHeight > 0;
    }), distinctUntilChanged(), shareReplay(1));
  }
  var mapLocation = (ev) => {
    const eventMap = {
      beforeunload: ev.target && ev.target instanceof HTMLAnchorElement ? new URL(ev.target.href) : getLocation(),
      popstate: ev.state ? new URL(ev.state.url) : getLocation(),
      hashchange: ev.newURL ? new URL(ev.newURL) : getLocation(),
      pageshow: ev.persisted ? getLocation() : new URL(customWindow.location.href)
    };
    return eventMap[ev.type] || getLocation();
  };
  var navigationEvents$ = "navigation" in customWindow ? (
    // If the browser supports the navigation event, we use it
    fromEventPattern((handler) => customWindow.navigation.addEventListener("navigate", handler), (handler) => customWindow.navigation.removeEventListener("navigate", handler)).pipe(filter((event) => event !== null && event instanceof NavigateEvent), map((event) => {
      return new URL(event.destination.url);
    }), startWith(getLocation()), shareReplay(1), share())
  ) : merge(merge(fromEvent(customWindow, "popstate"), fromEvent(customWindow, "hashchange"), fromEvent(customWindow, "pageshow"), fromEvent(customWindow, "beforeunload")).pipe(filter((event) => isValidEvent(event)), map((event) => {
    return mapLocation(event);
  })), location$2.pipe(distinctUntilChanged())).pipe(startWith(getLocation()), shareReplay(1), share());
  async function windowEvents() {
    const { document$: document$5, location$: location$3, target$: target$2, keyboard$: keyboard$2, viewport$: viewport$5, tablet$: tablet$2, screen$: screen$2, print$: print$2, alert$: alert$2, progress$: progress$2, component$: component$2 } = customWindow;
    const observables = {
      document$: document$5,
      location$: location$3,
      target$: target$2,
      keyboard$: keyboard$2,
      viewport$: viewport$5,
      tablet$: tablet$2,
      screen$: screen$2,
      print$: print$2,
      alert$: alert$2,
      progress$: progress$2,
      component$: component$2
    };
    let observablesMissing = false;
    for (const key in observables) {
      if (!globalThis[key]) {
        observablesMissing = true;
      }
    }
    if (observablesMissing) {
      bundle_exports;
    }
  }
  var handleLicenseHash = (url2) => {
    if (url2.pathname !== new URL(customWindow.location.href).pathname) {
      const newUrl = new URL(customWindow.location.href);
      newUrl.hash = "";
      customWindow.history.replaceState({}, "", newUrl.toString());
      customWindow.location.href = newUrl.toString();
    }
    const hash = url2.hash.slice(1);
    const input = document.getElementById(hash);
    if (input) {
      ;
      input.checked = true;
      input.dispatchEvent(new Event("change"));
    }
  };
  function addLicenseHashListener() {
    customWindow.addEventListener("hashchange", (ev) => {
      const url2 = new URL(customWindow.location.href);
      if (isLicenseHash(url2)) {
        preventDefault(ev);
      }
    });
  }
  function watchLicenseHash() {
    return combineLatest([
      navigationEvents$.pipe(take(1), tap(() => addLicenseHashListener())),
      navigationEvents$.pipe(
        // skip the first value, as we've already handled it
        skip(1),
        // only emit while the pathname remains the same (i.e., we're watching the same page for hash changes)
        takeUntil(navigationEvents$.pipe(distinctUntilChanged((prev, curr) => prev.pathname === curr.pathname)))
      )
    ]).pipe(filter(([first2, second]) => first2.pathname === second.pathname), map(([_, second]) => second), filter((url2) => isLicenseHash(url2)), tap(handleLicenseHash));
  }

  // src/assets/javascripts/fetchWorker.ts
  var import_cache_meta = __require("../../cache_meta.MLCPS6VI.json");
  if ("serviceWorker" in navigator && window.isSecureContext) {
    logger.info("Registering service worker");
    navigator.serviceWorker.register(import_cache_meta.worker, { scope: "/" }).then((registration) => {
      if (registration.installing) {
        logger.info("Service worker installing");
      } else if (registration.waiting) {
        logger.info("Service worker installed");
      } else if (registration.active) {
        logger.info("Service worker active");
      }
    });
  }

  // src/assets/javascripts/features/feedback/feedback.ts
  var feedback = () => {
    const feedbackForm = document.forms?.namedItem("feedback");
    if (feedbackForm && feedbackForm instanceof HTMLFormElement) {
      return fromEvent(feedbackForm, "submit").pipe(filter(isValidEvent), map((ev) => {
        return ev;
      }), tap(() => preventDefault), throttleTime(3e3), tap((ev) => {
        const page = document.location.pathname;
        const data = ev.submitter?.getAttribute("data-md-value");
        logger.info(page, data);
        if (feedbackForm.firstElementChild && feedbackForm.firstElementChild instanceof HTMLButtonElement) {
          feedbackForm.firstElementChild.disabled = true;
        }
        const note = feedbackForm.querySelector(`.md-feedback__note [data-md-value='${data}']`);
        if (note && note instanceof HTMLElement) {
          note.hidden = false;
        }
      }));
    } else {
      return of(null);
    }
  };

  // src/assets/javascripts/features/licenses/tabManager.ts
  var TabManager = class {
    /**
     * @description Initializes tab elements and sets up interactions
     */
    constructor() {
      this.selectors = {
        inputs: '.tabbed-set input[type="radio"]',
        iconPrefix: "#icon-"
      };
      this.disclaimerTabSelectors = {
        inputs: "#not-advice-warning-checkbox, #not-official-warning-checkbox",
        labelAnchors: "#not-advice-warning-label, #not-official-warning-label"
      };
      this.subscription = new Subscription();
      this.tabs = this.initializeTabs();
      this.childTabs = this.initializeChildTabs();
      this.init();
    }
    /**
     * @returns {TabElement[]} Collection of initialized tab elements
     * @description Initializes tab elements by querying the DOM for input, label, and icon elements
     */
    initializeTabs() {
      const inputs = Array.from(document.querySelectorAll(this.selectors.inputs));
      return inputs.map((input) => {
        const { id } = input;
        const label = document.querySelector(`label[for="${id}"]`);
        const elements = {
          input,
          label,
          labelAnchor: label.querySelector("a"),
          iconAnchor: document.querySelector(`${this.selectors.iconPrefix}${id}`),
          iconSVG: document.querySelector(`${this.selectors.iconPrefix}${id}`)?.querySelector("svg"),
          contentElement: document.querySelector(`#${id}`),
          tablistElement: document.querySelector(".tabbed-set")
        };
        return Object.values(elements).every((el) => el) ? elements : null;
      }).filter((tab) => tab !== null);
    }
    initializeChildTabs() {
      const inputs = Array.from(document.querySelectorAll(this.disclaimerTabSelectors.inputs));
      const labels = Array.from(document.querySelectorAll(this.disclaimerTabSelectors.labelAnchors));
      return inputs.map((input) => {
        const { id } = input;
        const idPrefix = id.split("-")[1];
        const label = labels.find((label2) => label2.id.includes(idPrefix));
        const elements = {
          labelAnchor: label,
          input
        };
        return Object.values(elements).every((el) => el) ? elements : null;
      }).filter((tab) => tab !== null);
    }
    setAria() {
      this.tabs.forEach((tab) => {
        const { contentElement, input, labelAnchor, label, iconAnchor, iconSVG, tablistElement } = tab;
        tablistElement.setAttribute("role", "tablist");
        contentElement.setAttribute("role", "tabpanel");
        contentElement.setAttribute("aria-labelledby", `${label.id || labelAnchor.id} ${iconAnchor.id}`);
        input.setAttribute("aria-hidden", "true");
        labelAnchor.setAttribute("role", "tab");
        labelAnchor.setAttribute("aria-selected", input.checked ? "true" : "false");
        labelAnchor.setAttribute("aria-controls", contentElement.id);
        labelAnchor.setAttribute("tabindex", labelAnchor.href === "#reader" ? "0" : "-1");
        iconSVG.setAttribute("role", "button");
        iconAnchor.setAttribute("role", "tab");
        iconAnchor.setAttribute("aria-selected", input.checked ? "true" : "false");
        iconAnchor.setAttribute("aria-controls", contentElement.id);
      });
    }
    toggleAriaSelected(tabEls) {
      const checkedState = tabEls.map((tab) => tab.input.checked);
      const anchors = tabEls.map((tab) => {
        if ("iconAnchor" in tab) {
          return [tab.labelAnchor, tab.iconAnchor];
        }
        return [tab.labelAnchor];
      });
      checkedState.forEach((checked, index) => {
        anchors[index].forEach((anchor) => {
          anchor.setAttribute("aria-selected", checked ? "true" : "false");
        });
      });
    }
    /**
     * @param {TabElement} tab - Tab element to style
     * @param {TabState} state - Tab state object
     * @description Styles tab elements based on state
     */
    styleTab(tab, { isSelected, state }) {
      const { label, iconAnchor, iconSVG } = tab;
      const fillColor = state === "normal" ? "" : "var(--hover-color)";
      const selectedColor = "var(--selected-color)";
      iconAnchor.classList.toggle("selected", isSelected);
      iconSVG.style.fill = isSelected ? selectedColor : fillColor;
      label.style.color = isSelected ? selectedColor : fillColor;
    }
    /**
     * @returns {Observable<void>} Observable for tab interactions
     * @description Sets up interaction streams for tab elements
     */
    setupInteractions() {
      const createEventStream = (elements, eventName) => {
        const streams = elements.flatMap(({ label, iconAnchor }) => [
          fromEvent(label, eventName).pipe(map(() => ({ id: label.getAttribute("for"), event: eventName }))),
          fromEvent(iconAnchor, eventName).pipe(map(() => ({ id: iconAnchor.id.replace("icon-", ""), event: eventName })))
        ]);
        return merge(...streams).pipe(share());
      };
      const eventStateMap = {
        mouseenter: "hover",
        mouseleave: "normal",
        focus: "focus",
        "focus-visible": "focus-visible",
        blur: "normal"
      };
      const events = ["mouseenter", "mouseleave", "focus", "focus-visible", "blur"];
      const interactionStreams = events.map((event) => createEventStream(this.tabs, event));
      const iconClicks = this.tabs.map(({ iconAnchor, input, labelAnchor }) => merge(fromEvent(labelAnchor, "click"), fromEvent(iconAnchor, "click")).pipe(tap(() => {
        preventDefault;
        if (!input.checked) {
          input.checked = true;
          this.toggleAriaSelected(this.tabs);
          input.dispatchEvent(new Event("change"));
        }
      }), map(() => ({ id: input.id, event: "click" }))));
      const childClicks = this.childTabs.map(({ input, labelAnchor }) => fromEvent(labelAnchor, "click").pipe(tap(() => {
        preventDefault;
        if (!input.checked) {
          input.checked = true;
          this.toggleAriaSelected(this.childTabs);
          input.dispatchEvent(new Event("change"));
        }
      }), map(() => ({ id: input.id, event: "click" }))));
      const selections = this.tabs.map(({ input }) => fromEvent(input, "change").pipe(map(() => input.id), filter((id) => !!id)));
      return merge(...interactionStreams, ...iconClicks, ...childClicks, ...selections).pipe(filter((event) => typeof event === "object" && "id" in event && "event" in event), debounceTime(30), tap((event) => {
        const { id, event: eventName } = event;
        const tab = this.tabs.find((t) => t.input.id === id);
        if (tab) {
          this.styleTab(tab, {
            isSelected: tab.input.checked,
            state: eventStateMap[eventName] || "normal"
          });
        }
      }), map(() => void 0));
    }
    /**
     * @description Initializes tab styles and sets up interaction streams
     */
    init() {
      logger.info("Initializing license tabs");
      this.setAria();
      this.tabs.forEach((tab) => {
        this.styleTab(tab, { isSelected: tab.input.checked, state: "normal" });
      });
      this.subscription = this.setupInteractions().subscribe({
        error: (err) => logger.error("Error setting up license tabs:", err)
      });
      const allAnchors = [];
      this.tabs.forEach((tab) => {
        allAnchors.push(tab.labelAnchor, tab.iconAnchor);
      });
      this.childTabs.forEach((tab) => {
        allAnchors.push(tab.labelAnchor);
      });
      allAnchors.forEach((anchor) => {
        anchor.addEventListener("click", preventDefault);
      });
    }
    /**
     * @description Unsubscribes from event streams and performs cleanup
     */
    cleanup() {
      logger.info("Cleaning up license tabs");
      if (this.subscription) {
        this.subscription.unsubscribe();
      }
    }
  };

  // src/assets/javascripts/features/licenses/index.ts
  var customWindow2 = window;
  var { document$: document$2 } = customWindow2;
  function initLicenseFeature() {
    let tabManager = null;
    return document$2.pipe(tap(() => {
      tabManager?.cleanup?.();
      tabManager = new TabManager();
      logger.info("License feature initialized");
    }), map(() => {
      return tabManager?.subscription;
    }));
  }

  // src/assets/javascripts/state/predicates.ts
  var predicates_exports = {};
  __export(predicates_exports, {
    isFullyVisible: () => isFullyVisible,
    noVideo: () => noVideo,
    videoPredicate: () => videoPredicate
  });
  var isFullyVisible = (state) => state.atHome && state.landingVisible && state.pageVisible;
  var noVideo = (state) => state.prefersReducedMotion;
  var videoPredicate = {
    canPlay: (state) => isFullyVisible(state) && !noVideo(state)
  };

  // src/assets/javascripts/state/store.ts
  var customWindow3 = window;
  var weAreDev = isDev(new URL(customWindow3.location.href));
  var { viewport$: viewport$4 } = customWindow3;
  var initialUrl = new URL(customWindow3.location.href);
  var _HeroStore = class _HeroStore {
    /**
     * @description Initializes the HeroStore singleton instance
     */
    constructor() {
      // state$ is a BehaviorSubject that holds the current state of the hero section
      this.state$ = new BehaviorSubject({
        atHome: isHome(initialUrl),
        landingVisible: isHome(initialUrl),
        pageVisible: !document.hidden || document.visibilityState === "visible",
        prefersReducedMotion: customWindow3.matchMedia("(prefers-reduced-motion: reduce)").matches,
        viewport: {
          offset: getViewportOffset(),
          size: getViewportSize()
        },
        header: { height: 0, hidden: true },
        parallaxHeight: getViewportOffset().y * 1.4,
        location: initialUrl,
        tearDown: false
      });
      this.videoState$ = new BehaviorSubject({ canPlay: false });
      this.parallaxHeight$ = new BehaviorSubject(getViewportOffset().y * 1.4);
      this.subscriptions = new Subscription();
      this.initSubscriptions();
    }
    /**
     * @returns {HeroStore} Singleton instance of the HeroStore
     * @description Static singleton instance getter
     */
    static getInstance() {
      return _HeroStore.instance ?? (_HeroStore.instance = new _HeroStore());
    }
    /**
     * @param {Partial<HeroState>} update - Partial state object to update the hero state
     * @param {AnimationComponent} component Optional component to update
     * @description Updates the hero state with a partial state
     */
    updateState(update, component) {
      if (weAreDev) {
        this.debugStateChange(update);
      }
      const keys = Object.keys(update);
      if (keys[0] in this.state$.value) {
        this.state$.next({ ...this.state$.value, ...update });
        return;
      }
      switch (component) {
        case "video" /* Video */:
          this.videoState$.next(update);
          break;
        // there were more cases, but we simplified it by moving to the video.
        // keeping this to make it easier to add components in the future.
        case void 0:
          try {
            this.state$.next({ ...this.state$.value, ...update });
          } catch (error) {
            logger.error(`Error updating state: ${error}
Update: ${update}`);
          }
      }
    }
    /**
     * @param {Partial<HeroState>} updates - Partial state object to update the hero state
     * @param {AnimationComponent} component Optional component to update state
     * @description Updates the hero state with a partial state
     */
    updateHeroState(updates, component) {
      logger.info("external component updating state; updates:", updates);
      this.updateState(updates, component);
    }
    /**
     * @param {string} name - Name of the observable
     * @param {(T) => Partial<HeroState>} updateFn - Function to update state based on observable value
     * @returns {Observer<T>} - Observer for the observable
     * @description Creates an observer for an observable
     */
    createObserver(name, updateFn, component) {
      return {
        next: (value) => {
          logger.info(`${name} received:`, value);
          this.updateState(updateFn(value), component);
        },
        error: (error) => logger.error(`Error in ${name}:`, error),
        complete: () => logger.info(`${name} completed`)
      };
    }
    /**
     * @description Initializes all observables and subscriptions
     */
    initSubscriptions() {
      const atHome$ = navigationEvents$.pipe(map(isHome), distinctUntilChanged(), startWith(isHome(initialUrl)), shareReplay(1), tap(this.createObserver("atHome$", (atHome) => ({ atHome }))));
      const landing$ = isPartiallyInViewport(document.getElementById("parallax-hero-image-layer")).pipe(filter((landing) => landing !== void 0 && landing !== null));
      const landingVisible$ = atHome$.pipe(filter((atHome) => atHome), switchMap(() => landing$), filter((landingVisible) => landingVisible && landingVisible !== void 0 && landingVisible !== null), tap(this.createObserver("landingVisible$", (landingVisible) => ({ landingVisible }))));
      const pageVisible$ = isPageVisible$.pipe(tap(this.createObserver("pageVisible$", (pageVisible) => ({ pageVisible }))));
      const motion$ = prefersReducedMotion$.pipe(tap(this.createObserver("prefersReducedMotion$", (prefersReducedMotion) => ({
        prefersReducedMotion
      }))));
      const view$ = viewport$4.pipe(distinctUntilChanged(), debounceTime(100), shareReplay(1), tap((viewport) => {
        setCssVariable("--viewport-offset-height", `${viewport.offset.y}px`);
        setCssVariable("--viewport-offset-width", `${viewport.offset.x}px`);
      }), tap(this.createObserver("view$", (viewport) => ({ viewport }))));
      const header$3 = watchHeader(getComponentElement("header"), { viewport$: viewport$4 }).pipe(tap((header) => {
        setCssVariable("--header-height", header.hidden ? "0" : `${header.height}px`);
      }), tap(this.createObserver("header$", (header) => ({ header }))));
      const parallax$ = combineLatest([
        viewport$4,
        watchHeader(getComponentElement("header"), { viewport$: viewport$4 }),
        watchMediaQuery("(orientation: portrait)")
      ]).pipe(map(([viewport, header, portrait]) => {
        return {
          viewHeight: viewport.offset.y,
          headerHeight: header.height,
          portrait
        };
      }), map(({ viewHeight, headerHeight, portrait }) => {
        const adjustedHeight = viewHeight - headerHeight;
        return portrait ? adjustedHeight * 1.4 : adjustedHeight * 1.6;
      }), distinctUntilChanged(), shareReplay(1), tap((parallaxHeight) => {
        setCssVariable("--parallax-height", `${parallaxHeight}px`);
      }), tap(this.createObserver("parallaxHeight$", (parallaxHeight) => ({ parallaxHeight }))));
      const location$3 = navigationEvents$.pipe(tap(this.createObserver("location$", (location2) => ({ location: location2 }))));
      const video$ = this.getVideoState$((v) => this.videoState$.next(v));
      this.subscriptions.add(atHome$.subscribe());
      this.subscriptions.add(landingVisible$.subscribe());
      this.subscriptions.add(pageVisible$.subscribe());
      this.subscriptions.add(motion$.subscribe());
      this.subscriptions.add(view$.subscribe());
      this.subscriptions.add(header$3.subscribe());
      this.subscriptions.add(location$3.subscribe());
      this.subscriptions.add(parallax$.subscribe());
      this.subscriptions.add(video$.subscribe());
    }
    /**
     * @returns {HeroState} Current state of the hero section
     * @description Gets the current state of the hero section
     */
    getState() {
      return this.state$.getValue();
    }
    /**
     * @param {string} subject - Name of the state subject
     * @returns {any} - Current value of the state subject
     * @description Gets the current value of a specific state subject
     */
    getStateValue(subject) {
      return this.state$.value[subject];
    }
    /**
     * @param {string} component - Name of the component
     * @returns {ComponentState} - Current state of the component
     * @description Gets the current state of a specific
     * component or landing permissions
     */
    getComponentValue(component) {
      switch (component) {
        case "video" /* Video */:
          return this.videoState$.value;
        default:
          return this.videoState$.value;
      }
    }
    /** ============================================
     *          Component Specific Observables
     *=============================================**/
    /**
     * @param {string} name - Name of the observable
     * @param {ComponentStateUpdateFunction} func - Function to update the component state
     * @returns {Observer<T>} - Observer for the observable
     * @description Creates a standard observer for a component observable
     */
    getComponentObserver(name, func) {
      return {
        next: (value) => {
          logger.info(`${name} received:`, value);
          if (func) {
            ;
            (value2) => func(value2);
          }
        },
        error: (error) => logger.error(`Error in ${name}:`, error),
        complete: () => logger.info(`${name} completed`)
      };
    }
    /**
     * @param {ComponentStateUpdateFunction} observerFunc Function to update the component state
     * @returns {Observable<VideoState>} Observable for carousel state indicating play and pause conditions
     * @description Creates an observable for the carousel state indicating play and pause conditions
     */
    getVideoState$(observerFunc) {
      return this.state$.pipe(map((state) => ({
        canPlay: videoPredicate.canPlay(state)
      })), distinctUntilKeyChanged("canPlay"), shareReplay(1), tap(this.getComponentObserver("carouselState$", observerFunc)));
    }
    /**
     * @param {Partial<HeroState>} updates - Partial state object to update the hero state
     * @description Logs and updates state changes for debugging
     */
    debugStateChange(updates) {
      if (weAreDev) {
        const oldState = this.state$.value;
        const changes = Object.entries(updates).filter(([key, value]) => oldState[key] !== value);
        logger.info("Changes:", Object.fromEntries(changes));
        logger.info("New State:", { ...oldState, ...updates });
        Object.entries(predicates_exports).filter(([_, value]) => typeof value === "function").forEach(([name, predicate]) => {
          logger.info(`${name}:`, predicate({ ...oldState, ...updates }));
        });
      }
    }
    /**
     * @method destroy
     * @public
     * @description Unsubscribes from all observables and resets the singleton instance
     */
    destroy() {
      this.subscriptions.unsubscribe();
      _HeroStore.instance = void 0;
    }
  };
  _HeroStore.instance = new _HeroStore();
  var HeroStore = _HeroStore;

  // src/assets/javascripts/features/hero/animations/utils.ts
  var store = HeroStore.getInstance();
  function getMatchMediaInstance(scope) {
    return gsapWithCSS.matchMedia(scope || document.documentElement);
  }
  function getDistanceToViewport(target, edge = "bottom") {
    const rect = target.getBoundingClientRect();
    const { viewport } = store.state$.getValue();
    const distanceMap = {
      top: rect.top,
      right: viewport.offset.x - rect.right,
      bottom: viewport.offset.y - rect.bottom,
      left: rect.left
    };
    return distanceMap[edge];
  }
  function getContentElements(element) {
    return gsapWithCSS.utils.toArray(element.querySelectorAll("*")).filter((el) => isValidElement(el, element));
  }
  function modifyDurationForReducedMotion(duration) {
    let newDuration = duration;
    getMatchMediaInstance().add({ reducedMotion: "(prefers-reduced-motion: reduce)" }, (context4) => {
      const { reducedMotion } = context4.conditions;
      if (reducedMotion) {
        switch (typeof duration) {
          case "number":
            newDuration = duration * 2;
            break;
          case "string":
            newDuration = parseFloat(duration) * 2;
            break;
          default:
            newDuration = duration;
        }
      } else {
        newDuration = duration;
      }
    });
    return newDuration;
  }
  function wordsToLetterDivs(el) {
    const docFragment = document.createDocumentFragment();
    let text = "";
    if (typeof el === "string") {
      text = el;
    } else {
      text = el.innerText;
    }
    const letters = text.trim().split("");
    letters.forEach((letter, idx) => {
      if (idx === 0 && (letter === " " || letter === "\n")) {
        return;
      }
      const textNode = document.createTextNode(letter);
      if (letter === " " || letter === "\n") {
        const lastEl = docFragment.lastChild;
        lastEl?.appendChild(textNode);
      }
      const newDiv = document.createElement("div");
      newDiv.appendChild(textNode);
      newDiv.classList.add("hero__letter");
      docFragment.appendChild(newDiv);
    });
    if (el instanceof HTMLElement) {
      gsapWithCSS.set(el, { innerText: "" });
    }
    gsapWithCSS.set(docFragment.querySelectorAll("div"), { display: "inline-block", autoAlpha: 0 });
    return docFragment;
  }

  // src/assets/javascripts/features/hero/animations/effects.ts
  function getFadeVars(out = false, yPercent, direction) {
    const defaultDirection = out ? -1 /* UP */ : 1 /* DOWN */;
    const pathDirection = direction || defaultDirection;
    return {
      from: { autoAlpha: out ? 1 : 0, yPercent: out ? 0 : pathDirection * yPercent },
      to: { autoAlpha: out ? 0 : 1, yPercent: out ? pathDirection * yPercent : 0 }
    };
  }
  function getDFactor(direction) {
    return direction === -1 /* UP */ ? -1 /* UP */ : 1 /* DOWN */;
  }
  gsapWithCSS.registerEffect({
    name: "setSection",
    extendTimeline: true,
    defaults: { extendTimeline: true },
    effect: (config6) => {
      const { direction, section } = config6;
      logger.info(`setSection: direction: ${direction.toString()}, section: ${JSON.stringify(section), getCircularReplacer(), 2}`);
      const dFactor = getDFactor(direction);
      const tl = gsapWithCSS.timeline();
      tl.add(gsapWithCSS.set(section.element, { zIndex: 0 })).add(gsapWithCSS.to(section.bg, { yPercent: -15 * dFactor })).add(gsapWithCSS.set(section.element, { autoAlpha: 0 })).add(gsapWithCSS.set(section.content, { autoAlpha: 0 }));
    }
  });
  gsapWithCSS.registerEffect({
    name: "transitionSection",
    extendTimeline: true,
    defaults: { extendTimeline: true },
    effect: (config6) => {
      const { direction, section } = config6;
      logger.info(`transitionSection: direction: ${direction.toString()}, section: ${JSON.stringify(section, getCircularReplacer(), 2)}`);
      logger.info(`config object: ${JSON.stringify(config6, getCircularReplacer(), 2)}`);
      const dFactor = getDFactor(direction);
      const tl = gsapWithCSS.timeline();
      tl.fromTo([section.outerWrapper, section.innerWrapper], {
        yPercent: (i) => i ? i * -100 * dFactor : 100 * dFactor
      }, {
        yPercent: 0
      }, 0).fromTo(section.bg, {
        yPercent: 15 * dFactor
      }, {
        yPercent: 0
      }, 0).set(section.element, { zIndex: 1, autoAlpha: 1 }).fromTo(section.content, {
        autoAlpha: 0,
        yPercent: 50 * dFactor
      }, {
        autoAlpha: 1,
        yPercent: 0,
        stagger: {
          each: 0.1,
          axis: "y",
          from: direction === -1 /* UP */ ? "start" : "end"
        }
      }, 0.2);
      if (section.animation) {
        tl.add(section.animation, ">=wrapperTransition");
      }
      return tl;
    }
  });
  var fade = (targets, config6 = { out: false, direction: 1, fromConfig: {}, toConfig: {} }) => {
    logger.info(`fade: targets: ${targets}, config: ${JSON.stringify(config6, getCircularReplacer(), 2)}`);
    const media = getMatchMediaInstance();
    const tl = gsapWithCSS.timeline();
    media.add({ reducedMotion: "(prefers-reduced-motion: reduce)" }, (context4) => {
      const { out, direction, fromConfig, toConfig } = config6;
      if (fromConfig && toConfig) {
        const fadeVars = getFadeVars(out, Number(fromConfig.yPercent) || Number(toConfig?.yPercent) || 50, direction || null);
        const fromVars = { ...fadeVars.from, ...fromConfig };
        const toVars = { ...fadeVars.to, ...toConfig };
        const { reducedMotion } = context4.conditions;
        if (reducedMotion) {
          const modifiedVars = [fromVars, toVars].map((vars) => {
            let modified = { ...vars };
            if (modified.yPercent) {
              delete modified.yPercent;
            } else if (modified.duration) {
              modified.duration = modifyDurationForReducedMotion(vars.duration || 0.5);
            }
            return modified;
          });
          tl.add(gsapWithCSS.fromTo(targets, modifiedVars[0], modifiedVars[1]));
        } else {
          tl.add(gsapWithCSS.fromTo(targets, {
            ...fromVars
          }, {
            ...toVars
          }));
        }
      }
    });
    return tl;
  };
  gsapWithCSS.registerEffect({
    name: "fadeIn",
    extendTimeline: true,
    effect: (targets, config6) => {
      logger.info(`fadeIn: targets: ${targets}, config: ${JSON.stringify(config6, getCircularReplacer(), 2)}`);
      const { direction, fromConfig, toConfig } = config6;
      targets = targets instanceof Array ? targets : [targets];
      return fade(targets, { out: false, direction, fromConfig, toConfig });
    }
  });
  gsapWithCSS.registerEffect({
    name: "fadeOut",
    extendTimeline: true,
    defaults: { extendTimeline: true },
    effect: (targets, config6) => {
      logger.info(`fadeOut: targets: ${targets}, config: ${JSON.stringify(config6, getCircularReplacer(), 2)}`);
      const { direction, fromConfig, toConfig } = config6;
      return fade(targets, { out: true, direction, fromConfig, toConfig });
    }
  });
  var blink = (targets, config6 = {}) => {
    logger.info(`blink: targets: ${targets}, config: ${JSON.stringify(config6)}`);
    const duration = modifyDurationForReducedMotion(config6.duration || 0.5);
    return gsapWithCSS.to(targets, {
      autoAlpha: 0,
      ease: "power4.in",
      startAt: { filter: "brightness(1.3)" },
      ...config6,
      duration
    });
  };
  var jump = (targets, config6 = {}) => {
    logger.info(`jump: targets: ${targets}, config: ${JSON.stringify(config6, getCircularReplacer(), 2)}`);
    config6.y ? config6["delete"]("y") : null;
    const duration = modifyDurationForReducedMotion(config6.duration || 0.5);
    return gsapWithCSS.to(targets, {
      y: (_index, target, _targets) => {
        const distance = Math.abs(getDistanceToViewport(target));
        return -gsapWithCSS.utils.clamp(distance > 10 ? 10 : distance, distance, 25);
      },
      yoyoEase: "bounce",
      ease: "elastic",
      repeatDelay: 2,
      ...config6,
      duration
    });
  };
  var scaleUp = (targets, config6 = {}) => {
    logger.info(`scaleUp: targets: ${targets}, config: ${JSON.stringify(config6, getCircularReplacer(), 2)}`);
    const duration = modifyDurationForReducedMotion(config6.duration || 0.5);
    return gsapWithCSS.to(targets, { scale: 1.5, ease: "elastic", ...config6, duration });
  };
  gsapWithCSS.registerEffect({
    name: "emphasize",
    extendTimeline: true,
    defaults: { repeat: -1, yoyo: true, extendTimeline: true },
    effect: (targets, config6) => {
      logger.info(`emphasize: targets: ${targets}, config: ${JSON.stringify(config6, getCircularReplacer(), 2)}`);
      if (!targets) {
        return null;
      }
      const { blinkConfig, jumpConfig, scaleUpConfig } = config6;
      const emphasisTimeline = gsapWithCSS.timeline();
      getMatchMediaInstance().add({ reducedMotion: "(prefers-reduced-motion: reduce)" }, (context4) => {
        const { reducedMotion } = context4.conditions;
        if (reducedMotion) {
          emphasisTimeline.add(blink(targets, { ...blinkConfig, ease: "power1.inOut" }));
          emphasisTimeline.add(scaleUp(targets, { ...scaleUpConfig }));
        } else {
          emphasisTimeline.add(blink(targets, blinkConfig));
          emphasisTimeline.add(jump(targets, jumpConfig));
          emphasisTimeline.add(scaleUp(targets, scaleUpConfig));
        }
      });
      return emphasisTimeline;
    }
  });
  gsapWithCSS.registerEffect({
    name: "animateMessage",
    extendTimeline: true,
    defaults: { extendTimeline: true, repeat: 0 },
    effect: (target, config6) => {
      logger.info(`animateMessage: target: ${target}, config: ${JSON.stringify(config6, getCircularReplacer(), 2)}`);
      target = target instanceof Array ? target : gsapWithCSS.utils.toArray(target);
      if (!target || !(target instanceof Array)) {
        return gsapWithCSS.timeline();
      }
      target = gsapWithCSS.utils.toArray(target).filter((el) => el !== null && el instanceof HTMLElement);
      let msgFrag = document.createDocumentFragment();
      let animationElements = [];
      if (config6.message) {
        msgFrag = wordsToLetterDivs(config6.message);
        target = target.slice(0, 1);
        if (target instanceof Array && target.length > 0 && target[0] && target[0] instanceof HTMLElement) {
          requestAnimationFrame(() => {
            const element = target[0];
            element.append(msgFrag);
            animationElements = gsapWithCSS.utils.toArray(element.querySelectorAll("div")).filter((el) => el !== null && el instanceof HTMLElement && el.innerText !== "");
          });
        } else {
          return gsapWithCSS.timeline();
        }
      } else {
        gsapWithCSS.utils.toArray(target).forEach((el) => {
          if (el instanceof HTMLElement) {
            const text = wordsToLetterDivs(el);
            requestAnimationFrame(() => {
              el.append(text);
            });
            animationElements.push(el);
          }
        });
      }
      const messageTimeline = gsapWithCSS.timeline();
      messageTimeline.add(["setState", gsapWithCSS.set(animationElements, { autoAlpha: 0 })], 0);
      let fromVars = config6.entranceFromVars || {};
      let toVars = config6.entranceToVars || {};
      let exitVars = config6.exitVars || {};
      gsapWithCSS.matchMedia().add({ reducedMotion: "(prefers-reduced-motion: reduce)" }, (context4) => {
        const { reducedMotion } = context4.conditions;
        if (reducedMotion) {
          fromVars.yPercent = 50;
          toVars.ease = "power1.inOut";
          toVars.stagger = { each: 0.04, from: "start" };
          toVars.duration = modifyDurationForReducedMotion(toVars.duration || 1);
          exitVars.duration = modifyDurationForReducedMotion(exitVars.duration || 0.5);
          exitVars.yPercent = -50;
          exitVars.ease = "power1.inOut";
          exitVars.stagger = { each: 0.04, from: "end" };
        }
      });
      messageTimeline.add([
        "randomEntrance",
        gsapWithCSS.fromTo(animationElements, { autoAlpha: 0, yPercent: 150, ...fromVars }, {
          autoAlpha: 1,
          yPercent: 0,
          stagger: { each: 0.03, from: "random" },
          duration: 1.2,
          ...toVars
        })
      ], 0.02);
      messageTimeline.add([
        "randomExit",
        gsapWithCSS.to(animationElements, {
          autoAlpha: 0,
          duration: 0.5,
          yPercent: gsapWithCSS.utils.random(-150, 150, 10),
          stagger: { each: 0.03, from: "random" },
          ...exitVars
        })
      ], 4.5);
      return messageTimeline;
    }
  });

  // node_modules/gsap/Observer.js
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  var gsap2;
  var _coreInitted2;
  var _clamp3;
  var _win3;
  var _doc3;
  var _docEl;
  var _body;
  var _isTouch;
  var _pointerType;
  var ScrollTrigger;
  var _root;
  var _normalizer;
  var _eventTypes;
  var _context2;
  var _getGSAP = function _getGSAP2() {
    return gsap2 || typeof window !== "undefined" && (gsap2 = window.gsap) && gsap2.registerPlugin && gsap2;
  };
  var _startup = 1;
  var _observers = [];
  var _scrollers = [];
  var _proxies = [];
  var _getTime = Date.now;
  var _bridge = function _bridge2(name, value) {
    return value;
  };
  var _integrate = function _integrate2() {
    var core = ScrollTrigger.core, data = core.bridge || {}, scrollers = core._scrollers, proxies = core._proxies;
    scrollers.push.apply(scrollers, _scrollers);
    proxies.push.apply(proxies, _proxies);
    _scrollers = scrollers;
    _proxies = proxies;
    _bridge = function _bridge3(name, value) {
      return data[name](value);
    };
  };
  var _getProxyProp = function _getProxyProp2(element, property) {
    return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];
  };
  var _isViewport = function _isViewport2(el) {
    return !!~_root.indexOf(el);
  };
  var _addListener = function _addListener2(element, type, func, passive, capture) {
    return element.addEventListener(type, func, {
      passive: passive !== false,
      capture: !!capture
    });
  };
  var _removeListener = function _removeListener2(element, type, func, capture) {
    return element.removeEventListener(type, func, !!capture);
  };
  var _scrollLeft = "scrollLeft";
  var _scrollTop = "scrollTop";
  var _onScroll = function _onScroll2() {
    return _normalizer && _normalizer.isPressed || _scrollers.cache++;
  };
  var _scrollCacheFunc = function _scrollCacheFunc2(f, doNotCache) {
    var cachingFunc = function cachingFunc2(value) {
      if (value || value === 0) {
        _startup && (_win3.history.scrollRestoration = "manual");
        var isNormalizing = _normalizer && _normalizer.isPressed;
        value = cachingFunc2.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0);
        f(value);
        cachingFunc2.cacheID = _scrollers.cache;
        isNormalizing && _bridge("ss", value);
      } else if (doNotCache || _scrollers.cache !== cachingFunc2.cacheID || _bridge("ref")) {
        cachingFunc2.cacheID = _scrollers.cache;
        cachingFunc2.v = f();
      }
      return cachingFunc2.v + cachingFunc2.offset;
    };
    cachingFunc.offset = 0;
    return f && cachingFunc;
  };
  var _horizontal = {
    s: _scrollLeft,
    p: "left",
    p2: "Left",
    os: "right",
    os2: "Right",
    d: "width",
    d2: "Width",
    a: "x",
    sc: _scrollCacheFunc(function(value) {
      return arguments.length ? _win3.scrollTo(value, _vertical.sc()) : _win3.pageXOffset || _doc3[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;
    })
  };
  var _vertical = {
    s: _scrollTop,
    p: "top",
    p2: "Top",
    os: "bottom",
    os2: "Bottom",
    d: "height",
    d2: "Height",
    a: "y",
    op: _horizontal,
    sc: _scrollCacheFunc(function(value) {
      return arguments.length ? _win3.scrollTo(_horizontal.sc(), value) : _win3.pageYOffset || _doc3[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;
    })
  };
  var _getTarget = function _getTarget2(t, self) {
    return (self && self._ctx && self._ctx.selector || gsap2.utils.toArray)(t)[0] || (typeof t === "string" && gsap2.config().nullTargetWarn !== false ? console.warn("Element not found:", t) : null);
  };
  var _getScrollFunc = function _getScrollFunc2(element, _ref) {
    var s = _ref.s, sc = _ref.sc;
    _isViewport(element) && (element = _doc3.scrollingElement || _docEl);
    var i = _scrollers.indexOf(element), offset = sc === _vertical.sc ? 1 : 2;
    !~i && (i = _scrollers.push(element) - 1);
    _scrollers[i + offset] || _addListener(element, "scroll", _onScroll);
    var prev = _scrollers[i + offset], func = prev || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport(element) ? sc : _scrollCacheFunc(function(value) {
      return arguments.length ? element[s] = value : element[s];
    })));
    func.target = element;
    prev || (func.smooth = gsap2.getProperty(element, "scrollBehavior") === "smooth");
    return func;
  };
  var _getVelocityProp = function _getVelocityProp2(value, minTimeRefresh, useDelta) {
    var v1 = value, v2 = value, t1 = _getTime(), t2 = t1, min = minTimeRefresh || 50, dropToZeroTime = Math.max(500, min * 3), update = function update2(value2, force) {
      var t = _getTime();
      if (force || t - t1 > min) {
        v2 = v1;
        v1 = value2;
        t2 = t1;
        t1 = t;
      } else if (useDelta) {
        v1 += value2;
      } else {
        v1 = v2 + (value2 - v2) / (t - t2) * (t1 - t2);
      }
    }, reset = function reset2() {
      v2 = v1 = useDelta ? 0 : v1;
      t2 = t1 = 0;
    }, getVelocity = function getVelocity2(latestValue) {
      var tOld = t2, vOld = v2, t = _getTime();
      (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);
      return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1e3;
    };
    return {
      update,
      reset,
      getVelocity
    };
  };
  var _getEvent = function _getEvent2(e, preventDefault2) {
    preventDefault2 && !e._gsapAllow && e.preventDefault();
    return e.changedTouches ? e.changedTouches[0] : e;
  };
  var _getAbsoluteMax = function _getAbsoluteMax2(a) {
    var max = Math.max.apply(Math, a), min = Math.min.apply(Math, a);
    return Math.abs(max) >= Math.abs(min) ? max : min;
  };
  var _setScrollTrigger = function _setScrollTrigger2() {
    ScrollTrigger = gsap2.core.globals().ScrollTrigger;
    ScrollTrigger && ScrollTrigger.core && _integrate();
  };
  var _initCore3 = function _initCore4(core) {
    gsap2 = core || _getGSAP();
    if (!_coreInitted2 && gsap2 && typeof document !== "undefined" && document.body) {
      _win3 = window;
      _doc3 = document;
      _docEl = _doc3.documentElement;
      _body = _doc3.body;
      _root = [_win3, _doc3, _docEl, _body];
      _clamp3 = gsap2.utils.clamp;
      _context2 = gsap2.core.context || function() {
      };
      _pointerType = "onpointerenter" in _body ? "pointer" : "mouse";
      _isTouch = Observer2.isTouch = _win3.matchMedia && _win3.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in _win3 || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;
      _eventTypes = Observer2.eventTypes = ("ontouchstart" in _docEl ? "touchstart,touchmove,touchcancel,touchend" : !("onpointerdown" in _docEl) ? "mousedown,mousemove,mouseup,mouseup" : "pointerdown,pointermove,pointercancel,pointerup").split(",");
      setTimeout(function() {
        return _startup = 0;
      }, 500);
      _setScrollTrigger();
      _coreInitted2 = 1;
    }
    return _coreInitted2;
  };
  _horizontal.op = _vertical;
  _scrollers.cache = 0;
  var Observer2 = /* @__PURE__ */ function() {
    function Observer3(vars) {
      this.init(vars);
    }
    var _proto = Observer3.prototype;
    _proto.init = function init5(vars) {
      _coreInitted2 || _initCore3(gsap2) || console.warn("Please gsap.registerPlugin(Observer)");
      ScrollTrigger || _setScrollTrigger();
      var tolerance = vars.tolerance, dragMinimum = vars.dragMinimum, type = vars.type, target = vars.target, lineHeight = vars.lineHeight, debounce2 = vars.debounce, preventDefault2 = vars.preventDefault, onStop = vars.onStop, onStopDelay = vars.onStopDelay, ignore = vars.ignore, wheelSpeed = vars.wheelSpeed, event = vars.event, onDragStart = vars.onDragStart, onDragEnd = vars.onDragEnd, onDrag = vars.onDrag, onPress = vars.onPress, onRelease = vars.onRelease, onRight = vars.onRight, onLeft = vars.onLeft, onUp = vars.onUp, onDown = vars.onDown, onChangeX = vars.onChangeX, onChangeY = vars.onChangeY, onChange = vars.onChange, onToggleX = vars.onToggleX, onToggleY = vars.onToggleY, onHover = vars.onHover, onHoverEnd = vars.onHoverEnd, onMove = vars.onMove, ignoreCheck = vars.ignoreCheck, isNormalizer = vars.isNormalizer, onGestureStart = vars.onGestureStart, onGestureEnd = vars.onGestureEnd, onWheel = vars.onWheel, onEnable = vars.onEnable, onDisable = vars.onDisable, onClick = vars.onClick, scrollSpeed = vars.scrollSpeed, capture = vars.capture, allowClicks = vars.allowClicks, lockAxis = vars.lockAxis, onLockAxis = vars.onLockAxis;
      this.target = target = _getTarget(target) || _docEl;
      this.vars = vars;
      ignore && (ignore = gsap2.utils.toArray(ignore));
      tolerance = tolerance || 1e-9;
      dragMinimum = dragMinimum || 0;
      wheelSpeed = wheelSpeed || 1;
      scrollSpeed = scrollSpeed || 1;
      type = type || "wheel,touch,pointer";
      debounce2 = debounce2 !== false;
      lineHeight || (lineHeight = parseFloat(_win3.getComputedStyle(_body).lineHeight) || 22);
      var id, onStopDelayedCall, dragged, moved, wheeled, locked, axis, self = this, prevDeltaX = 0, prevDeltaY = 0, passive = vars.passive || !preventDefault2 && vars.passive !== false, scrollFuncX = _getScrollFunc(target, _horizontal), scrollFuncY = _getScrollFunc(target, _vertical), scrollX2 = scrollFuncX(), scrollY2 = scrollFuncY(), limitToTouch = ~type.indexOf("touch") && !~type.indexOf("pointer") && _eventTypes[0] === "pointerdown", isViewport = _isViewport(target), ownerDoc = target.ownerDocument || _doc3, deltaX = [0, 0, 0], deltaY = [0, 0, 0], onClickTime = 0, clickCapture = function clickCapture2() {
        return onClickTime = _getTime();
      }, _ignoreCheck = function _ignoreCheck2(e, isPointerOrTouch) {
        return (self.event = e) && ignore && ~ignore.indexOf(e.target) || isPointerOrTouch && limitToTouch && e.pointerType !== "touch" || ignoreCheck && ignoreCheck(e, isPointerOrTouch);
      }, onStopFunc = function onStopFunc2() {
        self._vx.reset();
        self._vy.reset();
        onStopDelayedCall.pause();
        onStop && onStop(self);
      }, update = function update2() {
        var dx = self.deltaX = _getAbsoluteMax(deltaX), dy = self.deltaY = _getAbsoluteMax(deltaY), changedX = Math.abs(dx) >= tolerance, changedY = Math.abs(dy) >= tolerance;
        onChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY);
        if (changedX) {
          onRight && self.deltaX > 0 && onRight(self);
          onLeft && self.deltaX < 0 && onLeft(self);
          onChangeX && onChangeX(self);
          onToggleX && self.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self);
          prevDeltaX = self.deltaX;
          deltaX[0] = deltaX[1] = deltaX[2] = 0;
        }
        if (changedY) {
          onDown && self.deltaY > 0 && onDown(self);
          onUp && self.deltaY < 0 && onUp(self);
          onChangeY && onChangeY(self);
          onToggleY && self.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self);
          prevDeltaY = self.deltaY;
          deltaY[0] = deltaY[1] = deltaY[2] = 0;
        }
        if (moved || dragged) {
          onMove && onMove(self);
          if (dragged) {
            onDragStart && dragged === 1 && onDragStart(self);
            onDrag && onDrag(self);
            dragged = 0;
          }
          moved = false;
        }
        locked && !(locked = false) && onLockAxis && onLockAxis(self);
        if (wheeled) {
          onWheel(self);
          wheeled = false;
        }
        id = 0;
      }, onDelta = function onDelta2(x, y, index) {
        deltaX[index] += x;
        deltaY[index] += y;
        self._vx.update(x);
        self._vy.update(y);
        debounce2 ? id || (id = requestAnimationFrame(update)) : update();
      }, onTouchOrPointerDelta = function onTouchOrPointerDelta2(x, y) {
        if (lockAxis && !axis) {
          self.axis = axis = Math.abs(x) > Math.abs(y) ? "x" : "y";
          locked = true;
        }
        if (axis !== "y") {
          deltaX[2] += x;
          self._vx.update(x, true);
        }
        if (axis !== "x") {
          deltaY[2] += y;
          self._vy.update(y, true);
        }
        debounce2 ? id || (id = requestAnimationFrame(update)) : update();
      }, _onDrag = function _onDrag2(e) {
        if (_ignoreCheck(e, 1)) {
          return;
        }
        e = _getEvent(e, preventDefault2);
        var x = e.clientX, y = e.clientY, dx = x - self.x, dy = y - self.y, isDragging = self.isDragging;
        self.x = x;
        self.y = y;
        if (isDragging || (dx || dy) && (Math.abs(self.startX - x) >= dragMinimum || Math.abs(self.startY - y) >= dragMinimum)) {
          dragged = isDragging ? 2 : 1;
          isDragging || (self.isDragging = true);
          onTouchOrPointerDelta(dx, dy);
        }
      }, _onPress = self.onPress = function(e) {
        if (_ignoreCheck(e, 1) || e && e.button) {
          return;
        }
        self.axis = axis = null;
        onStopDelayedCall.pause();
        self.isPressed = true;
        e = _getEvent(e);
        prevDeltaX = prevDeltaY = 0;
        self.startX = self.x = e.clientX;
        self.startY = self.y = e.clientY;
        self._vx.reset();
        self._vy.reset();
        _addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, passive, true);
        self.deltaX = self.deltaY = 0;
        onPress && onPress(self);
      }, _onRelease = self.onRelease = function(e) {
        if (_ignoreCheck(e, 1)) {
          return;
        }
        _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
        var isTrackingDrag = !isNaN(self.y - self.startY), wasDragging = self.isDragging, isDragNotClick = wasDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3), eventData = _getEvent(e);
        if (!isDragNotClick && isTrackingDrag) {
          self._vx.reset();
          self._vy.reset();
          if (preventDefault2 && allowClicks) {
            gsap2.delayedCall(0.08, function() {
              if (_getTime() - onClickTime > 300 && !e.defaultPrevented) {
                if (e.target.click) {
                  e.target.click();
                } else if (ownerDoc.createEvent) {
                  var syntheticEvent = ownerDoc.createEvent("MouseEvents");
                  syntheticEvent.initMouseEvent("click", true, true, _win3, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);
                  e.target.dispatchEvent(syntheticEvent);
                }
              }
            });
          }
        }
        self.isDragging = self.isGesturing = self.isPressed = false;
        onStop && wasDragging && !isNormalizer && onStopDelayedCall.restart(true);
        dragged && update();
        onDragEnd && wasDragging && onDragEnd(self);
        onRelease && onRelease(self, isDragNotClick);
      }, _onGestureStart = function _onGestureStart2(e) {
        return e.touches && e.touches.length > 1 && (self.isGesturing = true) && onGestureStart(e, self.isDragging);
      }, _onGestureEnd = function _onGestureEnd2() {
        return (self.isGesturing = false) || onGestureEnd(self);
      }, onScroll = function onScroll2(e) {
        if (_ignoreCheck(e)) {
          return;
        }
        var x = scrollFuncX(), y = scrollFuncY();
        onDelta((x - scrollX2) * scrollSpeed, (y - scrollY2) * scrollSpeed, 1);
        scrollX2 = x;
        scrollY2 = y;
        onStop && onStopDelayedCall.restart(true);
      }, _onWheel = function _onWheel2(e) {
        if (_ignoreCheck(e)) {
          return;
        }
        e = _getEvent(e, preventDefault2);
        onWheel && (wheeled = true);
        var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win3.innerHeight : 1) * wheelSpeed;
        onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);
        onStop && !isNormalizer && onStopDelayedCall.restart(true);
      }, _onMove = function _onMove2(e) {
        if (_ignoreCheck(e)) {
          return;
        }
        var x = e.clientX, y = e.clientY, dx = x - self.x, dy = y - self.y;
        self.x = x;
        self.y = y;
        moved = true;
        onStop && onStopDelayedCall.restart(true);
        (dx || dy) && onTouchOrPointerDelta(dx, dy);
      }, _onHover = function _onHover2(e) {
        self.event = e;
        onHover(self);
      }, _onHoverEnd = function _onHoverEnd2(e) {
        self.event = e;
        onHoverEnd(self);
      }, _onClick = function _onClick2(e) {
        return _ignoreCheck(e) || _getEvent(e, preventDefault2) && onClick(self);
      };
      onStopDelayedCall = self._dc = gsap2.delayedCall(onStopDelay || 0.25, onStopFunc).pause();
      self.deltaX = self.deltaY = 0;
      self._vx = _getVelocityProp(0, 50, true);
      self._vy = _getVelocityProp(0, 50, true);
      self.scrollX = scrollFuncX;
      self.scrollY = scrollFuncY;
      self.isDragging = self.isGesturing = self.isPressed = false;
      _context2(this);
      self.enable = function(e) {
        if (!self.isEnabled) {
          _addListener(isViewport ? ownerDoc : target, "scroll", _onScroll);
          type.indexOf("scroll") >= 0 && _addListener(isViewport ? ownerDoc : target, "scroll", onScroll, passive, capture);
          type.indexOf("wheel") >= 0 && _addListener(target, "wheel", _onWheel, passive, capture);
          if (type.indexOf("touch") >= 0 && _isTouch || type.indexOf("pointer") >= 0) {
            _addListener(target, _eventTypes[0], _onPress, passive, capture);
            _addListener(ownerDoc, _eventTypes[2], _onRelease);
            _addListener(ownerDoc, _eventTypes[3], _onRelease);
            allowClicks && _addListener(target, "click", clickCapture, true, true);
            onClick && _addListener(target, "click", _onClick);
            onGestureStart && _addListener(ownerDoc, "gesturestart", _onGestureStart);
            onGestureEnd && _addListener(ownerDoc, "gestureend", _onGestureEnd);
            onHover && _addListener(target, _pointerType + "enter", _onHover);
            onHoverEnd && _addListener(target, _pointerType + "leave", _onHoverEnd);
            onMove && _addListener(target, _pointerType + "move", _onMove);
          }
          self.isEnabled = true;
          self.isDragging = self.isGesturing = self.isPressed = moved = dragged = false;
          self._vx.reset();
          self._vy.reset();
          scrollX2 = scrollFuncX();
          scrollY2 = scrollFuncY();
          e && e.type && _onPress(e);
          onEnable && onEnable(self);
        }
        return self;
      };
      self.disable = function() {
        if (self.isEnabled) {
          _observers.filter(function(o) {
            return o !== self && _isViewport(o.target);
          }).length || _removeListener(isViewport ? ownerDoc : target, "scroll", _onScroll);
          if (self.isPressed) {
            self._vx.reset();
            self._vy.reset();
            _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
          }
          _removeListener(isViewport ? ownerDoc : target, "scroll", onScroll, capture);
          _removeListener(target, "wheel", _onWheel, capture);
          _removeListener(target, _eventTypes[0], _onPress, capture);
          _removeListener(ownerDoc, _eventTypes[2], _onRelease);
          _removeListener(ownerDoc, _eventTypes[3], _onRelease);
          _removeListener(target, "click", clickCapture, true);
          _removeListener(target, "click", _onClick);
          _removeListener(ownerDoc, "gesturestart", _onGestureStart);
          _removeListener(ownerDoc, "gestureend", _onGestureEnd);
          _removeListener(target, _pointerType + "enter", _onHover);
          _removeListener(target, _pointerType + "leave", _onHoverEnd);
          _removeListener(target, _pointerType + "move", _onMove);
          self.isEnabled = self.isPressed = self.isDragging = false;
          onDisable && onDisable(self);
        }
      };
      self.kill = self.revert = function() {
        self.disable();
        var i = _observers.indexOf(self);
        i >= 0 && _observers.splice(i, 1);
        _normalizer === self && (_normalizer = 0);
      };
      _observers.push(self);
      isNormalizer && _isViewport(target) && (_normalizer = self);
      self.enable(event);
    };
    _createClass(Observer3, [{
      key: "velocityX",
      get: function get() {
        return this._vx.getVelocity();
      }
    }, {
      key: "velocityY",
      get: function get() {
        return this._vy.getVelocity();
      }
    }]);
    return Observer3;
  }();
  Observer2.version = "3.12.7";
  Observer2.create = function(vars) {
    return new Observer2(vars);
  };
  Observer2.register = _initCore3;
  Observer2.getAll = function() {
    return _observers.slice();
  };
  Observer2.getById = function(id) {
    return _observers.filter(function(o) {
      return o.vars.id === id;
    })[0];
  };
  _getGSAP() && gsap2.registerPlugin(Observer2);

  // src/assets/javascripts/features/hero/animations/observer.ts
  gsapWithCSS.registerPlugin(Observer2);
  var HeroObservation = class _HeroObservation {
    constructor() {
      this.store = HeroStore.getInstance();
      this.currentIndex = -1;
      this.config = OBSERVER_CONFIG;
      this.sections = [];
      this.subscriptions = new Subscription();
      this.animating = false;
      this.sectionCount = 0;
      this.sectionIndexLength = 0;
      this.defaultTimelineVars = {};
      this.initialized = false;
      this.firstLoad = true;
      this.footer = document.querySelector(".md-footer");
      this.defaultTimelineVars = {
        repeat: 0,
        duration: this.config.slides.slideDuration,
        ease: "power2.inOut",
        onComplete: () => {
          this.animating = false;
        },
        onStart: () => {
          this.animating = true;
        },
        callbackScope: this
      };
      this.transitionTl = gsapWithCSS.timeline(this.defaultTimelineVars);
      this.setupSubscriptions();
      logger.info("HeroObservation initialized");
    }
    /**
     * @description Get the singleton instance of the HeroObservation class.
     * @returns {HeroObservation}
     */
    static getInstance() {
      return _HeroObservation.instance ?? (_HeroObservation.instance = _HeroObservation.instance = new _HeroObservation());
    }
    // Sets up RxJs subscriptions to monitor the atHome state
    setupSubscriptions() {
      const atHome$ = this.store.state$.pipe(map((state) => state.atHome), filter((atHome) => atHome), distinctUntilChanged());
      this.subscriptions.add(atHome$.subscribe(() => {
        this.onLoad();
      }));
    }
    // A delayed initialization function that sets up the observers
    // and the animations for the Hero feature -- when the user is at home
    onLoad() {
      this.transitionTl.pause();
      gsapWithCSS.set(this.footer, { autoAlpha: 0 });
      this.subscriptions.add(navigationEvents$.pipe(filter((url2) => !isHome(url2))).subscribe(() => {
        gsapWithCSS.set(this.footer, { autoAlpha: 1 });
      }));
      const outerWrappers = gsapWithCSS.utils.toArray(".outer");
      const innerWrappers = gsapWithCSS.utils.toArray(".inner");
      requestAnimationFrame(() => {
        document.body.style.overflow = "hidden";
        gsapWithCSS.set(this.sections.map((section) => section.element), { autoAlpha: 0 });
        gsapWithCSS.set(outerWrappers, { yPercent: 100 });
        gsapWithCSS.set(innerWrappers, { yPercent: -100 });
      });
      if (!this.initialized) {
        this.setupSections();
        this.wrapper = gsapWithCSS.utils.wrap([...Array(this.sectionCount).keys()]);
        this.setupFirstLoad();
        this.setupObserver();
      }
      const { hash } = window.location;
      if (hash !== "") {
        this.goToSection(0, 1);
      } else {
        const target = document.getElementById(hash.substring(1));
        if (target) {
          const sectionTarget = this.sections.find((section) => section.content.includes(target));
          if (sectionTarget) {
            this.firstLoad = false;
            const index = this.sections.indexOf(sectionTarget);
            this.goToSection(index, index === this.sectionIndexLength ? -1 /* UP */ : 1 /* DOWN */);
          }
        }
        this.initialized = true;
      }
    }
    /**
     * @description Set up the first load of the Hero feature.
     * Filters out the emphasis targets and fades in the content.
     * Emphasis animations are handled in videoManager.ts.
     */
    setupFirstLoad() {
      const firstSection = this.sections[0];
      const { content } = firstSection;
      const { subtle, strong } = this.config.emphasisTargets;
      const subtleTargets = gsapWithCSS.utils.toArray(document.querySelectorAll(subtle)).filter((el) => this.isValidContentTarget(el));
      const strongTargets = gsapWithCSS.utils.toArray(document.querySelectorAll(strong)).filter((el) => this.isValidContentTarget(el));
      const emphasisTargets = [...subtleTargets, ...strongTargets];
      const filteredContent = content.filter((content2) => !emphasisTargets.includes(content2) && this.isValidContentTarget(content2));
      gsapWithCSS.to(filteredContent, { autoAlpha: 1, duration: 0.75 });
      gsapWithCSS.to(subtleTargets, { autoAlpha: 0.7, duration: 1 });
    }
    /**
     * @param animation - The animation to register (gsap.core.Timeline)
     * @param key - The section element to register the animation with
     * @description Register an animation with a section element.
     */
    registerAnimation(animation, key) {
      const section = this.sections.find((section2) => section2.element === key);
      if (section) {
        section.animation = section.animation ? section.animation.add(animation) : animation;
      }
    }
    /**
     * @description Set up the Section objects for the Hero feature.
     */
    setupSections() {
      const sectionEls = this.config.fades.fadeInSections;
      this.sections = sectionEls.map((el, index) => {
        return {
          index,
          element: el,
          content: getContentElements(el),
          outerWrapper: el.querySelector(".outer"),
          innerWrapper: el.querySelector(".inner"),
          bg: el.querySelector(".bg"),
          animation: gsapWithCSS.timeline({
            paused: !(index === 0)
            // Only play the first section
          }).addLabel("start")
        };
      });
      logger.info(`Sections set up: ${JSON.stringify(this.sections, getCircularReplacer(), 2)}`);
      const ignores = gsapWithCSS.utils.toArray(this.config.fades.fadeInIgnore);
      this.sections[0].content.filter((content) => !ignores.includes(content) && this.isValidContentTarget(content));
      this.sections.forEach((section, _) => {
        const { content } = section;
        requestAnimationFrame(() => {
          gsapWithCSS.set(content, { autoAlpha: 0 });
        });
      });
      this.sectionCount = this.sections.length;
      this.sectionIndexLength = this.sectionCount - 1;
    }
    /**
     * @description Transition to the next section based on the direction and whether the scenicRoute is enabled.
     * @param direction
     * @param scenicRoute
     * @returns
     */
    async transition(direction, scenicRoute) {
      let index = this.getNextIndex(direction);
      if (!this.animating && !scenicRoute) {
        this.goToSection(index, direction);
      } else if (!this.animating && scenicRoute && direction === 1 /* DOWN */) {
        this.goToSection(index, direction);
        let remainingSections = this.sectionIndexLength - index;
        while (remainingSections > 0) {
          await new Promise((resolve3) => setTimeout(resolve3, 5e3));
          if (this.currentIndex !== this.sectionIndexLength && this.currentIndex === index) {
            this.goToSection(index + 1 /* DOWN */, direction);
            index++;
            remainingSections--;
          } else {
            break;
          }
        }
      }
      return;
    }
    // Get the next index based on the direction
    getNextIndex(direction) {
      if ((this.currentIndex === 0 || this.currentIndex === -1) && this.firstLoad && direction === -1 /* UP */) {
        return 0;
      }
      this.firstLoad = false;
      return this.wrapper(this.currentIndex + direction);
    }
    // Construct the transition timeline based on the direction and index
    // Uses registered effects from observerEffects.ts
    constructTransitionTimeline(direction, index, tl) {
      const nextSection = this.sections[index];
      if (this.currentIndex >= 0) {
        logger.info(`Setting section ${this.currentIndex} to section ${index}`);
        tl.setSection({ direction, section: nextSection });
      }
      logger.info(`Animating section ${index} in direction ${direction}`);
      tl.transitionSection({ direction, section: nextSection });
      return tl;
    }
    // Go to the next section based on the index and direction
    goToSection(index, direction) {
      if (this.animating || index === this.currentIndex) {
        return;
      }
      this.animating = true;
      logger.info(`Going to section ${index} in direction ${direction}`);
      let tl = gsapWithCSS.timeline({
        defaults: {
          duration: this.config.slides.slideDuration,
          ease: "power2.inOut",
          onComplete: () => {
            this.animating = false;
          },
          onStart: () => {
            this.animating = true;
          },
          callbackScope: this
        }
      });
      tl = this.constructTransitionTimeline(direction, index, tl);
      this.transitionTl = tl;
      if (!this.transitionTl.isActive()) {
        this.transitionTl.play();
      }
    }
    /**
     * @description Checks if an element is a valid content target for animations.
     * Ensures the element exists, is a valid element, has a parent, belongs to a section,
     * and is not one of the excluded section elements (bg, wrappers, etc.).
     * @param el - The element to check.
     * @returns True if the element is a valid content target, false otherwise.
     */
    isValidContentTarget(el) {
      if (!el || !(el instanceof Element) || !el.parentElement) {
        return false;
      }
      const section = this.sections.find((section2) => section2.content.includes(el));
      if (!section) {
        return false;
      }
      return el !== section.bg && el !== section.outerWrapper && el !== section.innerWrapper && el !== section.element && isValidElement(el, section.element);
    }
    /**
     * @description Set up the Observers for the Hero feature. The Observers are created only when the user is at home. There are two Observers:
     * 1. The transitionObserver is the main Observer that handles all
     * perceived up/down interactions to trigger transitions between sections.
     * 2. The clickObserver handles the click-driven "guided tour" of the sections.
     */
    setupObserver() {
      const clickTargets = gsapWithCSS.utils.toArray(document.querySelectorAll(this.config.clickTargets));
      const ignoreTargets = gsapWithCSS.utils.toArray(document.querySelectorAll(this.config.ignoreTargets));
      this.transitionObserver = Observer2.create({
        type: "wheel,touch,pointer,scroll",
        wheelSpeed: -1,
        onDown: () => {
          this.transition(1 /* DOWN */, false);
        },
        onUp: () => {
          this.transition(-1 /* UP */, false);
        },
        preventDefault: true,
        tolerance: 15,
        ignore: clickTargets
      });
      this.transitionObserver.enable();
      this.clickObserver = Observer2.create({
        type: "click",
        target: clickTargets,
        ignore: ignoreTargets,
        onClick: () => {
          this.transition(1 /* DOWN */, true);
        },
        onRelease: () => {
          this.transition(1 /* DOWN */, true);
        },
        preventDefault: true
      });
      this.clickObserver.enable();
    }
    // Destroy the Observers and subscriptions
    destroy() {
      if (this.transitionObserver) {
        this.transitionObserver.disable();
      }
      if (this.clickObserver) {
        this.clickObserver.disable();
      }
      this.subscriptions.unsubscribe();
    }
  };

  // src/assets/javascripts/features/hero/video/data.ts
  var rawHeroVideos = [
    {
      baseName: "tokyo_shuffle",
      parentPath: "/assets/videos/hero/tokyo_shuffle",
      variants: {
        av1: {
          426: "assets/videos/hero/break_free/break_free_av1_426.68b4fcb9.webm",
          640: "assets/videos/hero/break_free/break_free_av1_640.fbba63e1.webm",
          854: "assets/videos/hero/break_free/break_free_av1_854.5653b4a3.webm",
          1280: "assets/videos/hero/break_free/break_free_av1_1280.5924100d.webm",
          1920: "assets/videos/hero/break_free/break_free_av1_1920.15cf893c.webm",
          2560: "assets/videos/hero/break_free/break_free_av1_2560.422dd3aa.webm",
          3840: "assets/videos/hero/break_free/break_free_av1_3840.3f4ab485.webm"
        },
        vp9: {
          426: "assets/videos/hero/break_free/break_free_vp9_426.57d668a7.webm",
          640: "assets/videos/hero/break_free/break_free_vp9_640.a130f758.webm",
          854: "assets/videos/hero/break_free/break_free_vp9_854.47d4071d.webm",
          1280: "assets/videos/hero/break_free/break_free_vp9_1280.5050faa9.webm",
          1920: "assets/videos/hero/break_free/break_free_vp9_1920.1c78a676.webm",
          2560: "assets/videos/hero/break_free/break_free_vp9_2560.8fecc28d.webm",
          3840: "assets/videos/hero/break_free/break_free_vp9_3840.8c366fd1.webm"
        },
        h264: {
          426: "assets/videos/hero/break_free/break_free_h264_426.03ae5a02.mp4",
          640: "assets/videos/hero/break_free/break_free_h264_640.abc514ef.mp4",
          854: "assets/videos/hero/break_free/break_free_h264_854.bd603a43.mp4",
          1280: "assets/videos/hero/break_free/break_free_h264_1280.36973c5d.mp4",
          1920: "assets/videos/hero/break_free/break_free_h264_1920.6fe1c5f9.mp4",
          2560: "assets/videos/hero/break_free/break_free_h264_2560.9a7d9d68.mp4",
          3840: "assets/videos/hero/break_free/break_free_h264_3840.e6f18669.mp4"
        }
      },
      poster: {
        avif: {
          widths: {
            426: "assets/videos/hero/break_free/posters/break_free_426.15b2f8c2.avif",
            640: "assets/videos/hero/break_free/posters/break_free_640.1f09127c.avif",
            854: "assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_854.56629992.avif",
            1280: "assets/videos/hero/break_free/posters/break_free_1280.a70cced8.avif",
            1920: "assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_1920.a2f4dafc.avif",
            2560: "assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_2560.43267f7f.avif",
            3840: "assets/videos/hero/break_free/posters/break_free_3840.5b016e9b.avif"
          },
          srcset: "assets/videos/hero/break_free/posters/break_free_3840.5b016e9b.avif 3840w, assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_2560.43267f7f.avif 2560w, assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_1920.a2f4dafc.avif 1920w, assets/videos/hero/break_free/posters/break_free_1280.a70cced8.avif 1280w, assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_854.56629992.avif 854w, assets/videos/hero/break_free/posters/break_free_640.1f09127c.avif 640w, assets/videos/hero/break_free/posters/break_free_426.15b2f8c2.avif 426w"
        },
        webp: {
          widths: {
            426: "assets/videos/hero/break_free/posters/break_free_426.e5d3453e.webp",
            640: "assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_640.4f1c6fe6.webp",
            854: "assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_854.48926405.webp",
            1280: "assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_1280.a31d64a3.webp",
            1920: "assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_1920.e4d59947.webp",
            2560: "assets/videos/hero/break_free/posters/break_free_2560.923f39c9.webp",
            3840: "assets/videos/hero/break_free/posters/break_free_3840.a4a844c0.webp"
          },
          srcset: "assets/videos/hero/break_free/posters/break_free_3840.a4a844c0.webp 3840w, assets/videos/hero/break_free/posters/break_free_2560.923f39c9.webp 2560w, assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_1920.e4d59947.webp 1920w, assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_1280.a31d64a3.webp 1280w, assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_854.48926405.webp 854w, assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_640.4f1c6fe6.webp 640w, assets/videos/hero/break_free/posters/break_free_426.e5d3453e.webp 426w"
        },
        png: {
          widths: {
            426: "assets/videos/hero/break_free/posters/break_free_426.34c4c513.png",
            640: "assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_640.19194ff4.png",
            854: "assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_854.9828900a.png",
            1280: "assets/videos/hero/break_free/posters/break_free_1280.6088c494.png",
            1920: "assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_1920.1feeb1dd.png",
            2560: "assets/videos/hero/break_free/posters/break_free_2560.aac4a3cc.png",
            3840: "assets/videos/hero/break_free/posters/break_free_3840.c12169da.png"
          },
          srcset: "assets/videos/hero/break_free/posters/break_free_3840.c12169da.png 3840w, assets/videos/hero/break_free/posters/break_free_2560.aac4a3cc.png 2560w, assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_1920.1feeb1dd.png 1920w, assets/videos/hero/break_free/posters/break_free_1280.6088c494.png 1280w, assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_854.9828900a.png 854w, assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_640.19194ff4.png 640w, assets/videos/hero/break_free/posters/break_free_426.34c4c513.png 426w"
        }
      },
      message: "Stop the Nonsense"
    },
    {
      baseName: "break_free",
      parentPath: "/assets/videos/hero/break_free",
      variants: {
        av1: {
          426: "assets/videos/hero/break_free/break_free_av1_426.68b4fcb9.webm",
          640: "assets/videos/hero/break_free/break_free_av1_640.fbba63e1.webm",
          854: "assets/videos/hero/break_free/break_free_av1_854.5653b4a3.webm",
          1280: "assets/videos/hero/break_free/break_free_av1_1280.5924100d.webm",
          1920: "assets/videos/hero/break_free/break_free_av1_1920.15cf893c.webm",
          2560: "assets/videos/hero/break_free/break_free_av1_2560.422dd3aa.webm",
          3840: "assets/videos/hero/break_free/break_free_av1_3840.3f4ab485.webm"
        },
        vp9: {
          426: "assets/videos/hero/break_free/break_free_vp9_426.57d668a7.webm",
          640: "assets/videos/hero/break_free/break_free_vp9_640.a130f758.webm",
          854: "assets/videos/hero/break_free/break_free_vp9_854.47d4071d.webm",
          1280: "assets/videos/hero/break_free/break_free_vp9_1280.5050faa9.webm",
          1920: "assets/videos/hero/break_free/break_free_vp9_1920.1c78a676.webm",
          2560: "assets/videos/hero/break_free/break_free_vp9_2560.8fecc28d.webm",
          3840: "assets/videos/hero/break_free/break_free_vp9_3840.8c366fd1.webm"
        },
        h264: {
          426: "assets/videos/hero/break_free/break_free_h264_426.03ae5a02.mp4",
          640: "assets/videos/hero/break_free/break_free_h264_640.abc514ef.mp4",
          854: "assets/videos/hero/break_free/break_free_h264_854.bd603a43.mp4",
          1280: "assets/videos/hero/break_free/break_free_h264_1280.36973c5d.mp4",
          1920: "assets/videos/hero/break_free/break_free_h264_1920.6fe1c5f9.mp4",
          2560: "assets/videos/hero/break_free/break_free_h264_2560.9a7d9d68.mp4",
          3840: "assets/videos/hero/break_free/break_free_h264_3840.e6f18669.mp4"
        }
      },
      poster: {
        avif: {
          widths: {
            426: "assets/videos/hero/break_free/posters/break_free_426.15b2f8c2.avif",
            640: "assets/videos/hero/break_free/posters/break_free_640.1f09127c.avif",
            854: "assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_854.56629992.avif",
            1280: "assets/videos/hero/break_free/posters/break_free_1280.a70cced8.avif",
            1920: "assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_1920.a2f4dafc.avif",
            2560: "assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_2560.43267f7f.avif",
            3840: "assets/videos/hero/break_free/posters/break_free_3840.5b016e9b.avif"
          },
          srcset: "assets/videos/hero/break_free/posters/break_free_3840.5b016e9b.avif 3840w, assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_2560.43267f7f.avif 2560w, assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_1920.a2f4dafc.avif 1920w, assets/videos/hero/break_free/posters/break_free_1280.a70cced8.avif 1280w, assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_854.56629992.avif 854w, assets/videos/hero/break_free/posters/break_free_640.1f09127c.avif 640w, assets/videos/hero/break_free/posters/break_free_426.15b2f8c2.avif 426w"
        },
        webp: {
          widths: {
            426: "assets/videos/hero/break_free/posters/break_free_426.e5d3453e.webp",
            640: "assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_640.4f1c6fe6.webp",
            854: "assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_854.48926405.webp",
            1280: "assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_1280.a31d64a3.webp",
            1920: "assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_1920.e4d59947.webp",
            2560: "assets/videos/hero/break_free/posters/break_free_2560.923f39c9.webp",
            3840: "assets/videos/hero/break_free/posters/break_free_3840.a4a844c0.webp"
          },
          srcset: "assets/videos/hero/break_free/posters/break_free_3840.a4a844c0.webp 3840w, assets/videos/hero/break_free/posters/break_free_2560.923f39c9.webp 2560w, assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_1920.e4d59947.webp 1920w, assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_1280.a31d64a3.webp 1280w, assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_854.48926405.webp 854w, assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_640.4f1c6fe6.webp 640w, assets/videos/hero/break_free/posters/break_free_426.e5d3453e.webp 426w"
        },
        png: {
          widths: {
            426: "assets/videos/hero/break_free/posters/break_free_426.34c4c513.png",
            640: "assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_640.19194ff4.png",
            854: "assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_854.9828900a.png",
            1280: "assets/videos/hero/break_free/posters/break_free_1280.6088c494.png",
            1920: "assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_1920.1feeb1dd.png",
            2560: "assets/videos/hero/break_free/posters/break_free_2560.aac4a3cc.png",
            3840: "assets/videos/hero/break_free/posters/break_free_3840.c12169da.png"
          },
          srcset: "assets/videos/hero/break_free/posters/break_free_3840.c12169da.png 3840w, assets/videos/hero/break_free/posters/break_free_2560.aac4a3cc.png 2560w, assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_1920.1feeb1dd.png 1920w, assets/videos/hero/break_free/posters/break_free_1280.6088c494.png 1280w, assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_854.9828900a.png 854w, assets/videos/hero/tokyo_shuffle/posters/tokyo_shuffle_640.19194ff4.png 640w, assets/videos/hero/break_free/posters/break_free_426.34c4c513.png 426w"
        }
      },
      message: "Understanding shouldn't require a degree."
    }
  ];

  // src/assets/javascripts/features/hero/video/utils.ts
  function getHeroVideos() {
    return [...rawHeroVideos];
  }
  var getAv1MediaType = (width) => {
    const seqlevelMap = {
      426: "16",
      640: "16",
      854: "16",
      1280: "16",
      1920: "16",
      2560: "16",
      3840: "16"
    };
    const seqlevel = seqlevelMap[width];
    return `video/webm;codecs=av01.0.${seqlevel}M.10.0.110.01.01.01.0`;
  };
  var getH264MediaType = (width) => {
    const baseString = "avc1.6E00";
    const levelMap = {
      426: "16",
      640: "1F",
      854: "28",
      1280: "32",
      1920: "33",
      2560: "3C",
      3840: "3C"
    };
    const level = levelMap[width];
    return `video/mp4;codecs=${baseString}${level}`;
  };
  var getVp9MediaType = (width) => {
    const levelMap = {
      486: 20,
      640: 21,
      854: 30,
      1280: 31,
      1920: 40,
      2560: 50,
      3840: 51
    };
    const level = levelMap[width];
    return `video/webm;codecs=vp09.02.${level}.10.00.01.01.01.01`;
  };
  function get_media_type(type, width) {
    switch (type) {
      case "av1":
        return getAv1MediaType(width);
      case "vp9":
        return getVp9MediaType(width);
      case "h264":
        return getH264MediaType(width);
    }
  }
  function srcToAttributes(src) {
    const splitName = (s) => s.split("_");
    const { name } = parsePath(src);
    const width = parseInt(splitName(name).slice(-1)[0].split(".")[0], 10);
    const codec = splitName(name).slice(-2)[0];
    return [codec, width];
  }

  // src/assets/javascripts/features/hero/video/videoElement.ts
  var VideoElement = class {
    constructor(heroVideo, properties) {
      this.video = document.createElement("video");
      this.disablePictureInPicture = "true";
      this.playsinline = "true";
      this.preload = "metadata";
      this.muted = "true";
      this.loop = "true";
      this.autoplay = "true";
      this.picture = document.createElement("picture");
      this.properties = {};
      this.message = "";
      this.video.classList.add("hero__video");
      this.heroVideo = heroVideo;
      this.poster = heroVideo.poster;
      this.message = heroVideo.message || "";
      let props = properties ? Object.fromEntries(Object.entries(properties).map(([key, value]) => [
        key,
        value === "true" || value === "false" ? value : this[key] || "true"
      ])) : {};
      this.assignProperties(props);
      this.video = this.constructVideoElement();
      this.sources = this.constructSources();
      this.video.append(...this.sources);
      this.picture = this.constructPictureElement();
    }
    // assign properties to the video element
    assignProperties(properties) {
      const { disablePictureInPicture, playsinline, preload, muted, loop, autoplay } = this;
      return {
        disablePictureInPicture,
        playsinline,
        preload,
        muted,
        loop,
        autoplay,
        ...properties
      };
    }
    // construct the video element
    constructVideoElement() {
      const { video } = this;
      for (const prop in this.properties) {
        const key = typeof prop === "string" ? prop : `${prop}`;
        try {
          video.setAttribute(prop, this.properties[key]);
        } catch (e) {
          logger.error(`Error setting property ${key} on video element: ${e}`);
        }
      }
      return video;
    }
    // make the source elements for the video element
    constructSources() {
      const { heroVideo } = this;
      let srcs = [];
      const widths = Object.keys(MAX_WIDTHS);
      for (const [_, variant] of Object.entries(heroVideo.variants)) {
        for (const codec in variant) {
          if (codec === "av1" || codec === "vp9" || codec === "h264") {
            const codecKey = codec;
            for (const width in widths) {
              const w = parseInt(width, 10);
              const src = document.createElement("source");
              const codecVariant = variant[codecKey];
              if (typeof codecVariant === "string") {
                src.src = codecVariant;
              } else {
                src.src = codecVariant[w];
              }
              src.type = get_media_type(codec, w);
              src.media = w !== 3840 ? `(max-width: ${MAX_WIDTHS[w]}px)` : "";
              srcs.push(src);
            }
          }
        }
      }
      return srcs.sort((a, b) => {
        const [aCodec, aWidth] = srcToAttributes(a.src);
        const [bCodec, bWidth] = srcToAttributes(b.src);
        if (aWidth === bWidth) {
          switch (aCodec) {
            case "av1":
              return -1;
            case "vp9":
              return bCodec === "av1" ? 1 : -1;
            case "h264":
              return 1;
            // h264 should always be last if widths are equal
            default:
              throw new Error(`Unknown codec: ${aCodec}`);
          }
        } else {
          return aWidth - bWidth;
        }
      });
    }
    // get the sizes attribute for the poster image
    getSizes() {
      const { heroVideo } = this;
      const { poster } = heroVideo;
      const { png } = poster;
      const { widths } = png;
      let sizes = "";
      for (const width in widths) {
        const w = parseInt(width, 10);
        if (Array.from(Object.keys(MAX_WIDTHS)).includes(width)) {
          sizes += w !== 3840 ? `(max-width: ${MAX_WIDTHS[width]}px) ${width}px, ` : `${width}px`;
        }
      }
      return sizes;
    }
    // construct the picture element
    constructPictureElement() {
      const { picture, poster } = this;
      let srcs = [];
      for (const type in Object.keys(poster)) {
        if (type === "webp" || type === "avif") {
          const { srcset } = poster[type.toString()];
          const source = document.createElement("source");
          source.srcset = srcset;
          source.type = `image/${type}`;
          srcs.push(source);
        }
      }
      srcs = srcs.sort((a, b) => {
        const aType = a.type.split("/")[1];
        const bType = b.type.split("/")[1];
        if (aType === bType) {
          return 0;
        } else {
          if (aType === "avif") {
            return -1;
          }
          return 1;
        }
      });
      picture.append(...srcs);
      const img = document.createElement("img");
      img.src = poster.png.widths[1280];
      img.srcset = poster.png.srcset;
      img.alt = "";
      img.sizes = this.getSizes();
      picture.classList.add("hero__poster");
      picture.append(img);
      return picture;
    }
    getElements() {
      return this.video;
    }
  };

  // src/assets/javascripts/features/hero/video/videoManager.ts
  var customWindow4 = window;
  var { document$: document$3 } = customWindow4;
  var VideoManager = class _VideoManager {
    constructor() {
      this.store = HeroStore.getInstance();
      this.container = document.querySelector(".hero__container") || document.createElement("div");
      this.ctaContainer = document.querySelector(".cta__container") || document.createElement("div");
      this.ctaText = gsapWithCSS.utils.toArray("h1, h2");
      this.timeline = gsapWithCSS.timeline();
      this.subscriptions = new Subscription();
      this.has_played = false;
      this.status = "not_initialized";
      this.canPlay = false;
      this.videoDuration = 0;
      this.titleStart = 0;
      this.message = "";
      this.videoStore = getHeroVideos();
      this.initVideo();
      this.constructTimeline();
      this.init_subscriptions();
    }
    /**
     * @method init_subscriptions
     * @private
     * @description Initializes the subscriptions for the VideoManager
     */
    init_subscriptions() {
      const { videoState$ } = this.store;
      const video$ = videoState$.pipe(distinctUntilKeyChanged("canPlay"), map(({ canPlay }) => canPlay), tap((canPlay) => {
        if (canPlay) {
          this.handleCanPlay();
        } else {
          this.handleStopPlay();
        }
      }));
      const motionSub$ = this.store.state$.pipe(distinctUntilKeyChanged("prefersReducedMotion"), filter(({ prefersReducedMotion }) => prefersReducedMotion));
      const stallHandler$ = combineLatest([
        videoState$.pipe(filter((state) => state.canPlay === true)),
        merge(fromEvent(this.element, "stalled"), fromEvent(this.element, "waiting"))
      ]).pipe(tap(() => {
        this.pause();
      }), switchMap(() => fromEvent(this.element, "canplay")), tap(() => {
        this.resume();
      }));
      this.subscriptions.add(video$.subscribe());
      this.subscriptions.add(motionSub$.subscribe(() => this.initiateFallback()));
      this.subscriptions.add(stallHandler$.subscribe());
    }
    initVideo() {
      this.backupPicture = document.querySelector(".hero__backup") || document.createElement("picture");
      if (this.videoStore.length === 0) {
        this.initiateFallback();
        throw new Error("No videos found");
      } else if (this.videoStore.length === 1) {
        this.video = new VideoElement(this.videoStore[0]);
      } else {
        const randomized = gsapWithCSS.utils.shuffle(this.videoStore);
        this.video = new VideoElement(randomized[0]);
        this.element = this.video.video;
        this.poster = this.video.picture;
        this.message = this.video.message;
      }
    }
    static getInstance() {
      return this.instance ?? (this.instance = new _VideoManager());
    }
    handleCanPlay() {
      this.canPlay = true;
      switch (this.status) {
        case "loading":
        case "playing":
          break;
        case "paused":
          this.timeline.resume();
          break;
        case "on_delay":
          this.timeline.restart();
          break;
        case "loaded":
          this.timeline.play();
          break;
        case "not_initialized":
          this.status = "loading";
          this.loadVideo();
      }
    }
    handleStopPlay() {
      this.canPlay = false;
      this.pause();
      if (this.has_played && this.videoStore.length > 1) {
        this.reinit();
        this.status = "loading";
      }
    }
    // sets initial timeline properties
    constructTimeline() {
      this.timeline = gsapWithCSS.timeline({
        defaults: { paused: true },
        paused: true,
        onStart: () => {
          this.status = "playing";
        },
        onComplete: () => {
          this.status = "on_delay";
        },
        onRepeat: () => {
          this.has_played = true;
        },
        repeat: -1,
        repeatDelay: 3,
        callbackScope: this,
        ease: "none"
      });
    }
    setEmphasisAnimations() {
      const { subtle, strong } = OBSERVER_CONFIG.emphasisTargets;
      const subtleTargets = gsapWithCSS.utils.toArray(document.querySelectorAll(subtle));
      const strongTargets = gsapWithCSS.utils.toArray(document.querySelectorAll(strong));
      this.timeline.add(["subtleEmphasis", gsapWithCSS.emphasize(subtleTargets, SUBTLE_EMPHASIS_CONFIG)], ">");
      this.timeline.add(["strongEmphasis", gsapWithCSS.emphasize(strongTargets, STRONG_EMPHASIS_CONFIG)], ">=0.5");
      gsapWithCSS.to(strongTargets, STRONG_EMPHASIS_CONFIG);
    }
    loadVideo() {
      if (!this.container.querySelector("picture")) {
        this.loadPoster();
      }
      if (this.container.querySelector("video")) {
        return;
      }
      document$3.subscribe(() => {
        gsapWithCSS.set(this.element, { autoAlpha: 0 });
        this.element.pause();
        this.container.append(this.element);
        this.element.load();
        fromEvent(this.element, "loadedmetadata").subscribe(() => {
          this.videoDuration = this.element.duration;
          this.titleStart = this.videoDuration - 5;
        });
        fromEvent(this.element, "canplay").subscribe(() => {
          this.status = "loaded";
          gsapWithCSS.to(this.poster, { autoAlpha: 0, duration: 0.5 });
          this.timeline.add(["fadeinVideo", gsapWithCSS.to(this.element, { autoAlpha: 1, duration: 0.5 })], 0);
          this.timeline.add([
            "startVideo",
            () => {
              this.element.play();
            }
          ], "<");
          if (this.video.message) {
            this.timeline.add(["fadeOutVideo", gsapWithCSS.to(this.element, { autoAlpha: 0, duration: 0.5 })], this.titleStart);
            this.timeline.add(["message", gsapWithCSS.animateMessage(this.container, { message: this.message, repeat: 0 })], this.titleStart);
            this.setEmphasisAnimations();
            this.timeline.add([
              "resetVideo",
              () => {
                this.stop();
                this.play();
              },
              ">"
            ]);
          }
        });
      });
    }
    loadPoster() {
      gsapWithCSS.set(this.poster, { autoAlpha: 0 });
      this.container.append(this.poster);
      const img = this.poster.querySelector("img");
      const transition = () => gsapWithCSS.to(this.poster, { autoAlpha: 1, duration: 0.5 });
      if (img && img instanceof HTMLImageElement) {
        if (img.complete) {
          transition();
        } else {
          fromEvent(img, "load").subscribe(transition);
        }
      } else {
        this.loadBackup();
      }
    }
    loadBackup() {
      const backup = this.backupPicture || this.poster;
      if (!Array.from(this.container.children).includes(backup)) {
        requestAnimationFrame(() => {
          this.container.append(backup);
        });
      }
      gsapWithCSS.to(backup, { autoAlpha: 1, duration: 1 });
    }
    initiateFallback() {
      if (this.container.querySelector("video")) {
        gsapWithCSS.to(this.element, { autoAlpha: 0, duration: 0.5 });
        this.container.removeChild(this.element);
      }
      this.status = "loaded";
      if (!this.store.getStateValue("prefersReducedMotion")) {
        this.loadBackup();
      }
      gsapWithCSS.set(this.ctaContainer, { autoAlpha: 1 });
      gsapWithCSS.animateMessage(this.container, {
        message: this.ctaText || this.message,
        repeat: 0,
        autoRemoveChildren: true
      });
      this.timeline.kill();
      this.subscriptions.unsubscribe();
    }
    play() {
      if (!this.timeline.isActive()) {
        this.timeline.play();
        this.element.play();
      }
    }
    pause() {
      if (this.timeline.isActive()) {
        this.timeline.pause();
        this.element.pause();
      }
    }
    resume() {
      if (this.timeline.paused()) {
        this.timeline.resume();
        this.element.play();
      }
    }
    stop() {
      if (this.timeline.isActive()) {
        this.timeline.pause();
        this.element.pause();
        this.timeline.seek(0);
        this.element.currentTime = 0;
      } else {
        this.timeline.seek(0);
        this.element.currentTime = 0;
      }
    }
    reinit() {
      this.timeline.kill();
      this.constructor();
    }
  };

  // node_modules/gsap/ScrollTrigger.js
  var gsap3;
  var _coreInitted3;
  var _win4;
  var _doc4;
  var _docEl2;
  var _body2;
  var _root2;
  var _resizeDelay;
  var _toArray;
  var _clamp4;
  var _time2;
  var _syncInterval;
  var _refreshing;
  var _pointerIsDown;
  var _transformProp2;
  var _i;
  var _prevWidth;
  var _prevHeight;
  var _autoRefresh;
  var _sort;
  var _suppressOverwrites2;
  var _ignoreResize;
  var _normalizer2;
  var _ignoreMobileResize;
  var _baseScreenHeight;
  var _baseScreenWidth;
  var _fixIOSBug;
  var _context3;
  var _scrollRestoration;
  var _div100vh;
  var _100vh;
  var _isReverted;
  var _clampingMax;
  var _limitCallbacks;
  var _startup2 = 1;
  var _getTime2 = Date.now;
  var _time1 = _getTime2();
  var _lastScrollTime = 0;
  var _enabled = 0;
  var _parseClamp = function _parseClamp2(value, type, self) {
    var clamp3 = _isString3(value) && (value.substr(0, 6) === "clamp(" || value.indexOf("max") > -1);
    self["_" + type + "Clamp"] = clamp3;
    return clamp3 ? value.substr(6, value.length - 7) : value;
  };
  var _keepClamp = function _keepClamp2(value, clamp3) {
    return clamp3 && (!_isString3(value) || value.substr(0, 6) !== "clamp(") ? "clamp(" + value + ")" : value;
  };
  var _rafBugFix = function _rafBugFix2() {
    return _enabled && requestAnimationFrame(_rafBugFix2);
  };
  var _pointerDownHandler = function _pointerDownHandler2() {
    return _pointerIsDown = 1;
  };
  var _pointerUpHandler = function _pointerUpHandler2() {
    return _pointerIsDown = 0;
  };
  var _passThrough3 = function _passThrough4(v) {
    return v;
  };
  var _round3 = function _round4(value) {
    return Math.round(value * 1e5) / 1e5 || 0;
  };
  var _windowExists5 = function _windowExists6() {
    return typeof window !== "undefined";
  };
  var _getGSAP3 = function _getGSAP4() {
    return gsap3 || _windowExists5() && (gsap3 = window.gsap) && gsap3.registerPlugin && gsap3;
  };
  var _isViewport3 = function _isViewport4(e) {
    return !!~_root2.indexOf(e);
  };
  var _getViewportDimension = function _getViewportDimension2(dimensionProperty) {
    return (dimensionProperty === "Height" ? _100vh : _win4["inner" + dimensionProperty]) || _docEl2["client" + dimensionProperty] || _body2["client" + dimensionProperty];
  };
  var _getBoundsFunc = function _getBoundsFunc2(element) {
    return _getProxyProp(element, "getBoundingClientRect") || (_isViewport3(element) ? function() {
      _winOffsets.width = _win4.innerWidth;
      _winOffsets.height = _100vh;
      return _winOffsets;
    } : function() {
      return _getBounds(element);
    });
  };
  var _getSizeFunc = function _getSizeFunc2(scroller, isViewport, _ref) {
    var d = _ref.d, d2 = _ref.d2, a = _ref.a;
    return (a = _getProxyProp(scroller, "getBoundingClientRect")) ? function() {
      return a()[d];
    } : function() {
      return (isViewport ? _getViewportDimension(d2) : scroller["client" + d2]) || 0;
    };
  };
  var _getOffsetsFunc = function _getOffsetsFunc2(element, isViewport) {
    return !isViewport || ~_proxies.indexOf(element) ? _getBoundsFunc(element) : function() {
      return _winOffsets;
    };
  };
  var _maxScroll = function _maxScroll2(element, _ref2) {
    var s = _ref2.s, d2 = _ref2.d2, d = _ref2.d, a = _ref2.a;
    return Math.max(0, (s = "scroll" + d2) && (a = _getProxyProp(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport3(element) ? (_docEl2[s] || _body2[s]) - _getViewportDimension(d2) : element[s] - element["offset" + d2]);
  };
  var _iterateAutoRefresh = function _iterateAutoRefresh2(func, events) {
    for (var i = 0; i < _autoRefresh.length; i += 3) {
      (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);
    }
  };
  var _isString3 = function _isString4(value) {
    return typeof value === "string";
  };
  var _isFunction3 = function _isFunction4(value) {
    return typeof value === "function";
  };
  var _isNumber3 = function _isNumber4(value) {
    return typeof value === "number";
  };
  var _isObject3 = function _isObject4(value) {
    return typeof value === "object";
  };
  var _endAnimation = function _endAnimation2(animation, reversed, pause) {
    return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();
  };
  var _callback3 = function _callback4(self, func) {
    if (self.enabled) {
      var result = self._ctx ? self._ctx.add(function() {
        return func(self);
      }) : func(self);
      result && result.totalTime && (self.callbackAnimation = result);
    }
  };
  var _abs = Math.abs;
  var _left = "left";
  var _top = "top";
  var _right = "right";
  var _bottom = "bottom";
  var _width = "width";
  var _height = "height";
  var _Right = "Right";
  var _Left = "Left";
  var _Top = "Top";
  var _Bottom = "Bottom";
  var _padding = "padding";
  var _margin = "margin";
  var _Width = "Width";
  var _Height = "Height";
  var _px = "px";
  var _getComputedStyle = function _getComputedStyle2(element) {
    return _win4.getComputedStyle(element);
  };
  var _makePositionable = function _makePositionable2(element) {
    var position = _getComputedStyle(element).position;
    element.style.position = position === "absolute" || position === "fixed" ? position : "relative";
  };
  var _setDefaults3 = function _setDefaults4(obj, defaults2) {
    for (var p in defaults2) {
      p in obj || (obj[p] = defaults2[p]);
    }
    return obj;
  };
  var _getBounds = function _getBounds2(element, withoutTransforms) {
    var tween = withoutTransforms && _getComputedStyle(element)[_transformProp2] !== "matrix(1, 0, 0, 1, 0, 0)" && gsap3.to(element, {
      x: 0,
      y: 0,
      xPercent: 0,
      yPercent: 0,
      rotation: 0,
      rotationX: 0,
      rotationY: 0,
      scale: 1,
      skewX: 0,
      skewY: 0
    }).progress(1), bounds = element.getBoundingClientRect();
    tween && tween.progress(0).kill();
    return bounds;
  };
  var _getSize = function _getSize2(element, _ref3) {
    var d2 = _ref3.d2;
    return element["offset" + d2] || element["client" + d2] || 0;
  };
  var _getLabelRatioArray = function _getLabelRatioArray2(timeline2) {
    var a = [], labels = timeline2.labels, duration = timeline2.duration(), p;
    for (p in labels) {
      a.push(labels[p] / duration);
    }
    return a;
  };
  var _getClosestLabel = function _getClosestLabel2(animation) {
    return function(value) {
      return gsap3.utils.snap(_getLabelRatioArray(animation), value);
    };
  };
  var _snapDirectional = function _snapDirectional2(snapIncrementOrArray) {
    var snap3 = gsap3.utils.snap(snapIncrementOrArray), a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort(function(a2, b) {
      return a2 - b;
    });
    return a ? function(value, direction, threshold) {
      if (threshold === void 0) {
        threshold = 1e-3;
      }
      var i;
      if (!direction) {
        return snap3(value);
      }
      if (direction > 0) {
        value -= threshold;
        for (i = 0; i < a.length; i++) {
          if (a[i] >= value) {
            return a[i];
          }
        }
        return a[i - 1];
      } else {
        i = a.length;
        value += threshold;
        while (i--) {
          if (a[i] <= value) {
            return a[i];
          }
        }
      }
      return a[0];
    } : function(value, direction, threshold) {
      if (threshold === void 0) {
        threshold = 1e-3;
      }
      var snapped = snap3(value);
      return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap3(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);
    };
  };
  var _getLabelAtDirection = function _getLabelAtDirection2(timeline2) {
    return function(value, st) {
      return _snapDirectional(_getLabelRatioArray(timeline2))(value, st.direction);
    };
  };
  var _multiListener = function _multiListener2(func, element, types, callback) {
    return types.split(",").forEach(function(type) {
      return func(element, type, callback);
    });
  };
  var _addListener3 = function _addListener4(element, type, func, nonPassive, capture) {
    return element.addEventListener(type, func, {
      passive: !nonPassive,
      capture: !!capture
    });
  };
  var _removeListener3 = function _removeListener4(element, type, func, capture) {
    return element.removeEventListener(type, func, !!capture);
  };
  var _wheelListener = function _wheelListener2(func, el, scrollFunc) {
    scrollFunc = scrollFunc && scrollFunc.wheelHandler;
    if (scrollFunc) {
      func(el, "wheel", scrollFunc);
      func(el, "touchmove", scrollFunc);
    }
  };
  var _markerDefaults = {
    startColor: "green",
    endColor: "red",
    indent: 0,
    fontSize: "16px",
    fontWeight: "normal"
  };
  var _defaults2 = {
    toggleActions: "play",
    anticipatePin: 0
  };
  var _keywords = {
    top: 0,
    left: 0,
    center: 0.5,
    bottom: 1,
    right: 1
  };
  var _offsetToPx = function _offsetToPx2(value, size) {
    if (_isString3(value)) {
      var eqIndex = value.indexOf("="), relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;
      if (~eqIndex) {
        value.indexOf("%") > eqIndex && (relative *= size / 100);
        value = value.substr(0, eqIndex - 1);
      }
      value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf("%") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);
    }
    return value;
  };
  var _createMarker = function _createMarker2(type, name, container, direction, _ref4, offset, matchWidthEl, containerAnimation) {
    var startColor = _ref4.startColor, endColor = _ref4.endColor, fontSize = _ref4.fontSize, indent = _ref4.indent, fontWeight = _ref4.fontWeight;
    var e = _doc4.createElement("div"), useFixedPosition = _isViewport3(container) || _getProxyProp(container, "pinType") === "fixed", isScroller = type.indexOf("scroller") !== -1, parent = useFixedPosition ? _body2 : container, isStart = type.indexOf("start") !== -1, color = isStart ? startColor : endColor, css = "border-color:" + color + ";font-size:" + fontSize + ";color:" + color + ";font-weight:" + fontWeight + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
    css += "position:" + ((isScroller || containerAnimation) && useFixedPosition ? "fixed;" : "absolute;");
    (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _vertical ? _right : _bottom) + ":" + (offset + parseFloat(indent)) + "px;");
    matchWidthEl && (css += "box-sizing:border-box;text-align:left;width:" + matchWidthEl.offsetWidth + "px;");
    e._isStart = isStart;
    e.setAttribute("class", "gsap-marker-" + type + (name ? " marker-" + name : ""));
    e.style.cssText = css;
    e.innerText = name || name === 0 ? type + "-" + name : type;
    parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);
    e._offset = e["offset" + direction.op.d2];
    _positionMarker(e, 0, direction, isStart);
    return e;
  };
  var _positionMarker = function _positionMarker2(marker, start, direction, flipped) {
    var vars = {
      display: "block"
    }, side = direction[flipped ? "os2" : "p2"], oppositeSide = direction[flipped ? "p2" : "os2"];
    marker._isFlipped = flipped;
    vars[direction.a + "Percent"] = flipped ? -100 : 0;
    vars[direction.a] = flipped ? "1px" : 0;
    vars["border" + side + _Width] = 1;
    vars["border" + oppositeSide + _Width] = 0;
    vars[direction.p] = start + "px";
    gsap3.set(marker, vars);
  };
  var _triggers = [];
  var _ids = {};
  var _rafID;
  var _sync = function _sync2() {
    return _getTime2() - _lastScrollTime > 34 && (_rafID || (_rafID = requestAnimationFrame(_updateAll)));
  };
  var _onScroll3 = function _onScroll4() {
    if (!_normalizer2 || !_normalizer2.isPressed || _normalizer2.startX > _body2.clientWidth) {
      _scrollers.cache++;
      if (_normalizer2) {
        _rafID || (_rafID = requestAnimationFrame(_updateAll));
      } else {
        _updateAll();
      }
      _lastScrollTime || _dispatch3("scrollStart");
      _lastScrollTime = _getTime2();
    }
  };
  var _setBaseDimensions = function _setBaseDimensions2() {
    _baseScreenWidth = _win4.innerWidth;
    _baseScreenHeight = _win4.innerHeight;
  };
  var _onResize = function _onResize2(force) {
    _scrollers.cache++;
    (force === true || !_refreshing && !_ignoreResize && !_doc4.fullscreenElement && !_doc4.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== _win4.innerWidth || Math.abs(_win4.innerHeight - _baseScreenHeight) > _win4.innerHeight * 0.25)) && _resizeDelay.restart(true);
  };
  var _listeners2 = {};
  var _emptyArray2 = [];
  var _softRefresh = function _softRefresh2() {
    return _removeListener3(ScrollTrigger2, "scrollEnd", _softRefresh2) || _refreshAll(true);
  };
  var _dispatch3 = function _dispatch4(type) {
    return _listeners2[type] && _listeners2[type].map(function(f) {
      return f();
    }) || _emptyArray2;
  };
  var _savedStyles = [];
  var _revertRecorded = function _revertRecorded2(media) {
    for (var i = 0; i < _savedStyles.length; i += 5) {
      if (!media || _savedStyles[i + 4] && _savedStyles[i + 4].query === media) {
        _savedStyles[i].style.cssText = _savedStyles[i + 1];
        _savedStyles[i].getBBox && _savedStyles[i].setAttribute("transform", _savedStyles[i + 2] || "");
        _savedStyles[i + 3].uncache = 1;
      }
    }
  };
  var _revertAll = function _revertAll2(kill2, media) {
    var trigger;
    for (_i = 0; _i < _triggers.length; _i++) {
      trigger = _triggers[_i];
      if (trigger && (!media || trigger._ctx === media)) {
        if (kill2) {
          trigger.kill(1);
        } else {
          trigger.revert(true, true);
        }
      }
    }
    _isReverted = true;
    media && _revertRecorded(media);
    media || _dispatch3("revert");
  };
  var _clearScrollMemory = function _clearScrollMemory2(scrollRestoration, force) {
    _scrollers.cache++;
    (force || !_refreshingAll) && _scrollers.forEach(function(obj) {
      return _isFunction3(obj) && obj.cacheID++ && (obj.rec = 0);
    });
    _isString3(scrollRestoration) && (_win4.history.scrollRestoration = _scrollRestoration = scrollRestoration);
  };
  var _refreshingAll;
  var _refreshID = 0;
  var _queueRefreshID;
  var _queueRefreshAll = function _queueRefreshAll2() {
    if (_queueRefreshID !== _refreshID) {
      var id = _queueRefreshID = _refreshID;
      requestAnimationFrame(function() {
        return id === _refreshID && _refreshAll(true);
      });
    }
  };
  var _refresh100vh = function _refresh100vh2() {
    _body2.appendChild(_div100vh);
    _100vh = !_normalizer2 && _div100vh.offsetHeight || _win4.innerHeight;
    _body2.removeChild(_div100vh);
  };
  var _hideAllMarkers = function _hideAllMarkers2(hide) {
    return _toArray(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function(el) {
      return el.style.display = hide ? "none" : "block";
    });
  };
  var _refreshAll = function _refreshAll2(force, skipRevert) {
    _docEl2 = _doc4.documentElement;
    _body2 = _doc4.body;
    _root2 = [_win4, _doc4, _docEl2, _body2];
    if (_lastScrollTime && !force && !_isReverted) {
      _addListener3(ScrollTrigger2, "scrollEnd", _softRefresh);
      return;
    }
    _refresh100vh();
    _refreshingAll = ScrollTrigger2.isRefreshing = true;
    _scrollers.forEach(function(obj) {
      return _isFunction3(obj) && ++obj.cacheID && (obj.rec = obj());
    });
    var refreshInits = _dispatch3("refreshInit");
    _sort && ScrollTrigger2.sort();
    skipRevert || _revertAll();
    _scrollers.forEach(function(obj) {
      if (_isFunction3(obj)) {
        obj.smooth && (obj.target.style.scrollBehavior = "auto");
        obj(0);
      }
    });
    _triggers.slice(0).forEach(function(t) {
      return t.refresh();
    });
    _isReverted = false;
    _triggers.forEach(function(t) {
      if (t._subPinOffset && t.pin) {
        var prop = t.vars.horizontal ? "offsetWidth" : "offsetHeight", original = t.pin[prop];
        t.revert(true, 1);
        t.adjustPinSpacing(t.pin[prop] - original);
        t.refresh();
      }
    });
    _clampingMax = 1;
    _hideAllMarkers(true);
    _triggers.forEach(function(t) {
      var max = _maxScroll(t.scroller, t._dir), endClamp = t.vars.end === "max" || t._endClamp && t.end > max, startClamp = t._startClamp && t.start >= max;
      (endClamp || startClamp) && t.setPositions(startClamp ? max - 1 : t.start, endClamp ? Math.max(startClamp ? max : t.start + 1, max) : t.end, true);
    });
    _hideAllMarkers(false);
    _clampingMax = 0;
    refreshInits.forEach(function(result) {
      return result && result.render && result.render(-1);
    });
    _scrollers.forEach(function(obj) {
      if (_isFunction3(obj)) {
        obj.smooth && requestAnimationFrame(function() {
          return obj.target.style.scrollBehavior = "smooth";
        });
        obj.rec && obj(obj.rec);
      }
    });
    _clearScrollMemory(_scrollRestoration, 1);
    _resizeDelay.pause();
    _refreshID++;
    _refreshingAll = 2;
    _updateAll(2);
    _triggers.forEach(function(t) {
      return _isFunction3(t.vars.onRefresh) && t.vars.onRefresh(t);
    });
    _refreshingAll = ScrollTrigger2.isRefreshing = false;
    _dispatch3("refresh");
  };
  var _lastScroll = 0;
  var _direction = 1;
  var _primary;
  var _updateAll = function _updateAll2(force) {
    if (force === 2 || !_refreshingAll && !_isReverted) {
      ScrollTrigger2.isUpdating = true;
      _primary && _primary.update(0);
      var l = _triggers.length, time = _getTime2(), recordVelocity = time - _time1 >= 50, scroll = l && _triggers[0].scroll();
      _direction = _lastScroll > scroll ? -1 : 1;
      _refreshingAll || (_lastScroll = scroll);
      if (recordVelocity) {
        if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {
          _lastScrollTime = 0;
          _dispatch3("scrollEnd");
        }
        _time2 = _time1;
        _time1 = time;
      }
      if (_direction < 0) {
        _i = l;
        while (_i-- > 0) {
          _triggers[_i] && _triggers[_i].update(0, recordVelocity);
        }
        _direction = 1;
      } else {
        for (_i = 0; _i < l; _i++) {
          _triggers[_i] && _triggers[_i].update(0, recordVelocity);
        }
      }
      ScrollTrigger2.isUpdating = false;
    }
    _rafID = 0;
  };
  var _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"];
  var _stateProps = _propNamesToCopy.concat([_width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]);
  var _swapPinOut = function _swapPinOut2(pin, spacer, state) {
    _setState(state);
    var cache = pin._gsap;
    if (cache.spacerIsNative) {
      _setState(cache.spacerState);
    } else if (pin._gsap.swappedIn) {
      var parent = spacer.parentNode;
      if (parent) {
        parent.insertBefore(pin, spacer);
        parent.removeChild(spacer);
      }
    }
    pin._gsap.swappedIn = false;
  };
  var _swapPinIn = function _swapPinIn2(pin, spacer, cs, spacerState) {
    if (!pin._gsap.swappedIn) {
      var i = _propNamesToCopy.length, spacerStyle = spacer.style, pinStyle = pin.style, p;
      while (i--) {
        p = _propNamesToCopy[i];
        spacerStyle[p] = cs[p];
      }
      spacerStyle.position = cs.position === "absolute" ? "absolute" : "relative";
      cs.display === "inline" && (spacerStyle.display = "inline-block");
      pinStyle[_bottom] = pinStyle[_right] = "auto";
      spacerStyle.flexBasis = cs.flexBasis || "auto";
      spacerStyle.overflow = "visible";
      spacerStyle.boxSizing = "border-box";
      spacerStyle[_width] = _getSize(pin, _horizontal) + _px;
      spacerStyle[_height] = _getSize(pin, _vertical) + _px;
      spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = "0";
      _setState(spacerState);
      pinStyle[_width] = pinStyle["max" + _Width] = cs[_width];
      pinStyle[_height] = pinStyle["max" + _Height] = cs[_height];
      pinStyle[_padding] = cs[_padding];
      if (pin.parentNode !== spacer) {
        pin.parentNode.insertBefore(spacer, pin);
        spacer.appendChild(pin);
      }
      pin._gsap.swappedIn = true;
    }
  };
  var _capsExp2 = /([A-Z])/g;
  var _setState = function _setState2(state) {
    if (state) {
      var style = state.t.style, l = state.length, i = 0, p, value;
      (state.t._gsap || gsap3.core.getCache(state.t)).uncache = 1;
      for (; i < l; i += 2) {
        value = state[i + 1];
        p = state[i];
        if (value) {
          style[p] = value;
        } else if (style[p]) {
          style.removeProperty(p.replace(_capsExp2, "-$1").toLowerCase());
        }
      }
    }
  };
  var _getState = function _getState2(element) {
    var l = _stateProps.length, style = element.style, state = [], i = 0;
    for (; i < l; i++) {
      state.push(_stateProps[i], style[_stateProps[i]]);
    }
    state.t = element;
    return state;
  };
  var _copyState = function _copyState2(state, override, omitOffsets) {
    var result = [], l = state.length, i = omitOffsets ? 8 : 0, p;
    for (; i < l; i += 2) {
      p = state[i];
      result.push(p, p in override ? override[p] : state[i + 1]);
    }
    result.t = state.t;
    return result;
  };
  var _winOffsets = {
    left: 0,
    top: 0
  };
  var _parsePosition3 = function _parsePosition4(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation, clampZeroProp) {
    _isFunction3(value) && (value = value(self));
    if (_isString3(value) && value.substr(0, 3) === "max") {
      value = scrollerMax + (value.charAt(4) === "=" ? _offsetToPx("0" + value.substr(3), scrollerSize) : 0);
    }
    var time = containerAnimation ? containerAnimation.time() : 0, p1, p2, element;
    containerAnimation && containerAnimation.seek(0);
    isNaN(value) || (value = +value);
    if (!_isNumber3(value)) {
      _isFunction3(trigger) && (trigger = trigger(self));
      var offsets = (value || "0").split(" "), bounds, localOffset, globalOffset, display;
      element = _getTarget(trigger, self) || _body2;
      bounds = _getBounds(element) || {};
      if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === "none") {
        display = element.style.display;
        element.style.display = "block";
        bounds = _getBounds(element);
        display ? element.style.display = display : element.style.removeProperty("display");
      }
      localOffset = _offsetToPx(offsets[0], bounds[direction.d]);
      globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize);
      value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;
      markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);
      scrollerSize -= scrollerSize - globalOffset;
    } else {
      containerAnimation && (value = gsap3.utils.mapRange(containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, 0, scrollerMax, value));
      markerScroller && _positionMarker(markerScroller, scrollerSize, direction, true);
    }
    if (clampZeroProp) {
      self[clampZeroProp] = value || -1e-3;
      value < 0 && (value = 0);
    }
    if (marker) {
      var position = value + scrollerSize, isStart = marker._isStart;
      p1 = "scroll" + direction.d2;
      _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body2[p1], _docEl2[p1]) : marker.parentNode[p1]) <= position + 1);
      if (useFixedPosition) {
        scrollerBounds = _getBounds(markerScroller);
        useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);
      }
    }
    if (containerAnimation && element) {
      p1 = _getBounds(element);
      containerAnimation.seek(scrollerMax);
      p2 = _getBounds(element);
      containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];
      value = value / containerAnimation._caScrollDist * scrollerMax;
    }
    containerAnimation && containerAnimation.seek(time);
    return containerAnimation ? value : Math.round(value);
  };
  var _prefixExp = /(webkit|moz|length|cssText|inset)/i;
  var _reparent = function _reparent2(element, parent, top, left) {
    if (element.parentNode !== parent) {
      var style = element.style, p, cs;
      if (parent === _body2) {
        element._stOrig = style.cssText;
        cs = _getComputedStyle(element);
        for (p in cs) {
          if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === "string" && p !== "0") {
            style[p] = cs[p];
          }
        }
        style.top = top;
        style.left = left;
      } else {
        style.cssText = element._stOrig;
      }
      gsap3.core.getCache(element).uncache = 1;
      parent.appendChild(element);
    }
  };
  var _interruptionTracker = function _interruptionTracker2(getValueFunc, initialValue, onInterrupt) {
    var last1 = initialValue, last2 = last1;
    return function(value) {
      var current = Math.round(getValueFunc());
      if (current !== last1 && current !== last2 && Math.abs(current - last1) > 3 && Math.abs(current - last2) > 3) {
        value = current;
        onInterrupt && onInterrupt();
      }
      last2 = last1;
      last1 = Math.round(value);
      return last1;
    };
  };
  var _shiftMarker = function _shiftMarker2(marker, direction, value) {
    var vars = {};
    vars[direction.p] = "+=" + value;
    gsap3.set(marker, vars);
  };
  var _getTweenCreator = function _getTweenCreator2(scroller, direction) {
    var getScroll = _getScrollFunc(scroller, direction), prop = "_scroll" + direction.p2, getTween = function getTween2(scrollTo, vars, initialValue, change1, change2) {
      var tween = getTween2.tween, onComplete = vars.onComplete, modifiers = {};
      initialValue = initialValue || getScroll();
      var checkForInterruption = _interruptionTracker(getScroll, initialValue, function() {
        tween.kill();
        getTween2.tween = 0;
      });
      change2 = change1 && change2 || 0;
      change1 = change1 || scrollTo - initialValue;
      tween && tween.kill();
      vars[prop] = scrollTo;
      vars.inherit = false;
      vars.modifiers = modifiers;
      modifiers[prop] = function() {
        return checkForInterruption(initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio);
      };
      vars.onUpdate = function() {
        _scrollers.cache++;
        getTween2.tween && _updateAll();
      };
      vars.onComplete = function() {
        getTween2.tween = 0;
        onComplete && onComplete.call(tween);
      };
      tween = getTween2.tween = gsap3.to(scroller, vars);
      return tween;
    };
    scroller[prop] = getScroll;
    getScroll.wheelHandler = function() {
      return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);
    };
    _addListener3(scroller, "wheel", getScroll.wheelHandler);
    ScrollTrigger2.isTouch && _addListener3(scroller, "touchmove", getScroll.wheelHandler);
    return getTween;
  };
  var ScrollTrigger2 = /* @__PURE__ */ function() {
    function ScrollTrigger4(vars, animation) {
      _coreInitted3 || ScrollTrigger4.register(gsap3) || console.warn("Please gsap.registerPlugin(ScrollTrigger)");
      _context3(this);
      this.init(vars, animation);
    }
    var _proto = ScrollTrigger4.prototype;
    _proto.init = function init5(vars, animation) {
      this.progress = this.start = 0;
      this.vars && this.kill(true, true);
      if (!_enabled) {
        this.update = this.refresh = this.kill = _passThrough3;
        return;
      }
      vars = _setDefaults3(_isString3(vars) || _isNumber3(vars) || vars.nodeType ? {
        trigger: vars
      } : vars, _defaults2);
      var _vars = vars, onUpdate = _vars.onUpdate, toggleClass = _vars.toggleClass, id = _vars.id, onToggle = _vars.onToggle, onRefresh = _vars.onRefresh, scrub = _vars.scrub, trigger = _vars.trigger, pin = _vars.pin, pinSpacing = _vars.pinSpacing, invalidateOnRefresh = _vars.invalidateOnRefresh, anticipatePin = _vars.anticipatePin, onScrubComplete = _vars.onScrubComplete, onSnapComplete = _vars.onSnapComplete, once = _vars.once, snap3 = _vars.snap, pinReparent = _vars.pinReparent, pinSpacer = _vars.pinSpacer, containerAnimation = _vars.containerAnimation, fastScrollEnd = _vars.fastScrollEnd, preventOverlaps = _vars.preventOverlaps, direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _horizontal : _vertical, isToggle = !scrub && scrub !== 0, scroller = _getTarget(vars.scroller || _win4), scrollerCache = gsap3.core.getCache(scroller), isViewport = _isViewport3(scroller), useFixedPosition = ("pinType" in vars ? vars.pinType : _getProxyProp(scroller, "pinType") || isViewport && "fixed") === "fixed", callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack], toggleActions = isToggle && vars.toggleActions.split(" "), markers = "markers" in vars ? vars.markers : _defaults2.markers, borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0, self = this, onRefreshInit = vars.onRefreshInit && function() {
        return vars.onRefreshInit(self);
      }, getScrollerSize = _getSizeFunc(scroller, isViewport, direction), getScrollerOffsets = _getOffsetsFunc(scroller, isViewport), lastSnap = 0, lastRefresh = 0, prevProgress = 0, scrollFunc = _getScrollFunc(scroller, direction), tweenTo, pinCache, snapFunc, scroll1, scroll2, start, end, markerStart, markerEnd, markerStartTrigger, markerEndTrigger, markerVars, executingOnRefresh, change, pinOriginalState, pinActiveState, pinState, spacer, offset, pinGetter, pinSetter, pinStart, pinChange, spacingStart, spacerState, markerStartSetter, pinMoves, markerEndSetter, cs, snap1, snap22, scrubTween, scrubSmooth, snapDurClamp, snapDelayedCall, prevScroll, prevAnimProgress, caMarkerSetter, customRevertReturn;
      self._startClamp = self._endClamp = false;
      self._dir = direction;
      anticipatePin *= 45;
      self.scroller = scroller;
      self.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;
      scroll1 = scrollFunc();
      self.vars = vars;
      animation = animation || vars.animation;
      if ("refreshPriority" in vars) {
        _sort = 1;
        vars.refreshPriority === -9999 && (_primary = self);
      }
      scrollerCache.tweenScroll = scrollerCache.tweenScroll || {
        top: _getTweenCreator(scroller, _vertical),
        left: _getTweenCreator(scroller, _horizontal)
      };
      self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];
      self.scrubDuration = function(value) {
        scrubSmooth = _isNumber3(value) && value;
        if (!scrubSmooth) {
          scrubTween && scrubTween.progress(1).kill();
          scrubTween = 0;
        } else {
          scrubTween ? scrubTween.duration(value) : scrubTween = gsap3.to(animation, {
            ease: "expo",
            totalProgress: "+=0",
            inherit: false,
            duration: scrubSmooth,
            paused: true,
            onComplete: function onComplete() {
              return onScrubComplete && onScrubComplete(self);
            }
          });
        }
      };
      if (animation) {
        animation.vars.lazy = false;
        animation._initted && !self.isReverted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.duration() && animation.render(0, true, true);
        self.animation = animation.pause();
        animation.scrollTrigger = self;
        self.scrubDuration(scrub);
        snap1 = 0;
        id || (id = animation.vars.id);
      }
      if (snap3) {
        if (!_isObject3(snap3) || snap3.push) {
          snap3 = {
            snapTo: snap3
          };
        }
        "scrollBehavior" in _body2.style && gsap3.set(isViewport ? [_body2, _docEl2] : scroller, {
          scrollBehavior: "auto"
        });
        _scrollers.forEach(function(o) {
          return _isFunction3(o) && o.target === (isViewport ? _doc4.scrollingElement || _docEl2 : scroller) && (o.smooth = false);
        });
        snapFunc = _isFunction3(snap3.snapTo) ? snap3.snapTo : snap3.snapTo === "labels" ? _getClosestLabel(animation) : snap3.snapTo === "labelsDirectional" ? _getLabelAtDirection(animation) : snap3.directional !== false ? function(value, st) {
          return _snapDirectional(snap3.snapTo)(value, _getTime2() - lastRefresh < 500 ? 0 : st.direction);
        } : gsap3.utils.snap(snap3.snapTo);
        snapDurClamp = snap3.duration || {
          min: 0.1,
          max: 2
        };
        snapDurClamp = _isObject3(snapDurClamp) ? _clamp4(snapDurClamp.min, snapDurClamp.max) : _clamp4(snapDurClamp, snapDurClamp);
        snapDelayedCall = gsap3.delayedCall(snap3.delay || scrubSmooth / 2 || 0.1, function() {
          var scroll = scrollFunc(), refreshedRecently = _getTime2() - lastRefresh < 500, tween = tweenTo.tween;
          if ((refreshedRecently || Math.abs(self.getVelocity()) < 10) && !tween && !_pointerIsDown && lastSnap !== scroll) {
            var progress = (scroll - start) / change, totalProgress = animation && !isToggle ? animation.totalProgress() : progress, velocity = refreshedRecently ? 0 : (totalProgress - snap22) / (_getTime2() - _time2) * 1e3 || 0, change1 = gsap3.utils.clamp(-progress, 1 - progress, _abs(velocity / 2) * velocity / 0.185), naturalEnd = progress + (snap3.inertia === false ? 0 : change1), endValue, endScroll, _snap = snap3, onStart = _snap.onStart, _onInterrupt = _snap.onInterrupt, _onComplete = _snap.onComplete;
            endValue = snapFunc(naturalEnd, self);
            _isNumber3(endValue) || (endValue = naturalEnd);
            endScroll = Math.max(0, Math.round(start + endValue * change));
            if (scroll <= end && scroll >= start && endScroll !== scroll) {
              if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) {
                return;
              }
              if (snap3.inertia === false) {
                change1 = endValue - progress;
              }
              tweenTo(endScroll, {
                duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),
                ease: snap3.ease || "power3",
                data: _abs(endScroll - scroll),
                // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.
                onInterrupt: function onInterrupt() {
                  return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self);
                },
                onComplete: function onComplete() {
                  self.update();
                  lastSnap = scrollFunc();
                  if (animation && !isToggle) {
                    scrubTween ? scrubTween.resetTo("totalProgress", endValue, animation._tTime / animation._tDur) : animation.progress(endValue);
                  }
                  snap1 = snap22 = animation && !isToggle ? animation.totalProgress() : self.progress;
                  onSnapComplete && onSnapComplete(self);
                  _onComplete && _onComplete(self);
                }
              }, scroll, change1 * change, endScroll - scroll - change1 * change);
              onStart && onStart(self, tweenTo.tween);
            }
          } else if (self.isActive && lastSnap !== scroll) {
            snapDelayedCall.restart(true);
          }
        }).pause();
      }
      id && (_ids[id] = self);
      trigger = self.trigger = _getTarget(trigger || pin !== true && pin);
      customRevertReturn = trigger && trigger._gsap && trigger._gsap.stRevert;
      customRevertReturn && (customRevertReturn = customRevertReturn(self));
      pin = pin === true ? trigger : _getTarget(pin);
      _isString3(toggleClass) && (toggleClass = {
        targets: trigger,
        className: toggleClass
      });
      if (pin) {
        pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && pin.parentNode && pin.parentNode.style && _getComputedStyle(pin.parentNode).display === "flex" ? false : _padding);
        self.pin = pin;
        pinCache = gsap3.core.getCache(pin);
        if (!pinCache.spacer) {
          if (pinSpacer) {
            pinSpacer = _getTarget(pinSpacer);
            pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement);
            pinCache.spacerIsNative = !!pinSpacer;
            pinSpacer && (pinCache.spacerState = _getState(pinSpacer));
          }
          pinCache.spacer = spacer = pinSpacer || _doc4.createElement("div");
          spacer.classList.add("pin-spacer");
          id && spacer.classList.add("pin-spacer-" + id);
          pinCache.pinState = pinOriginalState = _getState(pin);
        } else {
          pinOriginalState = pinCache.pinState;
        }
        vars.force3D !== false && gsap3.set(pin, {
          force3D: true
        });
        self.spacer = spacer = pinCache.spacer;
        cs = _getComputedStyle(pin);
        spacingStart = cs[pinSpacing + direction.os2];
        pinGetter = gsap3.getProperty(pin);
        pinSetter = gsap3.quickSetter(pin, direction.a, _px);
        _swapPinIn(pin, spacer, cs);
        pinState = _getState(pin);
      }
      if (markers) {
        markerVars = _isObject3(markers) ? _setDefaults3(markers, _markerDefaults) : _markerDefaults;
        markerStartTrigger = _createMarker("scroller-start", id, scroller, direction, markerVars, 0);
        markerEndTrigger = _createMarker("scroller-end", id, scroller, direction, markerVars, 0, markerStartTrigger);
        offset = markerStartTrigger["offset" + direction.op.d2];
        var content = _getTarget(_getProxyProp(scroller, "content") || scroller);
        markerStart = this.markerStart = _createMarker("start", id, content, direction, markerVars, offset, 0, containerAnimation);
        markerEnd = this.markerEnd = _createMarker("end", id, content, direction, markerVars, offset, 0, containerAnimation);
        containerAnimation && (caMarkerSetter = gsap3.quickSetter([markerStart, markerEnd], direction.a, _px));
        if (!useFixedPosition && !(_proxies.length && _getProxyProp(scroller, "fixedMarkers") === true)) {
          _makePositionable(isViewport ? _body2 : scroller);
          gsap3.set([markerStartTrigger, markerEndTrigger], {
            force3D: true
          });
          markerStartSetter = gsap3.quickSetter(markerStartTrigger, direction.a, _px);
          markerEndSetter = gsap3.quickSetter(markerEndTrigger, direction.a, _px);
        }
      }
      if (containerAnimation) {
        var oldOnUpdate = containerAnimation.vars.onUpdate, oldParams = containerAnimation.vars.onUpdateParams;
        containerAnimation.eventCallback("onUpdate", function() {
          self.update(0, 0, 1);
          oldOnUpdate && oldOnUpdate.apply(containerAnimation, oldParams || []);
        });
      }
      self.previous = function() {
        return _triggers[_triggers.indexOf(self) - 1];
      };
      self.next = function() {
        return _triggers[_triggers.indexOf(self) + 1];
      };
      self.revert = function(revert, temp) {
        if (!temp) {
          return self.kill(true);
        }
        var r = revert !== false || !self.enabled, prevRefreshing = _refreshing;
        if (r !== self.isReverted) {
          if (r) {
            prevScroll = Math.max(scrollFunc(), self.scroll.rec || 0);
            prevProgress = self.progress;
            prevAnimProgress = animation && animation.progress();
          }
          markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function(m) {
            return m.style.display = r ? "none" : "block";
          });
          if (r) {
            _refreshing = self;
            self.update(r);
          }
          if (pin && (!pinReparent || !self.isActive)) {
            if (r) {
              _swapPinOut(pin, spacer, pinOriginalState);
            } else {
              _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState);
            }
          }
          r || self.update(r);
          _refreshing = prevRefreshing;
          self.isReverted = r;
        }
      };
      self.refresh = function(soft, force, position, pinOffset) {
        if ((_refreshing || !self.enabled) && !force) {
          return;
        }
        if (pin && soft && _lastScrollTime) {
          _addListener3(ScrollTrigger4, "scrollEnd", _softRefresh);
          return;
        }
        !_refreshingAll && onRefreshInit && onRefreshInit(self);
        _refreshing = self;
        if (tweenTo.tween && !position) {
          tweenTo.tween.kill();
          tweenTo.tween = 0;
        }
        scrubTween && scrubTween.pause();
        invalidateOnRefresh && animation && animation.revert({
          kill: false
        }).invalidate();
        self.isReverted || self.revert(true, true);
        self._subPinOffset = false;
        var size = getScrollerSize(), scrollerBounds = getScrollerOffsets(), max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction), isFirstRefresh = change <= 0.01, offset2 = 0, otherPinOffset = pinOffset || 0, parsedEnd = _isObject3(position) ? position.end : vars.end, parsedEndTrigger = vars.endTrigger || trigger, parsedStart = _isObject3(position) ? position.start : vars.start || (vars.start === 0 || !trigger ? 0 : pin ? "0 0" : "0 100%"), pinnedContainer = self.pinnedContainer = vars.pinnedContainer && _getTarget(vars.pinnedContainer, self), triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0, i = triggerIndex, cs2, bounds, scroll, isVertical, override, curTrigger, curPin, oppositeScroll, initted, revertedPins, forcedOverflow, markerStartOffset, markerEndOffset;
        if (markers && _isObject3(position)) {
          markerStartOffset = gsap3.getProperty(markerStartTrigger, direction.p);
          markerEndOffset = gsap3.getProperty(markerEndTrigger, direction.p);
        }
        while (i-- > 0) {
          curTrigger = _triggers[i];
          curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = self);
          curPin = curTrigger.pin;
          if (curPin && (curPin === trigger || curPin === pin || curPin === pinnedContainer) && !curTrigger.isReverted) {
            revertedPins || (revertedPins = []);
            revertedPins.unshift(curTrigger);
            curTrigger.revert(true, true);
          }
          if (curTrigger !== _triggers[i]) {
            triggerIndex--;
            i--;
          }
        }
        _isFunction3(parsedStart) && (parsedStart = parsedStart(self));
        parsedStart = _parseClamp(parsedStart, "start", self);
        start = _parsePosition3(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._startClamp && "_startClamp") || (pin ? -1e-3 : 0);
        _isFunction3(parsedEnd) && (parsedEnd = parsedEnd(self));
        if (_isString3(parsedEnd) && !parsedEnd.indexOf("+=")) {
          if (~parsedEnd.indexOf(" ")) {
            parsedEnd = (_isString3(parsedStart) ? parsedStart.split(" ")[0] : "") + parsedEnd;
          } else {
            offset2 = _offsetToPx(parsedEnd.substr(2), size);
            parsedEnd = _isString3(parsedStart) ? parsedStart : (containerAnimation ? gsap3.utils.mapRange(0, containerAnimation.duration(), containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, start) : start) + offset2;
            parsedEndTrigger = trigger;
          }
        }
        parsedEnd = _parseClamp(parsedEnd, "end", self);
        end = Math.max(start, _parsePosition3(parsedEnd || (parsedEndTrigger ? "100% 0" : max), parsedEndTrigger, size, direction, scrollFunc() + offset2, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._endClamp && "_endClamp")) || -1e-3;
        offset2 = 0;
        i = triggerIndex;
        while (i--) {
          curTrigger = _triggers[i];
          curPin = curTrigger.pin;
          if (curPin && curTrigger.start - curTrigger._pinPush <= start && !containerAnimation && curTrigger.end > 0) {
            cs2 = curTrigger.end - (self._startClamp ? Math.max(0, curTrigger.start) : curTrigger.start);
            if ((curPin === trigger && curTrigger.start - curTrigger._pinPush < start || curPin === pinnedContainer) && isNaN(parsedStart)) {
              offset2 += cs2 * (1 - curTrigger.progress);
            }
            curPin === pin && (otherPinOffset += cs2);
          }
        }
        start += offset2;
        end += offset2;
        self._startClamp && (self._startClamp += offset2);
        if (self._endClamp && !_refreshingAll) {
          self._endClamp = end || -1e-3;
          end = Math.min(end, _maxScroll(scroller, direction));
        }
        change = end - start || (start -= 0.01) && 1e-3;
        if (isFirstRefresh) {
          prevProgress = gsap3.utils.clamp(0, 1, gsap3.utils.normalize(start, end, prevScroll));
        }
        self._pinPush = otherPinOffset;
        if (markerStart && offset2) {
          cs2 = {};
          cs2[direction.a] = "+=" + offset2;
          pinnedContainer && (cs2[direction.p] = "-=" + scrollFunc());
          gsap3.set([markerStart, markerEnd], cs2);
        }
        if (pin && !(_clampingMax && self.end >= _maxScroll(scroller, direction))) {
          cs2 = _getComputedStyle(pin);
          isVertical = direction === _vertical;
          scroll = scrollFunc();
          pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;
          if (!max && end > 1) {
            forcedOverflow = (isViewport ? _doc4.scrollingElement || _docEl2 : scroller).style;
            forcedOverflow = {
              style: forcedOverflow,
              value: forcedOverflow["overflow" + direction.a.toUpperCase()]
            };
            if (isViewport && _getComputedStyle(_body2)["overflow" + direction.a.toUpperCase()] !== "scroll") {
              forcedOverflow.style["overflow" + direction.a.toUpperCase()] = "scroll";
            }
          }
          _swapPinIn(pin, spacer, cs2);
          pinState = _getState(pin);
          bounds = _getBounds(pin, true);
          oppositeScroll = useFixedPosition && _getScrollFunc(scroller, isVertical ? _horizontal : _vertical)();
          if (pinSpacing) {
            spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];
            spacerState.t = spacer;
            i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;
            if (i) {
              spacerState.push(direction.d, i + _px);
              spacer.style.flexBasis !== "auto" && (spacer.style.flexBasis = i + _px);
            }
            _setState(spacerState);
            if (pinnedContainer) {
              _triggers.forEach(function(t) {
                if (t.pin === pinnedContainer && t.vars.pinSpacing !== false) {
                  t._subPinOffset = true;
                }
              });
            }
            useFixedPosition && scrollFunc(prevScroll);
          } else {
            i = _getSize(pin, direction);
            i && spacer.style.flexBasis !== "auto" && (spacer.style.flexBasis = i + _px);
          }
          if (useFixedPosition) {
            override = {
              top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,
              left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,
              boxSizing: "border-box",
              position: "fixed"
            };
            override[_width] = override["max" + _Width] = Math.ceil(bounds.width) + _px;
            override[_height] = override["max" + _Height] = Math.ceil(bounds.height) + _px;
            override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = "0";
            override[_padding] = cs2[_padding];
            override[_padding + _Top] = cs2[_padding + _Top];
            override[_padding + _Right] = cs2[_padding + _Right];
            override[_padding + _Bottom] = cs2[_padding + _Bottom];
            override[_padding + _Left] = cs2[_padding + _Left];
            pinActiveState = _copyState(pinOriginalState, override, pinReparent);
            _refreshingAll && scrollFunc(0);
          }
          if (animation) {
            initted = animation._initted;
            _suppressOverwrites2(1);
            animation.render(animation.duration(), true, true);
            pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;
            pinMoves = Math.abs(change - pinChange) > 1;
            useFixedPosition && pinMoves && pinActiveState.splice(pinActiveState.length - 2, 2);
            animation.render(0, true, true);
            initted || animation.invalidate(true);
            animation.parent || animation.totalTime(animation.totalTime());
            _suppressOverwrites2(0);
          } else {
            pinChange = change;
          }
          forcedOverflow && (forcedOverflow.value ? forcedOverflow.style["overflow" + direction.a.toUpperCase()] = forcedOverflow.value : forcedOverflow.style.removeProperty("overflow-" + direction.a));
        } else if (trigger && scrollFunc() && !containerAnimation) {
          bounds = trigger.parentNode;
          while (bounds && bounds !== _body2) {
            if (bounds._pinOffset) {
              start -= bounds._pinOffset;
              end -= bounds._pinOffset;
            }
            bounds = bounds.parentNode;
          }
        }
        revertedPins && revertedPins.forEach(function(t) {
          return t.revert(false, true);
        });
        self.start = start;
        self.end = end;
        scroll1 = scroll2 = _refreshingAll ? prevScroll : scrollFunc();
        if (!containerAnimation && !_refreshingAll) {
          scroll1 < prevScroll && scrollFunc(prevScroll);
          self.scroll.rec = 0;
        }
        self.revert(false, true);
        lastRefresh = _getTime2();
        if (snapDelayedCall) {
          lastSnap = -1;
          snapDelayedCall.restart(true);
        }
        _refreshing = 0;
        animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress || 0, true).render(animation.time(), true, true);
        if (isFirstRefresh || prevProgress !== self.progress || containerAnimation || invalidateOnRefresh || animation && !animation._initted) {
          animation && !isToggle && animation.totalProgress(containerAnimation && start < -1e-3 && !prevProgress ? gsap3.utils.normalize(start, end, 0) : prevProgress, true);
          self.progress = isFirstRefresh || (scroll1 - start) / change === prevProgress ? 0 : prevProgress;
        }
        pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));
        scrubTween && scrubTween.invalidate();
        if (!isNaN(markerStartOffset)) {
          markerStartOffset -= gsap3.getProperty(markerStartTrigger, direction.p);
          markerEndOffset -= gsap3.getProperty(markerEndTrigger, direction.p);
          _shiftMarker(markerStartTrigger, direction, markerStartOffset);
          _shiftMarker(markerStart, direction, markerStartOffset - (pinOffset || 0));
          _shiftMarker(markerEndTrigger, direction, markerEndOffset);
          _shiftMarker(markerEnd, direction, markerEndOffset - (pinOffset || 0));
        }
        isFirstRefresh && !_refreshingAll && self.update();
        if (onRefresh && !_refreshingAll && !executingOnRefresh) {
          executingOnRefresh = true;
          onRefresh(self);
          executingOnRefresh = false;
        }
      };
      self.getVelocity = function() {
        return (scrollFunc() - scroll2) / (_getTime2() - _time2) * 1e3 || 0;
      };
      self.endAnimation = function() {
        _endAnimation(self.callbackAnimation);
        if (animation) {
          scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self.direction < 0, 1);
        }
      };
      self.labelToScroll = function(label) {
        return animation && animation.labels && (start || self.refresh() || start) + animation.labels[label] / animation.duration() * change || 0;
      };
      self.getTrailing = function(name) {
        var i = _triggers.indexOf(self), a = self.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i + 1);
        return (_isString3(name) ? a.filter(function(t) {
          return t.vars.preventOverlaps === name;
        }) : a).filter(function(t) {
          return self.direction > 0 ? t.end <= start : t.start >= end;
        });
      };
      self.update = function(reset, recordVelocity, forceFake) {
        if (containerAnimation && !forceFake && !reset) {
          return;
        }
        var scroll = _refreshingAll === true ? prevScroll : self.scroll(), p = reset ? 0 : (scroll - start) / change, clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0, prevProgress2 = self.progress, isActive, wasActive, toggleState, action, stateChanged, toggled, isAtMax, isTakingAction;
        if (recordVelocity) {
          scroll2 = scroll1;
          scroll1 = containerAnimation ? scrollFunc() : scroll;
          if (snap3) {
            snap22 = snap1;
            snap1 = animation && !isToggle ? animation.totalProgress() : clipped;
          }
        }
        if (anticipatePin && pin && !_refreshing && !_startup2 && _lastScrollTime) {
          if (!clipped && start < scroll + (scroll - scroll2) / (_getTime2() - _time2) * anticipatePin) {
            clipped = 1e-4;
          } else if (clipped === 1 && end > scroll + (scroll - scroll2) / (_getTime2() - _time2) * anticipatePin) {
            clipped = 0.9999;
          }
        }
        if (clipped !== prevProgress2 && self.enabled) {
          isActive = self.isActive = !!clipped && clipped < 1;
          wasActive = !!prevProgress2 && prevProgress2 < 1;
          toggled = isActive !== wasActive;
          stateChanged = toggled || !!clipped !== !!prevProgress2;
          self.direction = clipped > prevProgress2 ? 1 : -1;
          self.progress = clipped;
          if (stateChanged && !_refreshing) {
            toggleState = clipped && !prevProgress2 ? 0 : clipped === 1 ? 1 : prevProgress2 === 1 ? 2 : 3;
            if (isToggle) {
              action = !toggled && toggleActions[toggleState + 1] !== "none" && toggleActions[toggleState + 1] || toggleActions[toggleState];
              isTakingAction = animation && (action === "complete" || action === "reset" || action in animation);
            }
          }
          preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (_isFunction3(preventOverlaps) ? preventOverlaps(self) : self.getTrailing(preventOverlaps).forEach(function(t) {
            return t.endAnimation();
          }));
          if (!isToggle) {
            if (scrubTween && !_refreshing && !_startup2) {
              scrubTween._dp._time - scrubTween._start !== scrubTween._time && scrubTween.render(scrubTween._dp._time - scrubTween._start);
              if (scrubTween.resetTo) {
                scrubTween.resetTo("totalProgress", clipped, animation._tTime / animation._tDur);
              } else {
                scrubTween.vars.totalProgress = clipped;
                scrubTween.invalidate().restart();
              }
            } else if (animation) {
              animation.totalProgress(clipped, !!(_refreshing && (lastRefresh || reset)));
            }
          }
          if (pin) {
            reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);
            if (!useFixedPosition) {
              pinSetter(_round3(pinStart + pinChange * clipped));
            } else if (stateChanged) {
              isAtMax = !reset && clipped > prevProgress2 && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction);
              if (pinReparent) {
                if (!reset && (isActive || isAtMax)) {
                  var bounds = _getBounds(pin, true), _offset = scroll - start;
                  _reparent(pin, _body2, bounds.top + (direction === _vertical ? _offset : 0) + _px, bounds.left + (direction === _vertical ? 0 : _offset) + _px);
                } else {
                  _reparent(pin, spacer);
                }
              }
              _setState(isActive || isAtMax ? pinActiveState : pinState);
              pinMoves && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));
            }
          }
          snap3 && !tweenTo.tween && !_refreshing && !_startup2 && snapDelayedCall.restart(true);
          toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach(function(el) {
            return el.classList[isActive || once ? "add" : "remove"](toggleClass.className);
          });
          onUpdate && !isToggle && !reset && onUpdate(self);
          if (stateChanged && !_refreshing) {
            if (isToggle) {
              if (isTakingAction) {
                if (action === "complete") {
                  animation.pause().totalProgress(1);
                } else if (action === "reset") {
                  animation.restart(true).pause();
                } else if (action === "restart") {
                  animation.restart(true);
                } else {
                  animation[action]();
                }
              }
              onUpdate && onUpdate(self);
            }
            if (toggled || !_limitCallbacks) {
              onToggle && toggled && _callback3(self, onToggle);
              callbacks[toggleState] && _callback3(self, callbacks[toggleState]);
              once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0);
              if (!toggled) {
                toggleState = clipped === 1 ? 1 : 3;
                callbacks[toggleState] && _callback3(self, callbacks[toggleState]);
              }
            }
            if (fastScrollEnd && !isActive && Math.abs(self.getVelocity()) > (_isNumber3(fastScrollEnd) ? fastScrollEnd : 2500)) {
              _endAnimation(self.callbackAnimation);
              scrubTween ? scrubTween.progress(1) : _endAnimation(animation, action === "reverse" ? 1 : !clipped, 1);
            }
          } else if (isToggle && onUpdate && !_refreshing) {
            onUpdate(self);
          }
        }
        if (markerEndSetter) {
          var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;
          markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));
          markerEndSetter(n);
        }
        caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));
      };
      self.enable = function(reset, refresh) {
        if (!self.enabled) {
          self.enabled = true;
          _addListener3(scroller, "resize", _onResize);
          isViewport || _addListener3(scroller, "scroll", _onScroll3);
          onRefreshInit && _addListener3(ScrollTrigger4, "refreshInit", onRefreshInit);
          if (reset !== false) {
            self.progress = prevProgress = 0;
            scroll1 = scroll2 = lastSnap = scrollFunc();
          }
          refresh !== false && self.refresh();
        }
      };
      self.getTween = function(snap4) {
        return snap4 && tweenTo ? tweenTo.tween : scrubTween;
      };
      self.setPositions = function(newStart, newEnd, keepClamp, pinOffset) {
        if (containerAnimation) {
          var st = containerAnimation.scrollTrigger, duration = containerAnimation.duration(), _change = st.end - st.start;
          newStart = st.start + _change * newStart / duration;
          newEnd = st.start + _change * newEnd / duration;
        }
        self.refresh(false, false, {
          start: _keepClamp(newStart, keepClamp && !!self._startClamp),
          end: _keepClamp(newEnd, keepClamp && !!self._endClamp)
        }, pinOffset);
        self.update();
      };
      self.adjustPinSpacing = function(amount) {
        if (spacerState && amount) {
          var i = spacerState.indexOf(direction.d) + 1;
          spacerState[i] = parseFloat(spacerState[i]) + amount + _px;
          spacerState[1] = parseFloat(spacerState[1]) + amount + _px;
          _setState(spacerState);
        }
      };
      self.disable = function(reset, allowAnimation) {
        if (self.enabled) {
          reset !== false && self.revert(true, true);
          self.enabled = self.isActive = false;
          allowAnimation || scrubTween && scrubTween.pause();
          prevScroll = 0;
          pinCache && (pinCache.uncache = 1);
          onRefreshInit && _removeListener3(ScrollTrigger4, "refreshInit", onRefreshInit);
          if (snapDelayedCall) {
            snapDelayedCall.pause();
            tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);
          }
          if (!isViewport) {
            var i = _triggers.length;
            while (i--) {
              if (_triggers[i].scroller === scroller && _triggers[i] !== self) {
                return;
              }
            }
            _removeListener3(scroller, "resize", _onResize);
            isViewport || _removeListener3(scroller, "scroll", _onScroll3);
          }
        }
      };
      self.kill = function(revert, allowAnimation) {
        self.disable(revert, allowAnimation);
        scrubTween && !allowAnimation && scrubTween.kill();
        id && delete _ids[id];
        var i = _triggers.indexOf(self);
        i >= 0 && _triggers.splice(i, 1);
        i === _i && _direction > 0 && _i--;
        i = 0;
        _triggers.forEach(function(t) {
          return t.scroller === self.scroller && (i = 1);
        });
        i || _refreshingAll || (self.scroll.rec = 0);
        if (animation) {
          animation.scrollTrigger = null;
          revert && animation.revert({
            kill: false
          });
          allowAnimation || animation.kill();
        }
        markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function(m) {
          return m.parentNode && m.parentNode.removeChild(m);
        });
        _primary === self && (_primary = 0);
        if (pin) {
          pinCache && (pinCache.uncache = 1);
          i = 0;
          _triggers.forEach(function(t) {
            return t.pin === pin && i++;
          });
          i || (pinCache.spacer = 0);
        }
        vars.onKill && vars.onKill(self);
      };
      _triggers.push(self);
      self.enable(false, false);
      customRevertReturn && customRevertReturn(self);
      if (animation && animation.add && !change) {
        var updateFunc = self.update;
        self.update = function() {
          self.update = updateFunc;
          _scrollers.cache++;
          start || end || self.refresh();
        };
        gsap3.delayedCall(0.01, self.update);
        change = 0.01;
        start = end = 0;
      } else {
        self.refresh();
      }
      pin && _queueRefreshAll();
    };
    ScrollTrigger4.register = function register2(core) {
      if (!_coreInitted3) {
        gsap3 = core || _getGSAP3();
        _windowExists5() && window.document && ScrollTrigger4.enable();
        _coreInitted3 = _enabled;
      }
      return _coreInitted3;
    };
    ScrollTrigger4.defaults = function defaults2(config6) {
      if (config6) {
        for (var p in config6) {
          _defaults2[p] = config6[p];
        }
      }
      return _defaults2;
    };
    ScrollTrigger4.disable = function disable(reset, kill2) {
      _enabled = 0;
      _triggers.forEach(function(trigger) {
        return trigger[kill2 ? "kill" : "disable"](reset);
      });
      _removeListener3(_win4, "wheel", _onScroll3);
      _removeListener3(_doc4, "scroll", _onScroll3);
      clearInterval(_syncInterval);
      _removeListener3(_doc4, "touchcancel", _passThrough3);
      _removeListener3(_body2, "touchstart", _passThrough3);
      _multiListener(_removeListener3, _doc4, "pointerdown,touchstart,mousedown", _pointerDownHandler);
      _multiListener(_removeListener3, _doc4, "pointerup,touchend,mouseup", _pointerUpHandler);
      _resizeDelay.kill();
      _iterateAutoRefresh(_removeListener3);
      for (var i = 0; i < _scrollers.length; i += 3) {
        _wheelListener(_removeListener3, _scrollers[i], _scrollers[i + 1]);
        _wheelListener(_removeListener3, _scrollers[i], _scrollers[i + 2]);
      }
    };
    ScrollTrigger4.enable = function enable() {
      _win4 = window;
      _doc4 = document;
      _docEl2 = _doc4.documentElement;
      _body2 = _doc4.body;
      if (gsap3) {
        _toArray = gsap3.utils.toArray;
        _clamp4 = gsap3.utils.clamp;
        _context3 = gsap3.core.context || _passThrough3;
        _suppressOverwrites2 = gsap3.core.suppressOverwrites || _passThrough3;
        _scrollRestoration = _win4.history.scrollRestoration || "auto";
        _lastScroll = _win4.pageYOffset || 0;
        gsap3.core.globals("ScrollTrigger", ScrollTrigger4);
        if (_body2) {
          _enabled = 1;
          _div100vh = document.createElement("div");
          _div100vh.style.height = "100vh";
          _div100vh.style.position = "absolute";
          _refresh100vh();
          _rafBugFix();
          Observer2.register(gsap3);
          ScrollTrigger4.isTouch = Observer2.isTouch;
          _fixIOSBug = Observer2.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent);
          _ignoreMobileResize = Observer2.isTouch === 1;
          _addListener3(_win4, "wheel", _onScroll3);
          _root2 = [_win4, _doc4, _docEl2, _body2];
          if (gsap3.matchMedia) {
            ScrollTrigger4.matchMedia = function(vars) {
              var mm = gsap3.matchMedia(), p;
              for (p in vars) {
                mm.add(p, vars[p]);
              }
              return mm;
            };
            gsap3.addEventListener("matchMediaInit", function() {
              return _revertAll();
            });
            gsap3.addEventListener("matchMediaRevert", function() {
              return _revertRecorded();
            });
            gsap3.addEventListener("matchMedia", function() {
              _refreshAll(0, 1);
              _dispatch3("matchMedia");
            });
            gsap3.matchMedia().add("(orientation: portrait)", function() {
              _setBaseDimensions();
              return _setBaseDimensions;
            });
          } else {
            console.warn("Requires GSAP 3.11.0 or later");
          }
          _setBaseDimensions();
          _addListener3(_doc4, "scroll", _onScroll3);
          var bodyHasStyle = _body2.hasAttribute("style"), bodyStyle = _body2.style, border = bodyStyle.borderTopStyle, AnimationProto = gsap3.core.Animation.prototype, bounds, i;
          AnimationProto.revert || Object.defineProperty(AnimationProto, "revert", {
            value: function value() {
              return this.time(-0.01, true);
            }
          });
          bodyStyle.borderTopStyle = "solid";
          bounds = _getBounds(_body2);
          _vertical.m = Math.round(bounds.top + _vertical.sc()) || 0;
          _horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;
          border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty("border-top-style");
          if (!bodyHasStyle) {
            _body2.setAttribute("style", "");
            _body2.removeAttribute("style");
          }
          _syncInterval = setInterval(_sync, 250);
          gsap3.delayedCall(0.5, function() {
            return _startup2 = 0;
          });
          _addListener3(_doc4, "touchcancel", _passThrough3);
          _addListener3(_body2, "touchstart", _passThrough3);
          _multiListener(_addListener3, _doc4, "pointerdown,touchstart,mousedown", _pointerDownHandler);
          _multiListener(_addListener3, _doc4, "pointerup,touchend,mouseup", _pointerUpHandler);
          _transformProp2 = gsap3.utils.checkPrefix("transform");
          _stateProps.push(_transformProp2);
          _coreInitted3 = _getTime2();
          _resizeDelay = gsap3.delayedCall(0.2, _refreshAll).pause();
          _autoRefresh = [_doc4, "visibilitychange", function() {
            var w = _win4.innerWidth, h2 = _win4.innerHeight;
            if (_doc4.hidden) {
              _prevWidth = w;
              _prevHeight = h2;
            } else if (_prevWidth !== w || _prevHeight !== h2) {
              _onResize();
            }
          }, _doc4, "DOMContentLoaded", _refreshAll, _win4, "load", _refreshAll, _win4, "resize", _onResize];
          _iterateAutoRefresh(_addListener3);
          _triggers.forEach(function(trigger) {
            return trigger.enable(0, 1);
          });
          for (i = 0; i < _scrollers.length; i += 3) {
            _wheelListener(_removeListener3, _scrollers[i], _scrollers[i + 1]);
            _wheelListener(_removeListener3, _scrollers[i], _scrollers[i + 2]);
          }
        }
      }
    };
    ScrollTrigger4.config = function config6(vars) {
      "limitCallbacks" in vars && (_limitCallbacks = !!vars.limitCallbacks);
      var ms = vars.syncInterval;
      ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);
      "ignoreMobileResize" in vars && (_ignoreMobileResize = ScrollTrigger4.isTouch === 1 && vars.ignoreMobileResize);
      if ("autoRefreshEvents" in vars) {
        _iterateAutoRefresh(_removeListener3) || _iterateAutoRefresh(_addListener3, vars.autoRefreshEvents || "none");
        _ignoreResize = (vars.autoRefreshEvents + "").indexOf("resize") === -1;
      }
    };
    ScrollTrigger4.scrollerProxy = function scrollerProxy(target, vars) {
      var t = _getTarget(target), i = _scrollers.indexOf(t), isViewport = _isViewport3(t);
      if (~i) {
        _scrollers.splice(i, isViewport ? 6 : 2);
      }
      if (vars) {
        isViewport ? _proxies.unshift(_win4, vars, _body2, vars, _docEl2, vars) : _proxies.unshift(t, vars);
      }
    };
    ScrollTrigger4.clearMatchMedia = function clearMatchMedia(query) {
      _triggers.forEach(function(t) {
        return t._ctx && t._ctx.query === query && t._ctx.kill(true, true);
      });
    };
    ScrollTrigger4.isInViewport = function isInViewport(element, ratio, horizontal) {
      var bounds = (_isString3(element) ? _getTarget(element) : element).getBoundingClientRect(), offset = bounds[horizontal ? _width : _height] * ratio || 0;
      return horizontal ? bounds.right - offset > 0 && bounds.left + offset < _win4.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < _win4.innerHeight;
    };
    ScrollTrigger4.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {
      _isString3(element) && (element = _getTarget(element));
      var bounds = element.getBoundingClientRect(), size = bounds[horizontal ? _width : _height], offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf("%") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;
      return horizontal ? (bounds.left + offset) / _win4.innerWidth : (bounds.top + offset) / _win4.innerHeight;
    };
    ScrollTrigger4.killAll = function killAll(allowListeners) {
      _triggers.slice(0).forEach(function(t) {
        return t.vars.id !== "ScrollSmoother" && t.kill();
      });
      if (allowListeners !== true) {
        var listeners = _listeners2.killAll || [];
        _listeners2 = {};
        listeners.forEach(function(f) {
          return f();
        });
      }
    };
    return ScrollTrigger4;
  }();
  ScrollTrigger2.version = "3.12.7";
  ScrollTrigger2.saveStyles = function(targets) {
    return targets ? _toArray(targets).forEach(function(target) {
      if (target && target.style) {
        var i = _savedStyles.indexOf(target);
        i >= 0 && _savedStyles.splice(i, 5);
        _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute("transform"), gsap3.core.getCache(target), _context3());
      }
    }) : _savedStyles;
  };
  ScrollTrigger2.revert = function(soft, media) {
    return _revertAll(!soft, media);
  };
  ScrollTrigger2.create = function(vars, animation) {
    return new ScrollTrigger2(vars, animation);
  };
  ScrollTrigger2.refresh = function(safe) {
    return safe ? _onResize(true) : (_coreInitted3 || ScrollTrigger2.register()) && _refreshAll(true);
  };
  ScrollTrigger2.update = function(force) {
    return ++_scrollers.cache && _updateAll(force === true ? 2 : 0);
  };
  ScrollTrigger2.clearScrollMemory = _clearScrollMemory;
  ScrollTrigger2.maxScroll = function(element, horizontal) {
    return _maxScroll(element, horizontal ? _horizontal : _vertical);
  };
  ScrollTrigger2.getScrollFunc = function(element, horizontal) {
    return _getScrollFunc(_getTarget(element), horizontal ? _horizontal : _vertical);
  };
  ScrollTrigger2.getById = function(id) {
    return _ids[id];
  };
  ScrollTrigger2.getAll = function() {
    return _triggers.filter(function(t) {
      return t.vars.id !== "ScrollSmoother";
    });
  };
  ScrollTrigger2.isScrolling = function() {
    return !!_lastScrollTime;
  };
  ScrollTrigger2.snapDirectional = _snapDirectional;
  ScrollTrigger2.addEventListener = function(type, callback) {
    var a = _listeners2[type] || (_listeners2[type] = []);
    ~a.indexOf(callback) || a.push(callback);
  };
  ScrollTrigger2.removeEventListener = function(type, callback) {
    var a = _listeners2[type], i = a && a.indexOf(callback);
    i >= 0 && a.splice(i, 1);
  };
  ScrollTrigger2.batch = function(targets, vars) {
    var result = [], varsCopy = {}, interval = vars.interval || 0.016, batchMax = vars.batchMax || 1e9, proxyCallback = function proxyCallback2(type, callback) {
      var elements = [], triggers = [], delay2 = gsap3.delayedCall(interval, function() {
        callback(elements, triggers);
        elements = [];
        triggers = [];
      }).pause();
      return function(self) {
        elements.length || delay2.restart(true);
        elements.push(self.trigger);
        triggers.push(self);
        batchMax <= elements.length && delay2.progress(1);
      };
    }, p;
    for (p in vars) {
      varsCopy[p] = p.substr(0, 2) === "on" && _isFunction3(vars[p]) && p !== "onRefreshInit" ? proxyCallback(p, vars[p]) : vars[p];
    }
    if (_isFunction3(batchMax)) {
      batchMax = batchMax();
      _addListener3(ScrollTrigger2, "refresh", function() {
        return batchMax = vars.batchMax();
      });
    }
    _toArray(targets).forEach(function(target) {
      var config6 = {};
      for (p in varsCopy) {
        config6[p] = varsCopy[p];
      }
      config6.trigger = target;
      result.push(ScrollTrigger2.create(config6));
    });
    return result;
  };
  var _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier2(scrollFunc, current, end, max) {
    current > max ? scrollFunc(max) : current < 0 && scrollFunc(0);
    return end > max ? (max - current) / (end - current) : end < 0 ? current / (current - end) : 1;
  };
  var _allowNativePanning = function _allowNativePanning2(target, direction) {
    if (direction === true) {
      target.style.removeProperty("touch-action");
    } else {
      target.style.touchAction = direction === true ? "auto" : direction ? "pan-" + direction + (Observer2.isTouch ? " pinch-zoom" : "") : "none";
    }
    target === _docEl2 && _allowNativePanning2(_body2, direction);
  };
  var _overflow = {
    auto: 1,
    scroll: 1
  };
  var _nestedScroll = function _nestedScroll2(_ref5) {
    var event = _ref5.event, target = _ref5.target, axis = _ref5.axis;
    var node = (event.changedTouches ? event.changedTouches[0] : event).target, cache = node._gsap || gsap3.core.getCache(node), time = _getTime2(), cs;
    if (!cache._isScrollT || time - cache._isScrollT > 2e3) {
      while (node && node !== _body2 && (node.scrollHeight <= node.clientHeight && node.scrollWidth <= node.clientWidth || !(_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]))) {
        node = node.parentNode;
      }
      cache._isScroll = node && node !== target && !_isViewport3(node) && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]);
      cache._isScrollT = time;
    }
    if (cache._isScroll || axis === "x") {
      event.stopPropagation();
      event._gsapAllow = true;
    }
  };
  var _inputObserver = function _inputObserver2(target, type, inputs, nested) {
    return Observer2.create({
      target,
      capture: true,
      debounce: false,
      lockAxis: true,
      type,
      onWheel: nested = nested && _nestedScroll,
      onPress: nested,
      onDrag: nested,
      onScroll: nested,
      onEnable: function onEnable() {
        return inputs && _addListener3(_doc4, Observer2.eventTypes[0], _captureInputs, false, true);
      },
      onDisable: function onDisable() {
        return _removeListener3(_doc4, Observer2.eventTypes[0], _captureInputs, true);
      }
    });
  };
  var _inputExp = /(input|label|select|textarea)/i;
  var _inputIsFocused;
  var _captureInputs = function _captureInputs2(e) {
    var isInput = _inputExp.test(e.target.tagName);
    if (isInput || _inputIsFocused) {
      e._gsapAllow = true;
      _inputIsFocused = isInput;
    }
  };
  var _getScrollNormalizer = function _getScrollNormalizer2(vars) {
    _isObject3(vars) || (vars = {});
    vars.preventDefault = vars.isNormalizer = vars.allowClicks = true;
    vars.type || (vars.type = "wheel,touch");
    vars.debounce = !!vars.debounce;
    vars.id = vars.id || "normalizer";
    var _vars2 = vars, normalizeScrollX = _vars2.normalizeScrollX, momentum = _vars2.momentum, allowNestedScroll = _vars2.allowNestedScroll, onRelease = _vars2.onRelease, self, maxY, target = _getTarget(vars.target) || _docEl2, smoother = gsap3.core.globals().ScrollSmoother, smootherInstance = smoother && smoother.get(), content = _fixIOSBug && (vars.content && _getTarget(vars.content) || smootherInstance && vars.content !== false && !smootherInstance.smooth() && smootherInstance.content()), scrollFuncY = _getScrollFunc(target, _vertical), scrollFuncX = _getScrollFunc(target, _horizontal), scale = 1, initialScale = (Observer2.isTouch && _win4.visualViewport ? _win4.visualViewport.scale * _win4.visualViewport.width : _win4.outerWidth) / _win4.innerWidth, wheelRefresh = 0, resolveMomentumDuration = _isFunction3(momentum) ? function() {
      return momentum(self);
    } : function() {
      return momentum || 2.8;
    }, lastRefreshID, skipTouchMove, inputObserver = _inputObserver(target, vars.type, true, allowNestedScroll), resumeTouchMove = function resumeTouchMove2() {
      return skipTouchMove = false;
    }, scrollClampX = _passThrough3, scrollClampY = _passThrough3, updateClamps = function updateClamps2() {
      maxY = _maxScroll(target, _vertical);
      scrollClampY = _clamp4(_fixIOSBug ? 1 : 0, maxY);
      normalizeScrollX && (scrollClampX = _clamp4(0, _maxScroll(target, _horizontal)));
      lastRefreshID = _refreshID;
    }, removeContentOffset = function removeContentOffset2() {
      content._gsap.y = _round3(parseFloat(content._gsap.y) + scrollFuncY.offset) + "px";
      content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(content._gsap.y) + ", 0, 1)";
      scrollFuncY.offset = scrollFuncY.cacheID = 0;
    }, ignoreDrag = function ignoreDrag2() {
      if (skipTouchMove) {
        requestAnimationFrame(resumeTouchMove);
        var offset = _round3(self.deltaY / 2), scroll = scrollClampY(scrollFuncY.v - offset);
        if (content && scroll !== scrollFuncY.v + scrollFuncY.offset) {
          scrollFuncY.offset = scroll - scrollFuncY.v;
          var y = _round3((parseFloat(content && content._gsap.y) || 0) - scrollFuncY.offset);
          content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + y + ", 0, 1)";
          content._gsap.y = y + "px";
          scrollFuncY.cacheID = _scrollers.cache;
          _updateAll();
        }
        return true;
      }
      scrollFuncY.offset && removeContentOffset();
      skipTouchMove = true;
    }, tween, startScrollX, startScrollY, onStopDelayedCall, onResize = function onResize2() {
      updateClamps();
      if (tween.isActive() && tween.vars.scrollY > maxY) {
        scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo("scrollY", maxY);
      }
    };
    content && gsap3.set(content, {
      y: "+=0"
    });
    vars.ignoreCheck = function(e) {
      return _fixIOSBug && e.type === "touchmove" && ignoreDrag(e) || scale > 1.05 && e.type !== "touchstart" || self.isGesturing || e.touches && e.touches.length > 1;
    };
    vars.onPress = function() {
      skipTouchMove = false;
      var prevScale = scale;
      scale = _round3((_win4.visualViewport && _win4.visualViewport.scale || 1) / initialScale);
      tween.pause();
      prevScale !== scale && _allowNativePanning(target, scale > 1.01 ? true : normalizeScrollX ? false : "x");
      startScrollX = scrollFuncX();
      startScrollY = scrollFuncY();
      updateClamps();
      lastRefreshID = _refreshID;
    };
    vars.onRelease = vars.onGestureStart = function(self2, wasDragging) {
      scrollFuncY.offset && removeContentOffset();
      if (!wasDragging) {
        onStopDelayedCall.restart(true);
      } else {
        _scrollers.cache++;
        var dur = resolveMomentumDuration(), currentScroll, endScroll;
        if (normalizeScrollX) {
          currentScroll = scrollFuncX();
          endScroll = currentScroll + dur * 0.05 * -self2.velocityX / 0.227;
          dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _horizontal));
          tween.vars.scrollX = scrollClampX(endScroll);
        }
        currentScroll = scrollFuncY();
        endScroll = currentScroll + dur * 0.05 * -self2.velocityY / 0.227;
        dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _vertical));
        tween.vars.scrollY = scrollClampY(endScroll);
        tween.invalidate().duration(dur).play(0.01);
        if (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) {
          gsap3.to({}, {
            onUpdate: onResize,
            duration: dur
          });
        }
      }
      onRelease && onRelease(self2);
    };
    vars.onWheel = function() {
      tween._ts && tween.pause();
      if (_getTime2() - wheelRefresh > 1e3) {
        lastRefreshID = 0;
        wheelRefresh = _getTime2();
      }
    };
    vars.onChange = function(self2, dx, dy, xArray, yArray) {
      _refreshID !== lastRefreshID && updateClamps();
      dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX + (self2.startX - self2.x) : scrollFuncX() + dx - xArray[1]));
      if (dy) {
        scrollFuncY.offset && removeContentOffset();
        var isTouch = yArray[2] === dy, y = isTouch ? startScrollY + self2.startY - self2.y : scrollFuncY() + dy - yArray[1], yClamped = scrollClampY(y);
        isTouch && y !== yClamped && (startScrollY += yClamped - y);
        scrollFuncY(yClamped);
      }
      (dy || dx) && _updateAll();
    };
    vars.onEnable = function() {
      _allowNativePanning(target, normalizeScrollX ? false : "x");
      ScrollTrigger2.addEventListener("refresh", onResize);
      _addListener3(_win4, "resize", onResize);
      if (scrollFuncY.smooth) {
        scrollFuncY.target.style.scrollBehavior = "auto";
        scrollFuncY.smooth = scrollFuncX.smooth = false;
      }
      inputObserver.enable();
    };
    vars.onDisable = function() {
      _allowNativePanning(target, true);
      _removeListener3(_win4, "resize", onResize);
      ScrollTrigger2.removeEventListener("refresh", onResize);
      inputObserver.kill();
    };
    vars.lockAxis = vars.lockAxis !== false;
    self = new Observer2(vars);
    self.iOS = _fixIOSBug;
    _fixIOSBug && !scrollFuncY() && scrollFuncY(1);
    _fixIOSBug && gsap3.ticker.add(_passThrough3);
    onStopDelayedCall = self._dc;
    tween = gsap3.to(self, {
      ease: "power4",
      paused: true,
      inherit: false,
      scrollX: normalizeScrollX ? "+=0.1" : "+=0",
      scrollY: "+=0.1",
      modifiers: {
        scrollY: _interruptionTracker(scrollFuncY, scrollFuncY(), function() {
          return tween.pause();
        })
      },
      onUpdate: _updateAll,
      onComplete: onStopDelayedCall.vars.onComplete
    });
    return self;
  };
  ScrollTrigger2.sort = function(func) {
    if (_isFunction3(func)) {
      return _triggers.sort(func);
    }
    var scroll = _win4.pageYOffset || 0;
    ScrollTrigger2.getAll().forEach(function(t) {
      return t._sortY = t.trigger ? scroll + t.trigger.getBoundingClientRect().top : t.start + _win4.innerHeight;
    });
    return _triggers.sort(func || function(a, b) {
      return (a.vars.refreshPriority || 0) * -1e6 + (a.vars.containerAnimation ? 1e6 : a._sortY) - ((b.vars.containerAnimation ? 1e6 : b._sortY) + (b.vars.refreshPriority || 0) * -1e6);
    });
  };
  ScrollTrigger2.observe = function(vars) {
    return new Observer2(vars);
  };
  ScrollTrigger2.normalizeScroll = function(vars) {
    if (typeof vars === "undefined") {
      return _normalizer2;
    }
    if (vars === true && _normalizer2) {
      return _normalizer2.enable();
    }
    if (vars === false) {
      _normalizer2 && _normalizer2.kill();
      _normalizer2 = vars;
      return;
    }
    var normalizer = vars instanceof Observer2 ? vars : _getScrollNormalizer(vars);
    _normalizer2 && _normalizer2.target === normalizer.target && _normalizer2.kill();
    _isViewport3(normalizer.target) && (_normalizer2 = normalizer);
    return normalizer;
  };
  ScrollTrigger2.core = {
    // smaller file size way to leverage in ScrollSmoother and Observer
    _getVelocityProp,
    _inputObserver,
    _scrollers,
    _proxies,
    bridge: {
      // when normalizeScroll sets the scroll position (ss = setScroll)
      ss: function ss() {
        _lastScrollTime || _dispatch3("scrollStart");
        _lastScrollTime = _getTime2();
      },
      // a way to get the _refreshing value in Observer
      ref: function ref() {
        return _refreshing;
      }
    }
  };
  _getGSAP3() && gsap3.registerPlugin(ScrollTrigger2);

  // node_modules/gsap/ScrollToPlugin.js
  var gsap4;
  var _coreInitted4;
  var _window;
  var _docEl3;
  var _body3;
  var _toArray2;
  var _config2;
  var ScrollTrigger3;
  var _windowExists7 = function _windowExists8() {
    return typeof window !== "undefined";
  };
  var _getGSAP5 = function _getGSAP6() {
    return gsap4 || _windowExists7() && (gsap4 = window.gsap) && gsap4.registerPlugin && gsap4;
  };
  var _isString5 = function _isString6(value) {
    return typeof value === "string";
  };
  var _isFunction5 = function _isFunction6(value) {
    return typeof value === "function";
  };
  var _max = function _max2(element, axis) {
    var dim = axis === "x" ? "Width" : "Height", scroll = "scroll" + dim, client = "client" + dim;
    return element === _window || element === _docEl3 || element === _body3 ? Math.max(_docEl3[scroll], _body3[scroll]) - (_window["inner" + dim] || _docEl3[client] || _body3[client]) : element[scroll] - element["offset" + dim];
  };
  var _buildGetter = function _buildGetter2(e, axis) {
    var p = "scroll" + (axis === "x" ? "Left" : "Top");
    if (e === _window) {
      if (e.pageXOffset != null) {
        p = "page" + axis.toUpperCase() + "Offset";
      } else {
        e = _docEl3[p] != null ? _docEl3 : _body3;
      }
    }
    return function() {
      return e[p];
    };
  };
  var _clean = function _clean2(value, index, target, targets) {
    _isFunction5(value) && (value = value(index, target, targets));
    if (typeof value !== "object") {
      return _isString5(value) && value !== "max" && value.charAt(1) !== "=" ? {
        x: value,
        y: value
      } : {
        y: value
      };
    } else if (value.nodeType) {
      return {
        y: value,
        x: value
      };
    } else {
      var result = {}, p;
      for (p in value) {
        result[p] = p !== "onAutoKill" && _isFunction5(value[p]) ? value[p](index, target, targets) : value[p];
      }
      return result;
    }
  };
  var _getOffset = function _getOffset2(element, container) {
    element = _toArray2(element)[0];
    if (!element || !element.getBoundingClientRect) {
      return console.warn("scrollTo target doesn't exist. Using 0") || {
        x: 0,
        y: 0
      };
    }
    var rect = element.getBoundingClientRect(), isRoot = !container || container === _window || container === _body3, cRect = isRoot ? {
      top: _docEl3.clientTop - (_window.pageYOffset || _docEl3.scrollTop || _body3.scrollTop || 0),
      left: _docEl3.clientLeft - (_window.pageXOffset || _docEl3.scrollLeft || _body3.scrollLeft || 0)
    } : container.getBoundingClientRect(), offsets = {
      x: rect.left - cRect.left,
      y: rect.top - cRect.top
    };
    if (!isRoot && container) {
      offsets.x += _buildGetter(container, "x")();
      offsets.y += _buildGetter(container, "y")();
    }
    return offsets;
  };
  var _parseVal = function _parseVal2(value, target, axis, currentVal, offset) {
    return !isNaN(value) && typeof value !== "object" ? parseFloat(value) - offset : _isString5(value) && value.charAt(1) === "=" ? parseFloat(value.substr(2)) * (value.charAt(0) === "-" ? -1 : 1) + currentVal - offset : value === "max" ? _max(target, axis) - offset : Math.min(_max(target, axis), _getOffset(value, target)[axis] - offset);
  };
  var _initCore5 = function _initCore6() {
    gsap4 = _getGSAP5();
    if (_windowExists7() && gsap4 && typeof document !== "undefined" && document.body) {
      _window = window;
      _body3 = document.body;
      _docEl3 = document.documentElement;
      _toArray2 = gsap4.utils.toArray;
      gsap4.config({
        autoKillThreshold: 7
      });
      _config2 = gsap4.config();
      _coreInitted4 = 1;
    }
  };
  var ScrollToPlugin = {
    version: "3.12.7",
    name: "scrollTo",
    rawVars: 1,
    register: function register(core) {
      gsap4 = core;
      _initCore5();
    },
    init: function init4(target, value, tween, index, targets) {
      _coreInitted4 || _initCore5();
      var data = this, snapType = gsap4.getProperty(target, "scrollSnapType");
      data.isWin = target === _window;
      data.target = target;
      data.tween = tween;
      value = _clean(value, index, target, targets);
      data.vars = value;
      data.autoKill = !!("autoKill" in value ? value : _config2).autoKill;
      data.getX = _buildGetter(target, "x");
      data.getY = _buildGetter(target, "y");
      data.x = data.xPrev = data.getX();
      data.y = data.yPrev = data.getY();
      ScrollTrigger3 || (ScrollTrigger3 = gsap4.core.globals().ScrollTrigger);
      gsap4.getProperty(target, "scrollBehavior") === "smooth" && gsap4.set(target, {
        scrollBehavior: "auto"
      });
      if (snapType && snapType !== "none") {
        data.snap = 1;
        data.snapInline = target.style.scrollSnapType;
        target.style.scrollSnapType = "none";
      }
      if (value.x != null) {
        data.add(data, "x", data.x, _parseVal(value.x, target, "x", data.x, value.offsetX || 0), index, targets);
        data._props.push("scrollTo_x");
      } else {
        data.skipX = 1;
      }
      if (value.y != null) {
        data.add(data, "y", data.y, _parseVal(value.y, target, "y", data.y, value.offsetY || 0), index, targets);
        data._props.push("scrollTo_y");
      } else {
        data.skipY = 1;
      }
    },
    render: function render3(ratio, data) {
      var pt = data._pt, target = data.target, tween = data.tween, autoKill = data.autoKill, xPrev = data.xPrev, yPrev = data.yPrev, isWin = data.isWin, snap3 = data.snap, snapInline = data.snapInline, x, y, yDif, xDif, threshold;
      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
      x = isWin || !data.skipX ? data.getX() : xPrev;
      y = isWin || !data.skipY ? data.getY() : yPrev;
      yDif = y - yPrev;
      xDif = x - xPrev;
      threshold = _config2.autoKillThreshold;
      if (data.x < 0) {
        data.x = 0;
      }
      if (data.y < 0) {
        data.y = 0;
      }
      if (autoKill) {
        if (!data.skipX && (xDif > threshold || xDif < -threshold) && x < _max(target, "x")) {
          data.skipX = 1;
        }
        if (!data.skipY && (yDif > threshold || yDif < -threshold) && y < _max(target, "y")) {
          data.skipY = 1;
        }
        if (data.skipX && data.skipY) {
          tween.kill();
          data.vars.onAutoKill && data.vars.onAutoKill.apply(tween, data.vars.onAutoKillParams || []);
        }
      }
      if (isWin) {
        _window.scrollTo(!data.skipX ? data.x : x, !data.skipY ? data.y : y);
      } else {
        data.skipY || (target.scrollTop = data.y);
        data.skipX || (target.scrollLeft = data.x);
      }
      if (snap3 && (ratio === 1 || ratio === 0)) {
        y = target.scrollTop;
        x = target.scrollLeft;
        snapInline ? target.style.scrollSnapType = snapInline : target.style.removeProperty("scroll-snap-type");
        target.scrollTop = y + 1;
        target.scrollLeft = x + 1;
        target.scrollTop = y;
        target.scrollLeft = x;
      }
      data.xPrev = data.x;
      data.yPrev = data.y;
      ScrollTrigger3 && ScrollTrigger3.update();
    },
    kill: function kill(property) {
      var both = property === "scrollTo", i = this._props.indexOf(property);
      if (both || property === "scrollTo_x") {
        this.skipX = 1;
      }
      if (both || property === "scrollTo_y") {
        this.skipY = 1;
      }
      i > -1 && this._props.splice(i, 1);
      return !this._props.length;
    }
  };
  ScrollToPlugin.max = _max;
  ScrollToPlugin.getOffset = _getOffset;
  ScrollToPlugin.buildGetter = _buildGetter;
  ScrollToPlugin.config = function(vars) {
    _config2 || _initCore5() || (_config2 = gsap4.config());
    for (var p in vars) {
      _config2[p] = vars[p];
    }
  };
  _getGSAP5() && gsap4.registerPlugin(ScrollToPlugin);

  // src/assets/javascripts/index.ts
  gsapWithCSS.registerPlugin(ScrollTrigger2, ScrollToPlugin);
  document.documentElement.classList.remove("no-js");
  document.documentElement.classList.add("js");
  var customWindow5 = window;
  var { document$: document$4 } = customWindow5;
  HeroStore.getInstance();
  var insertAnalytics = () => {
    try {
      createScript(
        "https://app.tinyanalytics.io/pixel/ei74pg7dZSNOtFvI",
        false,
        // async must be false
        true,
        // defer can be true
        true
      );
    } catch (e) {
      console.warn("Analytics failed to load:", e);
    }
  };
  var insertButtonScript = () => createScript("https://buttons.github.io/buttons.js", true, true);
  var onDom$ = (obs) => {
    return document$4.pipe(switchMap(() => obs));
  };
  var analytic$ = onDom$(of(insertAnalytics()));
  var feedback$ = onDom$(of(feedback()));
  var buttonScript$ = onDom$(of(insertButtonScript()));
  var color$ = of(document.body.setAttribute("data-md-color-scheme", "slate"));
  var observer$4 = of(HeroObservation.getInstance());
  var videoManager$ = of(VideoManager.getInstance());
  var licenseHashHandler$ = onDom$(watchLicenseHash());
  var license$ = navigationEvents$.pipe(filter(isLicense), switchMap(() => initLicenseFeature()));
  var windowEvents$ = from(windowEvents());
  var pageConfigs = [
    {
      matcher: isHome,
      location: "home",
      observables: [color$, observer$4, videoManager$]
    },
    {
      matcher: isLicense,
      location: "licenses",
      observables: [license$]
    },
    {
      matcher: isHelpingIndex,
      location: "helpingIndex",
      observables: [buttonScript$]
    },
    {
      matcher: isOnSite,
      location: "all",
      observables: [analytic$, feedback$, licenseHashHandler$, windowEvents$]
    }
  ];
  var pageSubscription$ = navigationEvents$.pipe(map((url2) => {
    const matchingConfigs = pageConfigs.filter((config6) => config6.matcher(url2));
    if (matchingConfigs.length === 0) {
      return null;
    }
    matchingConfigs.forEach((config6) => logger.info(`Navigated to ${config6.location}`));
    return matchingConfigs;
  }), filter((configs) => configs !== null), switchMap((configs) => {
    const allObservables = configs.flatMap((config6) => config6.observables.map((obs) => obs.pipe(tap(() => logger.info(`Running observables for ${config6.location}`)), catchError((error) => {
      logger.error(`Error in ${config6.location} observables:`, error);
      return EMPTY;
    }))));
    return merge(...allObservables);
  }), share());
  pageSubscription$.subscribe();
})();
/**
 * @module config
 * @description Main configuration file for the application; you should set up any changes to the application here.
 *
 *
 * @license Plain-Unlicense
 * @author Adam Poulemanos adam<at>plainlicense<dot>org
 */
/**
 * @module config/types
 * @description Types for configuration objects
 *
 * @license Plain-Unlicense (Public Domain)
 * @author Adam Poulemanos adam<at>plainlicense<dot>org
 * @copyright No rights reserved
 */
/**
 * @module utilities/conditionChecks
 * @description Utility functions for checking conditions
 *
 * @license Plain-Unlicense
 * @copyright No rights reserved.
 */
/**
 * @module log
 * @description A simple logger for development purposes.
 * Only logs to the console in development.
 *
 * @copyright No rights reserved. Created by and for Plain License www.plainlicense.org
 * @license Plain Unlicense (Public Domain)
 */
/**
 * @module utils/helpers
 * @description General purpose utility functions
 *
 * @license Plain-Unlicense (Public Domain)
 * @author Adam Poulemanos adam<at>plainlicense<.>org
 * @copyright No rights reserved.
 */
/**
 * @module EventHandlers
 * @description Reactive event handling and observation utilities
 *
 * @overview
 * Provides event management and observation capabilities using RxJS,
 * covering navigation, viewport, media queries, visibility, and custom browser interactions.
 *
 * Key Features:
 * - Reactive navigation event streams
 * - Viewport and scroll monitoring
 * - Media query and visibility tracking
 * - Cross-browser event normalization
 * - Custom event handling for specific interactions
 *
 * @see {@link https://rxjs.dev/} RxJS Documentation
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Navigation_API} Navigation API
 * @license Plain-Unlicense (Public Domain)
 * @copyright No rights reserved.
 */
/**
 * @module feedback
 * @description Handles feedback form submission
 * @license Plain Unlicense(Public Domain)
 * @copyright No rights reserved. Created by and for Plain License www.plainlicense.org
 */
/**
 * @module TabManager
 *
 * @description Coordinates tab interactions with corresponding link icons and labels
 *
 * @license Plain-Unlicense (Public Domain)
 * @author Adam Poulemanos adam<at>plainlicense<dot>org
 * @copyright No rights reserved
 */
/**
 * @module types (licenses)
 * @description Types for the licenses feature.
 *
 * @license Plain-Unlicense (Public Domain)
 * @author Adam Poulemanos adam<at>plainlicense<dot>org
 * @copyright No rights reserved.
 */
/**
 * @module features/licenses
 *
 * @description License feature initialization.
 *
 * @license Plain-Unlicense (Public Domain)
 * @author Adam Poulemanos adam<at>plainlicense<dot>org
 * @copyright No rights reserved.
 */
/**
 * @module predicates
 * @description A collection of state predicates for HeroState and its sub-states. This
 * probably looks sad; it's a remnant of a much more complicated state system. Here
 * until the next refactor.
 *
 * @license Plain-Unlicense
 * @author Adam Poulemanos adam<at>plainlicense<dot>org
 * @copyright No rights reserved
 */
/**
 * @module store
 * @description Centralized state management for hero section with reactive state updates
 *
 * Implements a singleton reactive store for managing complex UI state using RxJS,
 * with advanced state tracking, predicate-based logic, and performance optimizations.
 *
 * Frankly, it's overkill, but it was designed for a complex UI with many moving parts... and then I changed the design to be simpler... so now it's overkill.
 * But it works, so I'm leaving it in place.
 *
 * @license Plain-Unlicense (Public Domain)
 * @author Adam Poulemanos adam<at>plainlicense<dot>org
 * @copyright No rights reserved
 */
/**
 * @module animations/utils
 * @description Utility functions for animations
 *
 * @license Plain-Unlicense (Public Domain)
 * @author Adam Poulemanos adam<at>plainlicense<.>org
 * @copyright No rights reserved.
 */
/**
 * @module observerEffects
 * @description Creates and registers gsap effects for observer-based animations.
 *
 * USAGE:
 * The effects register to the global gsap object, and can be used in timelines or tweens as if it were a 'gsap.to' or 'gsap.fromTo' effect.
 * For example, for the 'fadeIn' effect: gsap.fadeIn(targets, config)
 *
 ** Effects:
 **  - setSection: Sets the specified section up for a transition.
 **  - transitionSection: Transitions the specified section.
 **  - fadeIn: Fades in the specified targets with a y-axis movement.
 **  - fadeOut: Fades out the specified targets with a y-axis movement.
 **  - emphasize: Blinks, jumps, and scales up the specified targets.
 *
 * @author Adam Poulemanos adam<at>plainlicense<dot>org
 * @license Plain-Unlicense (Public Domain)
 * @copyright No rights reserved.
 *
 */
/**
 * @module observer
 * @description HeroObservation class for the Hero feature. Creates GSAP Observers that handle the slide-show style animations.
 *
 * @license Plain-Unlicense (Public Domain)
 * @author Adam Poulemanos adam<at>plainlicense<dot>org
 * @see {@link https://codepen.io/GreenSock/pen/XWzRraJ} GSAP Hero Observers Example
 * @see {@link https://gsap.com/docs/v3/Plugins/Observer/} GSAP Observer Documentation
 */
/**
 * @module VideoElement
 * @description constructs a video element with sources and properties, and a corresponding picture element to be used as a poster
 * @license Plain-Unlicense (Public Domain)
 * @author Adam Poulemanos adam<at>plainlicense<dot>org
 * @copyright No rights reserved
 */
/**
 * ========================================================================
 * *                          PLAIN LICENSE ENTRYPOINT
 *
 * Entrypoint for Plain License's added script bundle.
 * Supplements Material for MkDocs with site-specific scripts.
 * @module index
 * @license Plain Unlicense (Public Domain)
 *
 * Handles:
 * - Imports Material for MkDocs bundle and ensures global observables stay available
 * - Caching/preloading of static assets
 * - Subscriptions to page-specific observables
 *========================================================================*
 */
/*! Bundled license information:

escape-html/index.js:
  (*!
   * escape-html
   * Copyright(c) 2012-2013 TJ Holowaychuk
   * Copyright(c) 2015 Andreas Lubbe
   * Copyright(c) 2015 Tiancheng "Timothy" Gu
   * MIT Licensed
   *)

clipboard/dist/clipboard.js:
  (*!
   * clipboard.js v2.0.11
   * https://clipboardjs.com/
   *
   * Licensed MIT  Zeno Rocha
   *)

gsap/gsap-core.js:
  (*!
   * GSAP 3.12.7
   * https://gsap.com
   *
   * @license Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/CSSPlugin.js:
  (*!
   * CSSPlugin 3.12.7
   * https://gsap.com
   *
   * Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/Observer.js:
  (*!
   * Observer 3.12.7
   * https://gsap.com
   *
   * @license Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/ScrollTrigger.js:
  (*!
   * ScrollTrigger 3.12.7
   * https://gsap.com
   *
   * @license Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/ScrollToPlugin.js:
  (*!
   * ScrollToPlugin 3.12.7
   * https://gsap.com
   *
   * @license Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)
*/
//# sourceMappingURL=index.4YPKFWJJ.js.map
