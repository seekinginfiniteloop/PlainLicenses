{
  "version": 3,
  "sources": ["../../../../src/assets/javascripts/workers/cache_worker.ts"],
  "sourcesContent": ["/**\n * Cache worker for precaching and caching strategies\n * @module cache_worker\n *\n * @license Plain-Unlicense\n * @author Adam Poulemanos <adam<at>plainlicense<dot>org>\n * @copyright No rights reserved.\n */\nexport type {};\ndeclare const self: ServiceWorkerGlobalScope;\n// Configuration types\ninterface CacheConfig {\n    cacheName: string;\n    urls: string[];\n    version: string;\n}\ninterface CacheMetadata {\n    cacheName: string;\n    version: string;\n    [key: string]: string;\n}\n/** ======================\n *    Custom Errors\n *========================**/\n// represents Cache errors\nclass CacheError extends Error {\n    constructor(message: string, public readonly cause?: Error) {\n        super(message);\n        this.name = \"CacheError\";\n        // Set the cause on the error object for error chaining\n        if (cause && \"cause\" in Error) {\n            Object.defineProperty(this, \"cause\", {\n                value: cause,\n                configurable: true,\n                writable: true,\n            });\n        }\n    }\n    toString(): string {\n        return this.cause ? `${this.message}\\nCaused by: ${this.cause.toString()}` : this.message;\n    }\n}\n// represents network errors\nclass NetworkError extends Error {\n    constructor(message: string, public readonly status?: number) {\n        super(message);\n        this.name = \"NetworkError\";\n        // Include the status in the error message if available\n        if (status) {\n            this.message = `${message} (HTTP ${status})`;\n        }\n    }\n}\n// Cache configuration with versioning\nconst DEFAULT_CONFIG: CacheConfig = {\n    cacheName: \"plain-license-v1\",\n    urls: [],\n    version: \"1.0.0\",\n};\n/**\n * Get the hash from a file path\n * @param s string - file path\n * @returns string | null\n */\nconst get_hash = (s: string): string | null => {\n    try {\n        const split = s.split(\"/\")[s.split(\"/\").length - 1].split(\".\");\n        if (split.length >= 3) {\n            return split[split.length - 2];\n        }\n        else {\n            return null;\n        }\n    }\n    catch (_error) {\n        logger.error(\"Failed to get hash from string:\", _error as Error);\n        return null;\n    }\n};\n/**\n * Check if we're in development mode\n * @returns boolean\n */\nconst isDev = (): boolean => {\n    const { origin, hostname, port } = self.location;\n    return (hostname === \"localhost\" ||\n        hostname === \"127.0.0.1\" ||\n        port === \"8000\" ||\n        origin.includes(\"localhost\"));\n};\n// simple logger utility; only logs in development\nconst logger = {\n    error: (message: string, error?: Error) => {\n        if (isDev()) {\n            if (error instanceof CacheError) {\n                console.error(`[ServiceWorker] Cache Error: ${message}`);\n                console.error(error.toString());\n            }\n            else if (error instanceof NetworkError) {\n                console.error(`[ServiceWorker] Network Error: ${message}`);\n                console.error(`Status: ${error.status || \"unknown\"}`);\n                console.error(error.message);\n            }\n            else if (error) {\n                console.error(`[ServiceWorker] ${message}`);\n                console.error(error);\n            }\n        }\n        // In production, you might want to send errors to your logging service\n    },\n    info: (message: string) => {\n        if (isDev()) {\n            console.info(`[ServiceWorker] ${message}`);\n        }\n    },\n};\n/**\n * Retrieve cache configuration from meta.json\n * @returns Promise<CacheConfig>\n */\nasync function retrieveCacheConfig(): Promise<CacheConfig> {\n    try {\n        const response = await fetch(\"meta.json\");\n        if (!response.ok) {\n            throw new NetworkError(\"Failed to fetch meta.json\", response.status);\n        }\n        const meta: CacheMetadata = await response.json();\n        return {\n            cacheName: meta.cacheName ?? DEFAULT_CONFIG.cacheName,\n            version: meta.version ?? DEFAULT_CONFIG.version,\n            urls: Object.entries(meta)\n                .filter(([key]) => ![\"cacheName\", \"version\"].includes(key))\n                .map(([, value]) => value as string),\n        };\n    }\n    catch (error) {\n        logger.error(\"Failed to retrieve cache config:\", error as Error);\n        return DEFAULT_CONFIG;\n    }\n}\n/**\n * Cache manager for managing cache operations\n *\n * @method init - Initialize cache configuration\n * @method cleanup - Cleanup old caches\n * @method precache - Precache all the urls in the cache configuration\n */\nclass CacheManager {\n    private config: CacheConfig = DEFAULT_CONFIG;\n    constructor() {\n        this.init();\n    }\n    // gets the cache configuration\n    async init(): Promise<void> {\n        try {\n            this.config = await retrieveCacheConfig();\n            logger.info(\"Cache configuration retrieved\");\n        }\n        catch (error) {\n            logger.error(\"Failed to retrieve cache configuration:\", error as Error);\n            this.config = DEFAULT_CONFIG;\n        }\n    }\n    /**\n     * Cleanup old caches\n     */\n    async cleanup(): Promise<void> {\n        try {\n            const cacheKeys = await caches.keys();\n            const deletionPromises = cacheKeys\n                .filter((key) => key !== this.config.cacheName)\n                .map((key) => caches.delete(key));\n            await Promise.all(deletionPromises);\n            logger.info(\"Old caches cleaned up\");\n        }\n        catch (error) {\n            throw new CacheError(\"Failed to cleanup caches\", error as Error);\n        }\n    }\n    /**\n     * Precache all the urls in the cache configuration\n     */\n    async precache(): Promise<void> {\n        try {\n            const cache = await caches.open(this.config.cacheName);\n            await cache.addAll(this.config.urls);\n            logger.info(\"Precaching complete\");\n        }\n        catch (error) {\n            throw new CacheError(\"Failed to precache urls\", error as Error);\n        }\n    }\n    /**\n     * Attempt to fetch a resource\n     * @param request Request | string | URL - request to fetch\n     * @param init RequestInit - request options\n     * @returns Promise<Response> - response\n     */\n    private async tryFetch(request: Request | string | URL, init?: RequestInit): Promise<Response> {\n        try {\n            const response = await fetch(request, init);\n            if (!response.ok) {\n                throw new NetworkError(\"Network response was not ok\", response.status);\n            }\n            return response;\n        }\n        catch (error) {\n            logger.error(\"Failed to fetch:\", error as Error);\n            throw new NetworkError(`Failed to fetch request for ${request.toString()}`, 500);\n        }\n    }\n    /**\n     * Fallback fetch for failed fetches. Attempts to remove the hash from the url and fetch again\n     * @param request Request | string | URL - request to fetch\n     * @param init RequestInit - request options\n     * @returns Promise<Response> - response\n     */\n    async fallbackFetch(request: Request | string | URL, init?: RequestInit): Promise<Response> {\n        const response = await fetch(request, init);\n        if (response.ok) {\n            return response;\n        }\n        else {\n            const errorMessage = response instanceof Response ? await response.json() : \"No response\";\n            logger.error(\"Failed to fetch:\", new Error(errorMessage));\n            logger.error(\"Attempting fallback fetch\");\n            const url = request instanceof URL ? request\n                : request instanceof Request ? new URL(request.url)\n                    : new URL(request);\n            const hash = get_hash(url.pathname);\n            if (!hash) {\n                const file = url.pathname.split(\"/\")[-1];\n                const parts = file.split(\".\");\n                const name = parts[0];\n                const ext = parts[parts.length - 1];\n                const hashlessUrl = new RegExp(`${name}\\.[a-fA-F0-9]{8}\\.${ext}`);\n                const inConfig = this.config.urls.find((u) => hashlessUrl.test(u));\n                if (inConfig) {\n                    return this.tryFetch(inConfig, init);\n                }\n            }\n            return this.tryFetch(url.pathname.replace(`.${hash}`, \"\"), init);\n        }\n    }\n}\n// Initialize cache manager\nconst cacheManager = new CacheManager();\n/**\n * Cache strategies for fetching resources\n * @method @static cacheFirst\n * @method @static staleWhileRevalidate\n */\nclass CacheStrategies {\n    /**\n     * Cache first strategy\n     * @param request Request\n     * @returns Promise<Response>\n     */\n    static async cacheFirst(request: Request): Promise<Response> {\n        const cached = await caches.match(request);\n        if (cached) {\n            return cached;\n        }\n        try {\n            const response = await cacheManager.fallbackFetch(request);\n            if (!response.ok) {\n                throw new NetworkError(\"Network response was not ok\", response.status);\n            }\n            const cache = await caches.open(DEFAULT_CONFIG.cacheName);\n            await cache.put(request, response.clone());\n            return response;\n        }\n        catch (error) {\n            logger.error(\"Cache first strategy failed:\", error as Error);\n            throw error;\n        }\n    }\n    /**\n     * Stale while revalidate strategy\n     * @param request Request\n     * @returns Promise<Response>\n     */\n    static async staleWhileRevalidate(request: Request): Promise<Response> {\n        const cache = await caches.open(DEFAULT_CONFIG.cacheName);\n        const cached = await cache.match(request);\n        const networkPromise = await cacheManager\n            .fallbackFetch(request)\n            .then((response) => {\n            if (!response.ok) {\n                throw new NetworkError(\"Network response was not ok\", response.status);\n            }\n            cache.put(request, response.clone());\n            return response;\n        })\n            .catch((error) => {\n            logger.error(\"Network fetch failed:\", error as Error);\n            throw error;\n        });\n        return cached ?? networkPromise;\n    }\n}\n// install the service worker\nself.addEventListener(\"install\", (event: ExtendableEvent) => {\n    event.waitUntil((async () => {\n        try {\n            await cacheManager.init();\n            await cacheManager.precache();\n            await self.skipWaiting();\n            logger.info(\"Service worker installed\");\n        }\n        catch (error) {\n            logger.error(\"Install failed:\", error as Error);\n            throw error;\n        }\n    })());\n});\n/**\n * Activate the service worker and cleanup old caches\n */\nself.addEventListener(\"activate\", (event: ExtendableEvent) => {\n    event.waitUntil((async () => {\n        try {\n            await cacheManager.cleanup();\n            await self.clients.claim();\n            logger.info(\"Service worker activated\");\n        }\n        catch (error) {\n            logger.error(\"Activation failed:\", error as Error);\n            throw error;\n        }\n    })());\n});\n/**\n * Fetch event listener for handling requests\n */\nself.addEventListener(\"fetch\", (event: FetchEvent) => {\n    if (event.request.method !== \"GET\") {\n        return;\n    }\n    const url = new URL(event.request.url);\n    if (!url.origin.startsWith(self.location.origin)) {\n        return;\n    }\n    // We use stale-while-revalidate for assets that can are more regularly updated\n    const isRefreshAsset = /\\.(js|css|html|json)$/i.test(url.pathname);\n    event.respondWith(isRefreshAsset ?\n        CacheStrategies.staleWhileRevalidate(event.request)\n        : CacheStrategies.cacheFirst(event.request));\n});\n"],
  "mappings": "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",
  "names": []
}
