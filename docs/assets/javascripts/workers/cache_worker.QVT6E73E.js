/**
 * ---DO NOT EDIT THIS FILE---
 * The build process generates this file
 * You should edit the source file instead
 *
 * sources are in: src/assets/javascripts directory
 */


// src/assets/javascripts/workers/cache_worker.ts
var CONFIG = {
  cacheName: "plain-license-v1",
  urls: [],
  version: Date.now(),
  worker: "",
  logo: ""
};
var CacheError = class extends Error {
  constructor(message, cause) {
    super(message);
    this.cause = cause;
    this.name = "CacheError";
    if (cause && "cause" in Error) {
      Object.defineProperty(this, "cause", {
        value: cause,
        configurable: true,
        writable: true
      });
    }
  }
  toString() {
    return this.cause ? `${this.message}
Caused by: ${this.cause.toString()}` : this.message;
  }
};
var NetworkError = class extends Error {
  constructor(message, status) {
    super(message);
    this.status = status;
    this.name = "NetworkError";
    if (status) {
      this.message = `${message} (HTTP ${status})`;
    }
  }
};
self.addEventListener("message", (event) => {
  const payload = event.data;
  if (payload.type === "CACHE_CONFIG" && payload.payload && Object.keys(payload.payload).length > 1) {
    CONFIG = { ...CONFIG, ...payload.payload };
  }
});
var get_hash = (s) => {
  try {
    const split = s.split("/")[s.split("/").length - 1].split(".");
    if (split.length >= 3) {
      return split[split.length - 2];
    } else {
      return null;
    }
  } catch (_error) {
    logger.error("Failed to get hash from string:", _error);
    return null;
  }
};
var isDev = () => {
  const { origin, hostname, port } = self.location;
  return hostname === "localhost" || hostname === "127.0.0.1" || port === "8000" || origin.includes("localhost");
};
var logger = {
  error: (message, error) => {
    if (isDev()) {
      if (error instanceof CacheError) {
        console.error(`[ServiceWorker] Cache Error: ${message}`);
        console.error(error.toString());
      } else if (error instanceof NetworkError) {
        console.error(`[ServiceWorker] Network Error: ${message}`);
        console.error(`Status: ${error.status || "unknown"}`);
        console.error(error.message);
      } else if (error) {
        console.error(`[ServiceWorker] ${message}`);
        console.error(error);
      }
    }
  },
  info: (message) => {
    if (isDev()) {
      console.info(`[ServiceWorker] ${message}`);
    }
  }
};
async function retrieveCacheConfig() {
  if (CONFIG.urls.length > 0) {
    return CONFIG;
  } else {
    try {
      const response = await fetch("meta.json");
      if (!response.ok) {
        throw new NetworkError("Failed to fetch meta.json", response.status);
      }
      const meta = await response.json();
      return {
        cacheName: meta.cacheName ?? CONFIG.cacheName,
        version: meta.version ?? CONFIG.version,
        urls: Object.entries(meta).filter(([key]) => !["cacheName", "version"].includes(key)).map(([, value]) => value),
        worker: meta["worker"] ?? "",
        logo: meta["logo"] ?? ""
      };
    } catch (error) {
      logger.error("Failed to retrieve cache config:", error);
      return CONFIG;
    }
  }
}
var CacheManager = class {
  constructor() {
    this.config = CONFIG;
    this.init();
  }
  // gets the cache configuration
  async init() {
    try {
      CONFIG = await retrieveCacheConfig();
      logger.info("Cache configuration retrieved");
    } catch (error) {
      logger.error("Failed to retrieve cache configuration:", error);
      this.config = CONFIG;
    }
  }
  /**
   * Cleanup old caches
   */
  async cleanup() {
    try {
      const cacheKeys = await caches.keys();
      const deletionPromises = cacheKeys.filter((key) => key !== this.config.cacheName).map((key) => caches.delete(key));
      await Promise.all(deletionPromises);
      logger.info("Old caches cleaned up");
    } catch (error) {
      throw new CacheError("Failed to cleanup caches", error);
    }
  }
  /**
   * Precache all the urls in the cache configuration
   */
  async precache() {
    try {
      const cache = await caches.open(this.config.cacheName);
      await cache.addAll(this.config.urls);
      logger.info("Precaching complete");
    } catch (error) {
      throw new CacheError("Failed to precache urls", error);
    }
  }
  /**
   * Attempt to fetch a resource
   * @param request Request | string | URL - request to fetch
   * @param init RequestInit - request options
   * @returns Promise<Response> - response
   */
  async tryFetch(request, init) {
    try {
      const response = await fetch(request, init);
      if (!response.ok) {
        throw new NetworkError("Network response was not ok", response.status);
      }
      return response;
    } catch (error) {
      logger.error("Failed to fetch:", error);
      throw new NetworkError(`Failed to fetch request for ${request.toString()}`, 500);
    }
  }
  /**
   * Fallback fetch for failed fetches. Attempts to remove the hash from the url and fetch again
   * @param request Request | string | URL - request to fetch
   * @param init RequestInit - request options
   * @returns Promise<Response> - response
   */
  async fallbackFetch(request, init) {
    const response = await fetch(request, init);
    if (response.ok) {
      return response;
    } else {
      const errorMessage = response instanceof Response ? await response.json() : "No response";
      logger.error("Failed to fetch:", new Error(errorMessage));
      logger.error("Attempting fallback fetch");
      const url = request instanceof URL ? request : request instanceof Request ? new URL(request.url) : new URL(request);
      const hash = get_hash(url.pathname);
      if (!hash) {
        const file = url.pathname.split("/")?.pop();
        const parts = file?.split(".");
        const name = parts?.slice(0, -1).join(".");
        const ext = parts?.slice(-1)[0];
        const hashlessUrl = new RegExp(`${name}.[a-fA-F0-9]{8}.${ext}`);
        const inConfig = this.config.urls.find((u) => hashlessUrl.test(u));
        if (inConfig) {
          return this.tryFetch(inConfig, init);
        }
      }
      return this.tryFetch(url.pathname.replace(`.${hash}`, ""), init);
    }
  }
};
var cacheManager = new CacheManager();
var CacheStrategies = class {
  /**
   * Cache first strategy
   * @param request Request
   * @returns Promise<Response>
   */
  static async cacheFirst(request) {
    const cached = await caches.match(request);
    if (cached) {
      return cached;
    }
    try {
      const response = await cacheManager.fallbackFetch(request);
      if (!response.ok) {
        throw new NetworkError("Network response was not ok", response.status);
      }
      const cache = await caches.open(CONFIG.cacheName);
      await cache.put(request, response.clone());
      return response;
    } catch (error) {
      logger.error("Cache first strategy failed:", error);
      throw error;
    }
  }
  /**
   * Stale while revalidate strategy
   * @param request Request
   * @returns Promise<Response>
   */
  static async staleWhileRevalidate(request) {
    const cache = await caches.open(CONFIG.cacheName);
    const cached = await cache.match(request);
    const networkPromise = await cacheManager.fallbackFetch(request).then((response) => {
      if (!response.ok) {
        throw new NetworkError("Network response was not ok", response.status);
      }
      cache.put(request, response.clone());
      return response;
    }).catch((error) => {
      logger.error("Network fetch failed:", error);
      throw error;
    });
    return cached ?? networkPromise;
  }
};
self.addEventListener("install", (event) => {
  event.waitUntil((async () => {
    try {
      await cacheManager.init();
      await cacheManager.precache();
      await self.skipWaiting();
      logger.info("Service worker installed");
    } catch (error) {
      logger.error("Install failed:", error);
      throw error;
    }
  })());
});
self.addEventListener("activate", (event) => {
  event.waitUntil((async () => {
    try {
      await cacheManager.cleanup();
      await self.clients.claim();
      logger.info("Service worker activated");
    } catch (error) {
      logger.error("Activation failed:", error);
      throw error;
    }
  })());
});
self.addEventListener("fetch", (event) => {
  if (event.request.method !== "GET") {
    return;
  }
  const url = new URL(event.request.url);
  if (!url.origin.startsWith(self.location.origin)) {
    return;
  }
  const isRefreshAsset = /\.(js|css|html|json)$/i.test(url.pathname);
  event.respondWith(isRefreshAsset ? CacheStrategies.staleWhileRevalidate(event.request) : CacheStrategies.cacheFirst(event.request));
});
self.addEventListener("message", (event) => {
  const payload = event.data;
  if (payload.type === "CACHE_URLS" && payload.payload && payload.payload.urls) {
    CONFIG.urls.push(...payload.payload.urls);
    for (const url of payload.payload.urls) {
      CacheStrategies.cacheFirst(new Request(url));
    }
  }
});
/**
 * Cache worker for precaching and caching strategies
 * @module cache_worker
 *
 * @license Plain-Unlicense
 * @author Adam Poulemanos <adam<at>plainlicense<dot>org>
 * @copyright No rights reserved.
 */
//# sourceMappingURL=cache_worker.QVT6E73E.js.map
