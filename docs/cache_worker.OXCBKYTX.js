/**
 * ---DO NOT EDIT THIS FILE---
 * The build process generates this file
 * You should edit the source file instead
 *
 * sources are in: src/assets/javascripts directory
 */

"use strict";
(() => {
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });

  // src/cache_worker.ts
  var import_cache_meta = __require("./cache_meta.MLCPS6VI.json");
  var CONFIG = {
    cacheName: import_cache_meta.cacheName || "plain-license-v1",
    urls: import_cache_meta.urls || [],
    version: import_cache_meta.version || Date.now()
  };
  var isDev = () => {
    const { origin, hostname, port } = self.location;
    return hostname === "localhost" || hostname === "127.0.0.1" || port === "8000" || origin.includes("localhost");
  };
  var logger = {
    error: (message, error) => {
      if (isDev()) {
        if (error instanceof CacheError) {
          console.error(`[ServiceWorker] Cache Error: ${message}`);
          console.error(error.toString());
        } else if (error instanceof NetworkError) {
          console.error(`[ServiceWorker] Network Error: ${message}`);
          console.error(`Status: ${error.status || "unknown"}`);
          console.error(error.message);
        } else if (error) {
          console.error(`[ServiceWorker] ${message}`);
          console.error(error);
        }
      }
    },
    info: (message) => {
      if (isDev()) {
        console.info(`[ServiceWorker] ${message}`);
      }
    }
  };
  var CacheError = class extends Error {
    constructor(message, cause) {
      super(message);
      this.cause = cause;
      this.name = "CacheError";
      if (cause && "cause" in Error) {
        Object.defineProperty(this, "cause", {
          value: cause,
          configurable: true,
          writable: true
        });
      }
    }
    toString() {
      return this.cause ? `${this.message}
Caused by: ${this.cause.toString()}` : this.message;
    }
  };
  var NetworkError = class extends Error {
    constructor(message, status) {
      super(message);
      this.status = status;
      this.name = "NetworkError";
      if (status) {
        this.message = `${message} (HTTP ${status})`;
      }
    }
  };
  var get_hash = (s) => {
    try {
      const split = s.split("/")[s.split("/").length - 1].split(".");
      if (split.length >= 3) {
        return split[split.length - 2];
      } else {
        return null;
      }
    } catch (_error) {
      logger.error("Failed to get hash from string:", _error);
      return null;
    }
  };
  var normalizeUrl = (url) => {
    return url instanceof URL ? url : url instanceof Request ? new URL(url.url) : new URL(url);
  };
  var normalizeRequest = (url) => {
    return url instanceof Request ? url : new Request(url);
  };
  var CacheManager = class {
    constructor() {
      this.config = CONFIG;
      this.cache = null;
      this.cacheKeys = [];
      this.init();
    }
    // gets the cache configuration
    async init() {
      this.config = CONFIG;
      this.cache = await caches.open(this.config.cacheName);
      this.cacheKeys = await caches.keys();
      this.validateConfig();
    }
    async getCache() {
      if (!this.cache) {
        this.cache = await caches.open(this.config.cacheName);
      }
      return this.cache;
    }
    async updateKeys() {
      this.cacheKeys = await caches.keys();
      return this.cacheKeys;
    }
    async getCacheKeys() {
      if (!this.cacheKeys.length) {
        this.cacheKeys = await caches.keys();
        logger.info(`Cache keys updated, keys: ${this.cacheKeys.join(", ")}`);
      }
      return this.cacheKeys;
    }
    async cacheIt(request, response) {
      request = normalizeRequest(request);
      const cache = await this.getCache();
      if (response && response.ok) {
        await cache.put(request, response.clone());
        this.cacheKeys.push(request.toString());
        logger.info("cache complete");
        return;
      }
      try {
        if (await cache.match(request)) {
          return;
        } else {
          await cache.add(request);
          this.cacheKeys.push(request.toString());
          logger.info("cache complete");
        }
      } catch (error) {
        throw new CacheError("Failed to cache url", error);
      } finally {
        await this.checkForStaleKey(request);
      }
    }
    /**
     * Validate the cache configuration
     */
    validateConfig() {
      if (!this.config.cacheName || !this.config.cacheName.length || !this.config.cacheName.trim()) {
        throw new CacheError("Cache name is required");
      }
      if (!this.config.urls || !this.config.urls.length) {
        throw new CacheError("At least one url is required. Our poor cache worker has nothing to do.");
      }
      logger.info("Cache configuration validated");
    }
    async toBaseName(s) {
      try {
        const url = normalizeUrl(s);
        const file = url.pathname.split("/")?.pop();
        const parts = file?.split(".");
        if (!parts) {
          logger.error("Failed to get base name: No parts found");
          return "";
        }
        return parts.length >= 2 ? parts.slice(0, -2).join(".") : parts[0];
      } catch (error) {
        logger.error("Failed to get base name:", error);
        return "";
      }
    }
    /**
     * Checks for and deletes stale cache keys.
     * @param url The URL/string/Request to check for stale keys against.
     */
    async checkForStaleKey(url) {
      try {
        url = normalizeUrl(url);
        const cache = await this.getCache();
        const baseName = await this.toBaseName(url);
        const staleKeys = this.cacheKeys.filter((key) => key.includes(baseName) && url.toString() !== key);
        if (staleKeys.length) {
          logger.info(`Stale keys found: ${staleKeys.join(", ")}`);
          await Promise.all(staleKeys.map((key) => cache.delete(key)));
          logger.info("Stale keys deleted");
        }
      } catch (error) {
        logger.error("Failed to check for stale keys:", error);
      }
    }
    /**
     * Cleanup old caches
     */
    async cleanup() {
      try {
        const deletionPromises = await this.getCacheKeys().then((keys) => keys.filter((key) => key !== this.config.cacheName).map((key) => caches.delete(key)));
        await Promise.all(deletionPromises);
        logger.info("Old caches cleaned up");
      } catch (error) {
        throw new CacheError("Failed to cleanup caches", error);
      }
    }
    /**
     * Precache all the urls in the cache configuration
     */
    async precache() {
      try {
        const cache = await this.getCache();
        await cache.addAll(this.config.urls);
        for (const url of this.config.urls) {
          await this.checkForStaleKey(url);
        }
        logger.info("Precaching complete");
      } catch (error) {
        throw new CacheError("Failed to precache urls", error);
      }
    }
    /**
     * Attempt to fetch a resource
     * @param request Request | string | URL - request to fetch
     * @param init RequestInit - request options
     * @returns Promise<Response> - response
     */
    async tryFetch(request, init) {
      try {
        const response = await fetch(request, init);
        if (!response.ok) {
          throw new NetworkError("Network response was not ok", response.status);
        }
        this.cacheKeys.push(request.toString());
        return response;
      } catch (error) {
        logger.error("Failed to fetch:", error);
        throw new NetworkError(`Failed to fetch request for ${request.toString()}`, 500);
      } finally {
        await this.checkForStaleKey(request);
      }
    }
    /**
     * Fallback fetch for failed fetches. Attempts to remove the hash from the url and fetch again. We're basically checking if the build process went wrong.
     * @param request Request | string | URL - request to fetch
     * @param init RequestInit - request options
     * @returns Promise<Response> - response
     */
    async fallbackFetch(request, init) {
      request = normalizeRequest(request);
      const response = await fetch(request, init);
      if (response.ok) {
        return response;
      } else {
        const errorMessage = response instanceof Response ? await response.json() : "No response";
        logger.error("Failed to fetch:", new Error(errorMessage));
        logger.error("Attempting fallback fetch");
        const url = normalizeUrl(request);
        const hash = get_hash(url.pathname);
        if (!hash && url.origin === self.location.origin) {
          const file = url.pathname.split("/")?.pop();
          const parts = file?.split(".");
          const name = parts?.slice(0, -1).join(".");
          const ext = parts?.slice(-1)[0];
          const hashlessUrl = new RegExp(`${name}.[a-fA-F0-9]{8}.${ext}`);
          const inConfig = this.config.urls.find((u) => hashlessUrl.test(u));
          if (inConfig) {
            return this.tryFetch(inConfig, init);
          }
        }
        return this.tryFetch(url.pathname.replace(`.${hash}`, ""), init);
      }
    }
  };
  var cacheManager = new CacheManager();
  var CacheStrategies = class {
    /**
     * Cache first strategy
     * @param request Request
     * @returns Promise<Response>
     */
    static async cacheFirst(request) {
      request = normalizeRequest(request);
      const cache = await cacheManager.getCache();
      const cached = await cache.match(request);
      if (cached) {
        return cached;
      }
      try {
        const response = await cacheManager.fallbackFetch(request);
        if (!response.ok) {
          throw new NetworkError("Network response was not ok", response.status);
        }
        await cacheManager.cacheIt(request, response.clone());
        return response;
      } catch (error) {
        logger.error("Cache first strategy failed:", error);
        throw error;
      }
    }
    /**
     * Stale while revalidate strategy
     * @param request Request
     * @returns Promise<Response>
     */
    static async staleWhileRevalidate(request) {
      const cache = await cacheManager.getCache();
      const cached = await cache.match(request);
      const networkPromise = await cacheManager.fallbackFetch(request).then((response) => {
        if (!response.ok) {
          throw new NetworkError("Network response was not ok", response.status);
        }
        cacheManager.cacheIt(request, response.clone());
        return response;
      }).catch((error) => {
        logger.error("Network fetch failed:", error);
        throw error;
      });
      return cached ?? networkPromise;
    }
  };
  self.addEventListener("install", (event) => {
    event.waitUntil((async () => {
      try {
        await cacheManager.init();
        await self.skipWaiting();
        await cacheManager.precache();
        logger.info("Service worker installed");
      } catch (error) {
        logger.error("Install failed:", error);
        throw error;
      }
    })());
  });
  self.addEventListener("activate", (event) => {
    event.waitUntil((async () => {
      try {
        await cacheManager.cleanup();
        await self.clients.claim();
        logger.info("Service worker activated");
      } catch (error) {
        logger.error("Activation failed:", error);
        throw error;
      }
    })());
  });
  self.addEventListener("fetch", (event) => {
    if (event.request.method !== "GET") {
      return;
    }
    const url = new URL(event.request.url);
    if (!url.origin.startsWith(self.location.origin)) {
      return;
    }
    const isRefreshAsset = /\.(js|css|html|json)$/i.test(url.pathname);
    event.respondWith(isRefreshAsset ? CacheStrategies.staleWhileRevalidate(event.request) : CacheStrategies.cacheFirst(event.request));
    logger.info(`Fetching: ${url.pathname}`);
  });
  self.addEventListener("message", (event) => {
    const payload = event.data;
    if (payload.type === "CACHE_URLS" && payload.payload && payload.payload.urls) {
      CONFIG.urls.push(...payload.payload.urls);
      for (const url of payload.payload.urls) {
        CacheStrategies.cacheFirst(new Request(url));
      }
    }
  });
})();
/**
 * Cache worker for precaching and caching strategies
 * @module cache_worker
 *
 * @license Plain-Unlicense
 * @author Adam Poulemanos <adam<at>plainlicense<dot>org>
 * @copyright No rights reserved.
 */
//# sourceMappingURL=cache_worker.OXCBKYTX.js.map
